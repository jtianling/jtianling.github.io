---
layout: post
title: "当n非常非常大时（比如为1万），求n!问题的学习，解答和疑问。"
categories:
- C++
tags:
- C++
status: publish
type: post
published: true
meta:
  ratings_users: '0'
  ratings_score: '0'
  ratings_average: '0'
  views: '13'
author:
  login: jtianling
  email: jtianling@gmail.com
  display_name: jtianling
  first_name: ''
  last_name: ''
---
<p>
&nbsp;</p>
<p>欢迎转载，但请标明作者 &ldquo;九天雁翎&rdquo;，当然，你给出这个帖子的链接更好。</p>
<p>首先说明，这本来是钱能C++程序设计习题及解答中的一个习题。也就是在自然数范围内求n!，其实用他的方法还不能说在自然树范围内，按他的方法，不考虑机子性能，最多可以算到2^32-1（32位机），原题解答如下：</p>
<p>程序1：</p>
<p>#include &lt;iostream&gt;<br />#include &lt;iomanip&gt;<br />#include &lt;cmath&gt;<br />#include &lt;cstdlib&gt;<br />using namespace std;<br />//--------------------------------------------------------------------<br />int getN();<br />int getBitNum(int n);<br />char *init(int size);<br />void calc(char *a,int n);<br />void display(char *a,int size);<br />//--------------------------------------------------------------------<br />int main()<br />{<br />&nbsp;int n = getN();<br />&nbsp;int size = getBitNum(n);<br />&nbsp;char *pa = init(size);<br />&nbsp;calc(pa,n);<br />&nbsp;display(pa,size);<br />&nbsp;delete []pa;<br />&nbsp;return 0;<br />}<br />//----------------------------------------------------------------------<br />int getN()<br />{<br />&nbsp;int n;<br />&nbsp;cout &lt;&lt;&quot;请输入n!中的n:&quot;;<br />&nbsp;cin &gt;&gt;n;<br />&nbsp;while(n&lt;0)<br />&nbsp;{<br />&nbsp;&nbsp;cout &lt;&lt;&quot;输入有错，请重输：&quot;;<br />&nbsp;&nbsp;cin &gt;&gt;n;<br />&nbsp;}<br />&nbsp;if(n == 0)<br />&nbsp;&nbsp;exit(1);<br />&nbsp;return n;<br />}<br />//--------------------------------------------------------------------<br />int getBitNum(int n)<br />{<br />&nbsp;double sum = 1.0;<br />&nbsp;for(int i = 1;i &lt;= n;++i)<br />&nbsp;&nbsp;sum += log10(double(i));<br />&nbsp;return int(sum);<br />}<br />//--------------------------------------------------------------------<br />char *init(int size)<br />{<br />&nbsp;char *pa = new char[size];<br />&nbsp;if(!pa)<br />&nbsp;{<br />&nbsp;&nbsp;cout&lt;&lt;&quot;Too large factor of&quot;&lt;&lt;size&lt;&lt;endl;<br />&nbsp;&nbsp;exit(1);<br />&nbsp;}<br />&nbsp;pa[0] = 1;<br />&nbsp;for(int i = 1;i &lt;size;++i)<br />&nbsp;&nbsp;pa[i] = 0;<br />&nbsp;return pa;<br />}<br />//--------------------------------------------------------------------<br />void calc(char *a,int n)<br />{<br />&nbsp;double bitcount = 1;<br />&nbsp;int begin = 0;<br />&nbsp;for(int i = 2;i &lt;= n;++i)<br />&nbsp;{<br />&nbsp;&nbsp;long and = 0;<br />&nbsp;&nbsp;bitcount += log10(double(i));<br />&nbsp;&nbsp;if(a[begin] == 0)<br />&nbsp;&nbsp;&nbsp;++begin;<br />&nbsp;&nbsp;for(int j = begin;j &lt; int(bitcount); ++j)<br />&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;and += i * a[j];<br />&nbsp;&nbsp;&nbsp;a[j] = char(and % 10);<br />&nbsp;&nbsp;&nbsp;and /= 10;<br />&nbsp;&nbsp;}<br />&nbsp;}<br />}<br />//--------------------------------------------------------------------<br />void display(char *a,int size)<br />{<br />&nbsp;int bit = 0;<br />&nbsp;for(int i = size - 1;i &gt;= 0; --i)<br />&nbsp;{<br />&nbsp;&nbsp;if(bit % 50 == 0)<br />&nbsp;&nbsp;&nbsp;cout &lt;&lt;endl&lt;&lt;&quot;第&quot;&lt;&lt;setw(3)&lt;&lt;(bit/50+1)&lt;&lt;&quot;个50位:&quot;;<br />&nbsp;&nbsp;cout &lt;&lt;(int)a[i];<br />&nbsp;&nbsp;++bit;<br />&nbsp;}<br />&nbsp;cout &lt;&lt;endl;<br />}<br />//--------------------------------------------------------------------</p>
<p>程序的运行效率和结构化设计都很不错，这里赞一句清华大学钱能教授的C语言编程水平，注意，仅仅是佩服他的C语言编程水平而已，这根本就不能算是一个好的C++程序，虽然他是在一个C++教程里面给出来的。我把自己按他的算法重新编写了代码，没有他那么好看了，但是因为int明显是正的，所以用了unsigned类型的size_t，这样就让n可接受的范围到了2^32-1。</p>
<p>程序2：</p>
<p>#include &lt;iostream&gt;<br />#include &lt;iomanip&gt;<br />#include &lt;cmath&gt;<br />#include &lt;cstdlib&gt;<br />using namespace std;</p>
<p>size_t getbit(const size_t &amp;aN);<br />void init(unsigned char *p,size_t &amp;am);<br />void compute(unsigned char *p,const size_t &amp;an);<br />void print(unsigned char *p,const size_t &amp;am);<br />int main()<br />{<br />&nbsp;cout &lt;&lt;&quot;Input the /&quot;n/&quot; you want to compute:&quot;;<br />&nbsp;size_t n;<br />&nbsp;cin &gt;&gt; n;<br />&nbsp;if(n == 0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //检验输入<br />&nbsp;{<br />&nbsp;&nbsp;cerr&lt;&lt;&quot;Please input a integer more than zero.&quot;&lt;&lt;endl;<br />&nbsp;}<br />&nbsp;size_t m = getbit(n);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;unsigned char *pn = new unsigned char[m];<br />&nbsp;if(!pn)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //检验空间分配<br />&nbsp;{<br />&nbsp;&nbsp;cerr&lt;&lt;&quot;The factor is too big.&quot;&lt;&lt;endl;<br />&nbsp;}<br />&nbsp;init(pn,m);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //初始化<br />&nbsp;compute(pn,n);&nbsp;&nbsp; //计算n!<br />&nbsp;print(pn,m);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //输出<br />&nbsp;delete []pn;<br />&nbsp;return 0;<br />}<br />//-----------------------------------------------------------<br />size_t getbit(const size_t &amp;aN)<br />{<br />&nbsp;double sum = 1.0;<br />&nbsp;for(size_t i = 1;i&lt;=aN;++i)<br />&nbsp;{<br />&nbsp;&nbsp;sum+=log10(double(i));<br />&nbsp;}<br />&nbsp;return size_t(sum);<br />}<br />//------------------------------------------------------------<br />void init(unsigned char *p,size_t &amp;am)<br />{<br />&nbsp;p[0]=1;<br />&nbsp;for(size_t i = 1;i != am;++i)<br />&nbsp;{<br />&nbsp;&nbsp;p[i] = 0;<br />&nbsp;}<br />}<br />//------------------------------------------------------------<br />void compute(unsigned char *p,const size_t &amp;an)<br />{<br />&nbsp;double bitcount = 1.1;<br />&nbsp;size_t begin = 0;<br />&nbsp;for(size_t i = 2;i&lt;=an;++i)<br />&nbsp;{<br />&nbsp;&nbsp;size_t and = 0;<br />&nbsp;&nbsp;bitcount +=log10(double(i));<br />&nbsp;&nbsp;if(p[begin]==0)<br />&nbsp;&nbsp;&nbsp;++begin;<br />&nbsp;&nbsp;for(size_t j = begin ; j &lt; size_t(bitcount);++j)<br />&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;and += i * p[j];<br />&nbsp;&nbsp;&nbsp;p[j] = unsigned char(and % 10);<br />&nbsp;&nbsp;&nbsp;and /= 10;<br />&nbsp;&nbsp;}<br />&nbsp;}<br />}<br />//----------------------------------------------------------------<br />void print(unsigned char *p,const size_t &amp;am)<br />{<br />&nbsp;&nbsp;size_t bit = 0;<br />&nbsp;for(size_t i = am;i != 0;--i)<br />&nbsp;{<br />&nbsp;&nbsp;if(bit % 50 == 0)<br />&nbsp;&nbsp;&nbsp;cout &lt;&lt;endl&lt;&lt;&quot;第&quot;&lt;&lt;setw(3)&lt;&lt;(bit/50+1)&lt;&lt;&quot;个50位:&quot;;<br />&nbsp;&nbsp;cout &lt;&lt; size_t(p[i-1]);<br />&nbsp;&nbsp;++bit;<br />&nbsp;}<br />&nbsp;cout&lt;&lt;endl;<br />}</p>
<p>我这里几乎都继承了钱能的算法，哪怕结构都差不多，仅仅是改变成了unsigned，可是竟然有问题，在运行时，当n比较小时（如50），有的时候会出错，大的时候反而不会（比如1000，2000），不知道是为什么。为了方便以后的使用，并体现一点C++的精神，我把这个程序作成一个类，就变成下面这样.</p>
<p>程序3：</p>
<p>Factor.h:</p>
<p>#pragma once<br />typedef&nbsp; unsigned char unchar;<br />class Factor<br />{<br />size_t n;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //求n的n!<br />size_t m;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //n!有多少位<br />unchar *pc;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //动态分配的数组指针<br />private:<br />&nbsp;void getbit();<br />&nbsp;void compute();&nbsp;&nbsp; //计算n!<br />&nbsp;void init();<br />&nbsp;Factor(Factor &amp;);<br />public:<br />&nbsp;void print()const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //输出<br />&nbsp;Factor(const size_t &amp;);<br />&nbsp;~Factor(void);<br />&nbsp;<br />};</p>
<p>Factor.cpp</p>
<p>#include &quot;Factor.h&quot;<br />#include &lt;iostream&gt;<br />#include &lt;cmath&gt;<br />#include &lt;iomanip&gt;<br />using namespace std;</p>
<p>Factor::Factor(const size_t &amp;nval)<br />{<br />&nbsp;if(nval == 0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //检验输入<br />&nbsp;{<br />&nbsp;cerr&lt;&lt;&quot;Please input a integer more than zero.&quot;&lt;&lt;endl;<br />&nbsp;}<br />&nbsp;n = nval;<br />&nbsp;init();<br />}<br />Factor::~Factor()<br />{<br />&nbsp;delete []pc;<br />}<br />void Factor::init()<br />{<br />&nbsp;getbit();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;pc = new unchar[m];<br />&nbsp;if(!pc)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //检验空间分配<br />&nbsp;{<br />&nbsp;&nbsp;cerr&lt;&lt;&quot;The factor is too big.&quot;&lt;&lt;endl;<br />&nbsp;}<br />&nbsp;pc[0]=1;<br />&nbsp;for(size_t i = 1;i &lt; m;++i)<br />&nbsp;{<br />&nbsp;&nbsp;pc[i] = 0;<br />&nbsp;}<br />&nbsp;compute();<br />}</p>
<p>void Factor::getbit()<br />{<br />&nbsp;double sum = 1.0;<br />&nbsp;for(size_t i = 1;i&lt;=n;++i)<br />&nbsp;{<br />&nbsp;&nbsp;sum+=log10(double(i));<br />&nbsp;}<br />&nbsp;m = size_t(sum);<br />}<br />//------------------------------------------------------------<br />void Factor::compute()<br />{<br />&nbsp;double bitcount = 1.1;<br />&nbsp;size_t begin = 0;<br />&nbsp;for(size_t i = 2;i&lt;=n;++i)<br />&nbsp;{<br />&nbsp;&nbsp;size_t and = 0;<br />&nbsp;&nbsp;bitcount +=log10(double(i));<br />&nbsp;&nbsp;if(pc[begin]==0)<br />&nbsp;&nbsp;&nbsp;++begin;<br />&nbsp;&nbsp;for(size_t j = begin ; j &lt; size_t(bitcount);++j)<br />&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;and += i * pc[j];<br />&nbsp;&nbsp;&nbsp;pc[j] = unchar(and % 10);<br />&nbsp;&nbsp;&nbsp;and /= 10;<br />&nbsp;&nbsp;}<br />&nbsp;}<br />}<br />//----------------------------------------------------------------<br />void Factor::print()const<br />{<br />&nbsp;&nbsp;size_t bit = 0;<br />&nbsp;for(size_t i = m;i != 0;--i)<br />&nbsp;{<br />&nbsp;&nbsp;if(bit % 50 == 0)<br />&nbsp;&nbsp;&nbsp;cout &lt;&lt;endl&lt;&lt;&quot;第&quot;&lt;&lt;setw(3)&lt;&lt;(bit/50+1)&lt;&lt;&quot;个50位:&quot;;<br />&nbsp;&nbsp;cout &lt;&lt; size_t(pc[i-1]);<br />&nbsp;&nbsp;++bit;<br />&nbsp;}<br />&nbsp;cout&lt;&lt;endl;<br />}</p>
<p>&nbsp;</p>
<p>main.cpp</p>
<p>#include &quot;Factor.h&quot;<br />#include &lt;iostream&gt;<br />using namespace std;<br />int main()<br />{<br />&nbsp;size_t anum;<br />&nbsp;cout&lt;&lt;&quot;Input the number you want to compute:&quot;;<br />&nbsp;cin &gt;&gt;anum;<br />&nbsp;Factor a(anum);<br />&nbsp;cout&lt;&lt;&quot;the &quot;&lt;&lt;anum&lt;&lt;&quot;! is:&quot;&lt;&lt;endl;<br />&nbsp;a.print();<br />&nbsp;return 0;<br />}</p>
<p>主程序仅仅是用来测试，这个类可以比较好的计算n!，问题是还是有些类似程序2的问题，我也是很困惑，难道是因为用了无符号的问题？因为这2个程序和原题答案这是个最大的区别，其他几乎一样。然后我为了用上C++的STL特性，编写了如下代码：</p>
<p>程序4：</p>
<p>Factor.h:</p>
<p>#pragma once<br />#include &lt;vector&gt;<br />class Factor<br />{<br />size_t n;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //求n的n!<br />std::vector&lt;size_t&gt; vec;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //储存结果的vector<br />private:<br />&nbsp;void compute();&nbsp;&nbsp; //计算n!<br />&nbsp;void init();<br />&nbsp;Factor(Factor &amp;);<br />public:<br />&nbsp;void print();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //输出<br />&nbsp;Factor(const size_t &amp;);<br />&nbsp;~Factor(void);<br />};</p>
<p>Factor.cpp</p>
<p>#include &quot;Factor.h&quot;<br />#include &lt;iostream&gt;<br />#include &lt;cmath&gt;<br />#include &lt;cmath&gt;<br />#include &lt;iomanip&gt;<br />using namespace std;<br />typedef vector&lt;size_t&gt;::iterator iter;</p>
<p>Factor::Factor(const size_t &amp;nval)<br />{<br />&nbsp;if(nval == 0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //检验输入<br />&nbsp;{<br />&nbsp;cerr&lt;&lt;&quot;Please input a integer more than zero.&quot;&lt;&lt;endl;<br />&nbsp;}<br />&nbsp;n = nval;<br />&nbsp;compute();<br />}<br />Factor::~Factor()<br />{<br />}<br />//------------------------------------------------------------<br />void Factor::compute()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //这个最主要的函数有问题<br />{<br />&nbsp;vec.push_back(1);<br />&nbsp;for(size_t i = 2;i&lt;=n;++i)<br />&nbsp;{<br />&nbsp;&nbsp;size_t and = 0;<br />&nbsp;&nbsp;for(iter it = vec.begin();it != vec.end();)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //每次都计算了end()，但是还是出错，不知道为什么<br />&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;and += i * (*it);<br />&nbsp;&nbsp;&nbsp;*(it++) = and % 10; <br />&nbsp;&nbsp;&nbsp;if(and /= 10)<br />&nbsp;&nbsp;&nbsp;&nbsp;if(it == vec.end())<br />&nbsp;&nbsp;&nbsp;&nbsp;{<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vec.push_back(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //知道这个操作会改变容器<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;<br />&nbsp;&nbsp;&nbsp;&nbsp;}<br />&nbsp;&nbsp;}<br />&nbsp;}<br />}<br />//----------------------------------------------------------------<br />void Factor::print()<br />{<br />&nbsp;&nbsp;size_t bit = 0;<br />&nbsp;for(iter it = vec.end();it != vec.begin();--it)<br />&nbsp;{<br />&nbsp;&nbsp;if(bit % 50 == 0)<br />&nbsp;&nbsp;&nbsp;cout &lt;&lt;endl&lt;&lt;&quot;第&quot;&lt;&lt;setw(3)&lt;&lt;(bit/50+1)&lt;&lt;&quot;个50位:&quot;;<br />&nbsp;&nbsp;cout &lt;&lt; size_t( *(it-1) );<br />&nbsp;&nbsp;++bit;<br />&nbsp;}<br />&nbsp;cout&lt;&lt;endl;<br />}</p>
<p>&nbsp;</p>
<p>这个程序利用了vector容器的动态添加，不需要一次添加那么多，不过感觉执行效率也许并比不上一次添加那么多，不过程序的大部分理解起来要更简单了，比如不需要提前用对数算好需要多少空间，这可以减轻很多负担，特别是根本不知道怎么算的时候，但是这样做付出了代价，就是主运算函数明显更加复杂，因为你还要在循环里面动态处理vector，我就是在这个里面出了问题，请高人给我一些提示。<br />&nbsp;</p>
