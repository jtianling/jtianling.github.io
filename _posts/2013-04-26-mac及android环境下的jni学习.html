---
layout: post
title: Mac及Android环境下的JNI学习
categories:
- Android
- Java
tags:
- Jni
status: publish
type: post
published: true
meta:
  mkd_text: "$TOC$\n\n# 简介\nJNI就是Java Native Interface, 也可以理解为一般脚本语言的C API, 一般情况下这种API的学习都是一种痛苦的精力,
    从来如此, 没有太多技术含量, 就是一堆晦涩难以理解的编程模型, 编程接口, 充斥着各种从当前语言到C语言的类型转换.  基本的含义就是用C语言的思维去表示当前的语言,
    这个问题在Lua语言中到达了极致.  不管是多么为了效率, 一个纯堆栈操作的编程接口都像汇编语言一样难以使用.  \n因为最近又开始做Android游戏了,
    用的是cocos2d-x, JNI是难以避免了, 以前的使用都是照猫画虎似的写几个函数调用接口, 总感觉有问题, 今天好好的学习学习吧.  \n与一般关于JNI文章稍微有些不一样的是,
    本文会更多的关注于Android相关的问题.  \n  \n本文使用的环境是:   \nMac OS X 10.8.3  \njava version \"1.6.0_43\"
    \ \nJava(TM) SE Runtime Environment (build 1.6.0_43-b01-447-11M4203)  \nJava HotSpot(TM)
    64-Bit Server VM (build 20.14-b01-447, mixed mode)  \ngcc version 4.2.1 (Based
    on Apple Inc. build 5658) (LLVM build 2336.11.00)  \nAndroid SDK API 17\nAndroid
    ndk r8d\n  \n# 从Java中调用C/C++库\n从Java中调用C/C++库的典型使用场景就是在Android中Load自己写的游戏库, 然后运行.
    \ 虽然有cocos2d-x引擎的时候你几乎不用关心这个.  \n\n## Hello World\n从R&D开始, Hello World就成了一开始必用的例子了,
    学习JNI也从这个开始吧.  \n首先构建一个最简单的Java class:  \n\n    :::java\n    // HelloWorld.java\n
    \   import java.lang.System.*;\n\n    public class HelloWorld {\n      public
    native void SayHelloWorld();\n\n      public static void main(String[] args) {\n
    \       System.loadLibrary(\"helloworld\");\n\n        HelloWorld helloworld =
    new HelloWorld();\n        helloworld.SayHelloWorld();\n      }\n    }\n  \n\nnative关键字表示的接口就是需要用C/C++来实现的接口,
    System.loadLibrary调用的就是将会实现的jni库.  \n然后用javac将文件编译成字节码:  \n\n    :::sh\n    javac
    HelloWorld.java\n\n生成HelloWorld.class, java中最人性的一点就是把binding的生成直接作为标准了, 这一点比Python和lua要强多了,
    也使得JNI的使用是我接触过的语言中, 类似C API最方便的一个.  直接生成C/C++ binding头文件的方式是用javah命令:  \n\n    :::sh\n
    \   javah HelloWorld\n\n从上面的HelloWorld类生成的头文件如下:  \n\n    :::c++\n    /* DO NOT
    EDIT THIS FILE - it is machine generated */\n    #include <jni.h>\n    /* Header
    for class HelloWorld */\n\n    #ifndef _Included_HelloWorld\n    #define _Included_HelloWorld\n
    \   #ifdef __cplusplus\n    extern \"C\" {\n    #endif\n      /*\n       * Class:
    \    HelloWorld\n       * Method:    SayHelloWorld\n       * Signature: ()V\n
    \      */\n      JNIEXPORT void JNICALL Java_HelloWorld_SayHelloWorld\n        (JNIEnv
    *, jobject);\n\n    #ifdef __cplusplus\n    }\n    #endif\n    #endif\n\n这实在是相当人性化了,
    我们只需要包含HelloWorld.h头文件, 然后实现按照头文件给的签名实现Java_HelloWorld_SayHelloWorld函数就行了, 而不用自己去记住这么复杂的函数名和参数.
    \ 实现的HelloWorld.cc文件如下:  \n\n    :::c++\n    // HelloWorld.cc\n    #include \"HelloWorld.h\"\n
    \   #include <cstdio>\n\n    JNIEXPORT void JNICALL Java_HelloWorld_SayHelloWorld(JNIEnv
    *, jobject) {\n      printf(\"HelloWorld.\\n\");\n    }\n\n\n编译C++代码的时候在MacOS下和在Linux,
    Windows有所不同, 不是编译成.so或者dll, 而是MacOS自己的jnilib.  并且jni.h的目录也比较特殊, 是`/System/Library/Frameworks/JavaVM.framework/Headers/`,
    这个需要稍微注意一下,  具体的命令如下: \n\n    :::sh\n    g++ -dynamiclib -o libhelloworld.jnilib
    HelloWorld.cc -framework JavaVM -I/System/Library/Frameworks/JavaVM.framework/Headers\n\n此时一切就绪:
    \ \n\n    :::sh\n    >java HelloWorld\n    HelloWorld.\n\n## 带参数的函数\n两个语言之间的来回调用,
    在没有任何参数的情况下还好, 有了参数以后, 因为牵涉到两个语言对类型的不同表示方式, 需要进行类型转换, 是最麻烦的地方, 比如在Lua, Python中,
    使用C API时, 你就需要记住Lua和Python的各种类型分别对应C语言中的哪个类型, JAVA中在调用C/C++函数时, 在Java中通过javah部分缓解了这个问题,
    可以让我们直接知道对应的类型是哪一个, 不过具体每个用C语言表示的JAVA类型该怎么用, 还是查文档吧, 比如下面这个例子:  \n\n    :::java\n
    \   // ArugmentTest.java\n    import java.lang.System.*;\n\n    public class ArgumentTest
    {\n      public native int intMethod(int n);\n      public native boolean booleanMethod(boolean
    bool);\n      public native String stringMethod(String text);\n      public native
    int intArrayMethod(int[] intArray);\n\n      public static void main(String[]
    args) {\n        System.loadLibrary(\"argumenttest\");\n\n        ArgumentTest
    obj = new ArgumentTest();\n\n        System.out.println(\"intMethod: \" + obj.intMethod(5));\n
    \       System.out.println(\"booleanMethod: \" + obj.booleanMethod(true));\n        System.out.println(\"stringMethod:
    \" + obj.stringMethod(\"JAVA\"));\n        System.out.println(\"intArrayMethod:
    \" + obj.intArrayMethod(new int[]{1,2,3,4,5}));\n      }\n    }\n  \n\n编译后, 用javah生成的头文件如下:
    \ \n\n    :::c++\n    /* DO NOT EDIT THIS FILE - it is machine generated */\n
    \   #include <jni.h>\n    /* Header for class ArgumentTest */\n    \n    #ifndef
    _Included_ArgumentTest\n    #define _Included_ArgumentTest\n    #ifdef __cplusplus\n
    \   extern \"C\" {\n    #endif\n    /*\n     * Class:     ArgumentTest\n     *
    Method:    intMethod\n     * Signature: (I)I\n     */\n    JNIEXPORT jint JNICALL
    Java_ArgumentTest_intMethod\n      (JNIEnv *, jobject, jint);\n    \n    /*\n
    \    * Class:     ArgumentTest\n     * Method:    booleanMethod\n     * Signature:
    (Z)Z\n     */\n    JNIEXPORT jboolean JNICALL Java_ArgumentTest_booleanMethod\n
    \     (JNIEnv *, jobject, jboolean);\n    \n    /*\n     * Class:     ArgumentTest\n
    \    * Method:    stringMethod\n     * Signature: (Ljava/lang/String;)Ljava/lang/String;\n
    \    */\n    JNIEXPORT jstring JNICALL Java_ArgumentTest_stringMethod\n      (JNIEnv
    *, jobject, jstring);\n    \n    /*\n     * Class:     ArgumentTest\n     * Method:
    \   intArrayMethod\n     * Signature: ([I)I\n     */\n    JNIEXPORT jint JNICALL
    Java_ArgumentTest_intArrayMethod\n      (JNIEnv *, jobject, jintArray);\n    \n
    \   #ifdef __cplusplus\n    }\n    #endif\n    #endif\n    \n这里我们可以看到, 大概的类型对应关系:\nObject=>jobject
    \ \nint=>jint  \nboolean=>jboolean  \nString=>jstring  \nint[]=>jintArray  \n\n但是,
    jobject, jstring, jintArray具体怎么使用, 总归得再学习一遍.  但是javah的存在还是非常有意义的, 起码我们不用记哪个类型该查什么文档了.
    \ \n实现的C++文件如下:  \n\n    :::c++\n    // ArgumentTest.cc\n    \n    #include \"ArgumentTest.h\"\n
    \   #include <cstring>\n    \n    using namespace std;\n    \n    JNIEXPORT jint
    JNICALL Java_ArgumentTest_intMethod(JNIEnv *env, jobject obj, jint num) {\n      return
    num * num; \n    }\n    \n    JNIEXPORT jboolean JNICALL Java_ArgumentTest_booleanMethod(JNIEnv
    *env, jobject obj, jboolean boolean) {\n      return !boolean;\n    }\n    \n
    \   JNIEXPORT jstring JNICALL Java_ArgumentTest_stringMethod(JNIEnv *env, jobject
    obj, jstring str) {\n      const char *cstr = env->GetStringUTFChars(str, 0);\n
    \     char cap[128] = \"language: \";\n      strcat(cap, cstr);\n      env->ReleaseStringUTFChars(str,
    cstr);\n      return env->NewStringUTF(cap);\n    }\n    \n    JNIEXPORT jint
    JNICALL Java_ArgumentTest_intArrayMethod(JNIEnv *env, jobject obj, jintArray array)
    {\n      jsize len = env->GetArrayLength(array);\n      jint *body = env ->GetIntArrayElements(array,
    0);\n      int sum = 0;\n      for (int i=0; i<len; ++i) {\n        sum += body[i];\n
    \     }\n      env->ReleaseIntArrayElements(array, body, 0);\n      return sum;\n
    \   }\n\n这里可以看到几个特殊的函数, GetStringUTFChars, GetArrayLength, GetIntArrayElements,
    ReleaseIntArrayElements等, 还好都不算太复杂.  一旦用了JNI, 需要注意的就是, 你资源的分配释放, 就得和C/C++中一样了,
    得自己手动来.  \n另外, 还值得一提的是, 因为C++对类的直接支持, 所以C++中可以用比C语言更简洁的语法, 大概的区别看了下面的示例:  \nC代码:
    `(*env)->GetStringUTFChars(env, string, 0);`\nC++代码: `env->GetStringUTFChars(string,
    0);`\n\n## Android中的情况\n其实实现和使用方式都类似, 只是编译时, 需要使用不同的命令, 其实因为Android其实就是一种特殊的Linux,
    所以对于Android来说, 生成方式和Linux类似, 并且都是生成Unix/Linux通用的`.so`动态库文件.  \n另外, 还有一些典型的Android的问题,
    比如在Android中去完成前面的ArugmentTest:  \n\n    :::java\n    import android.util.Log;\n
    \   import android.app.Activity;\n    import android.view.View;\n    import android.os.Bundle;\n\n
    \   public class ArgumentTest extends Activity\n    {\n      private static final
    String LOG_TAG = \"ArugmenetTest\";\n\n      public native int intMethod(int n);\n\n
    \     public native boolean booleanMethod(boolean bool);\n\n      public native
    String stringMethod(String text);\n\n      public native int intArrayMethod(int[]
    intArray);\n\n        /** Called when the activity is first created. */\n        @Override\n
    \       public void onCreate(Bundle savedInstanceState)\n        {\n            super.onCreate(savedInstanceState);\n\n
    \           /* Create a TextView and set its content.\n             * the text
    is retrieved by calling a native\n             * function.\n             */\n
    \           Log.v(LOG_TAG, \"begin.\\n\");\n            View v = new View(this);\n
    \           setContentView(v);\n            \n            Log.v(LOG_TAG, \"intMethod:
    \" + this.intMethod(5));\n            Log.v(LOG_TAG, \"booleanMethod: \" + this.booleanMethod(true));\n
    \           Log.v(LOG_TAG, \"stringMethod: \" + this.stringMethod(\"JAVA\"));\n
    \           Log.v(LOG_TAG, \"intArrayMethod: \" + this.intArrayMethod(new int[]{1,2,3,4,5}));\n
    \       }\n\n        static {\n          System.loadLibrary(\"argument_test\");\n
    \       }\n    }\n  \n需要注意的是, Android中就不要使用System.out这种标准JAVA的库输出了, 用的是android.util.Log这个再LogCat输出的类.
    \ 然后, 作为Android的工程, 一个Activity是必须的, 这里就把ArgumentTest做成了Activity了.  \n编译的时候需要注意,
    一方面在Android中, 我们肯定需要指定一个自己的package, 不能像前面那边随意了, 这里的pakcage我用的是com.jtianling.ArgumentTest,
    另外, 还需要指定一下android的classpath:  \n\n    :::sh\n    >javac -d ../jni/ com/jtianling/ArgumentTest/ArgumentTest.java
    -classpath ~/android/sdk/platforms/android-17/android.jar\n\n同样的, pacakge在用javah的时候也必不可少,
    不然就算生成了.so, 其实package对不上也是找不到的.  首先进入jni目录, 然后用下面的命令, 指定好package.  \n\n    :::sh\n
    \   >javah com.jtianling.ArgumentTest.ArgumentTest\n\n此时生成的头文件是带package信息的, 大概是下面这样子:
    \ \n`com_jtianling_ArgumentTest_ArgumentTest.h`  \n  \n文件的函数名也是类似, 也附带了package的信息:
    \ \n\n    :::c++\n    /* DO NOT EDIT THIS FILE - it is machine generated */\n
    \   #include <jni.h>\n    /* Header for class com_jtianling_ArgumentTest_ArgumentTest
    */\n    \n    #ifndef _Included_com_jtianling_ArgumentTest_ArgumentTest\n    #define
    _Included_com_jtianling_ArgumentTest_ArgumentTest\n    #ifdef __cplusplus\n    extern
    \"C\" {\n    #endif\n    /*\n     * Class:     com_jtianling_ArgumentTest_ArgumentTest\n
    \    * Method:    intMethod\n     * Signature: (I)I\n     */\n    JNIEXPORT jint
    JNICALL Java_com_jtianling_ArgumentTest_ArgumentTest_intMethod\n      (JNIEnv
    *, jobject, jint);\n    \n    /*\n     * Class:     com_jtianling_ArgumentTest_ArgumentTest\n
    \    * Method:    booleanMethod\n     * Signature: (Z)Z\n     */\n    JNIEXPORT
    jboolean JNICALL Java_com_jtianling_ArgumentTest_ArgumentTest_booleanMethod\n
    \     (JNIEnv *, jobject, jboolean);\n    \n    /*\n     * Class:     com_jtianling_ArgumentTest_ArgumentTest\n
    \    * Method:    stringMethod\n     * Signature: (Ljava/lang/String;)Ljava/lang/String;\n
    \    */\n    JNIEXPORT jstring JNICALL Java_com_jtianling_ArgumentTest_ArgumentTest_stringMethod\n
    \     (JNIEnv *, jobject, jstring);\n    \n    /*\n     * Class:     com_jtianling_ArgumentTest_ArgumentTest\n
    \    * Method:    intArrayMethod\n     * Signature: ([I)I\n     */\n    JNIEXPORT
    jint JNICALL Java_com_jtianling_ArgumentTest_ArgumentTest_intArrayMethod\n      (JNIEnv
    *, jobject, jintArray);\n    \n    #ifdef __cplusplus\n    }\n    #endif\n    #endif\n\n同样的,
    按照签名和函数名实现即可, 在一个典型的Android工程中, jni相关的C/C++代码都是放在工程的jni目录下, 我们还需在此目录配置Android.mk文件,
    大概如下:  \n\n    :::makefile\n    LOCAL_PATH := $(call my-dir)\n\n    include $(CLEAR_VARS)\n\n
    \   LOCAL_MODULE    := argument_test\n    LOCAL_SRC_FILES := argument_test.cc\n\n
    \   include $(BUILD_SHARED_LIBRARY)\n\n我们使用ndk-build来编译android的jni动态库.  编译的输入如下:
    \ \n\n    :::sh\n    >ndk-build\n    Gdbserver      : [arm-linux-androideabi-4.6]
    libs/armeabi/gdbserver\n    Gdbsetup       : libs/armeabi/gdb.setup\n    Compile++
    thumb  : argument_test <= argument_test.cc\n    StaticLibrary  : libstdc++.a\n
    \   SharedLibrary  : libargument_test.so\n    Install        : libargument_test.so
    => libs/armeabi/libargument_test.so\n\n看到最后的那句Install, 表示编译成功了.  \n此时, 在eclipse中运行,
    就可以看到LogCat输出的结果:  \n\n    V/ArugmenetTest(27895): begin.\n    V/ArugmenetTest(27895):
    intMethod: 25\n    V/ArugmenetTest(27895): booleanMethod: false\n    V/ArugmenetTest(27895):
    stringMethod: language: JAVA\n    V/ArugmenetTest(27895): intArrayMethod: 15\n\n#
    从C/C++中调用JAVA\n因为在Android中我暂时还没有发现这种需求, 暂时就不太研究了, 稍微看了一下[用 JNI 进行 Java 编程, 从 C/C++
    程序调用 Java 代码](http://www.ibm.com/developerworks/cn/education/java/j-jni/section3.html),
    似乎和以前看到的在C/C++中使用v8 js引擎最像, 相当于直接用C/C++代码操作java的虚拟机, 来执行代码.  有兴趣的就直接去看原文吧.  \n\n#
    高级主题\n本文只是介绍了最基础的情况, 实际上情况没有那么简单, 两个语言之间(这里是java和C/C++)的互相调用是很麻烦的, 这里可以从[参考1中的高级主题](http://www.ibm.com/developerworks/cn/education/java/j-jni/section4.html)中,
    看到一些例子.  \n\n# 参考\n\n1. [用 JNI 进行 Java 编程](http://www.ibm.com/developerworks/cn/education/java/j-jni/index.html)
    \ \n2. [使用JNI进行混合编程：在C/C++中调用Java代码](http://developer.51cto.com/art/201204/332810.htm)
    \ \n3. [Java Development Guide for Mac](https://developer.apple.com/library/mac/#documentation/Java/Conceptual/Java14Development/05-CoreJavaAPIs/CoreJavaAPIs.html)\n\n<div
    style=\"text-align:right\">\n  writen&nbsp;by <a href=\"http://www.jtianling.com\"
    target=\"_blank\">九天雁翎(JTianLing) -- www.jtianling.com</a>\n</div>"
  views: '328'
  _aioseop_title: Mac及Android环境下的JNI学习
author:
  login: jtianling
  email: jtianling@gmail.com
  display_name: jtianling
  first_name: ''
  last_name: ''
---
<div class="toc">
<ul>
<li><a href="#_1">简介</a></li>
<li><a href="#javacc">从Java中调用C/C++库</a>
<ul>
<li><a href="#hello-world">Hello World</a></li>
<li><a href="#_2">带参数的函数</a></li>
<li><a href="#android">Android中的情况</a></li>
</ul>
</li>
<li><a href="#ccjava">从C/C++中调用JAVA</a></li>
<li><a href="#_3">高级主题</a></li>
<li><a href="#_4">参考</a></li>
</ul>
</div>
<h1 id="_1">简介</h1>
<p>JNI就是Java Native Interface, 也可以理解为一般脚本语言的C API, 一般情况下这种API的学习都是一种痛苦的精力, 从来如此, 没有太多技术含量, 就是一堆晦涩难以理解的编程模型, 编程接口, 充斥着各种从当前语言到C语言的类型转换.  基本的含义就是用C语言的思维去表示当前的语言, 这个问题在Lua语言中到达了极致.  不管是多么为了效率, 一个纯堆栈操作的编程接口都像汇编语言一样难以使用.<br />
因为最近又开始做Android游戏了, 用的是cocos2d-x, JNI是难以避免了, 以前的使用都是照猫画虎似的写几个函数调用接口, 总感觉有问题, 今天好好的学习学习吧.<br />
与一般关于JNI文章稍微有些不一样的是, 本文会更多的关注于Android相关的问题.  </p>
<p>本文使用的环境是: <br />
Mac OS X 10.8.3<br />
java version "1.6.0_43"<br />
Java(TM) SE Runtime Environment (build 1.6.0_43-b01-447-11M4203)<br />
Java HotSpot(TM) 64-Bit Server VM (build 20.14-b01-447, mixed mode)<br />
gcc version 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)<br />
Android SDK API 17<br />
Android ndk r8d</p>
<h1 id="javacc">从Java中调用C/C++库</h1>
<p>从Java中调用C/C++库的典型使用场景就是在Android中Load自己写的游戏库, 然后运行.  虽然有cocos2d-x引擎的时候你几乎不用关心这个.  </p>
<h2 id="hello-world">Hello World</h2>
<p>从R&amp;D开始, Hello World就成了一开始必用的例子了, 学习JNI也从这个开始吧.<br />
首先构建一个最简单的Java class:  </p>
<div class="codehilite">
<pre><span class="c1">// HelloWorld.java</span>
<span class="kn">import</span> <span class="nn">java.lang.System.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">SayHelloWorld</span><span class="o">();</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">loadLibrary</span><span class="o">(</span><span class="s">&quot;helloworld&quot;</span><span class="o">);</span>

    <span class="n">HelloWorld</span> <span class="n">helloworld</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HelloWorld</span><span class="o">();</span>
    <span class="n">helloworld</span><span class="o">.</span><span class="na">SayHelloWorld</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre>
</div>
<p>native关键字表示的接口就是需要用C/C++来实现的接口, System.loadLibrary调用的就是将会实现的jni库.<br />
然后用javac将文件编译成字节码:  </p>
<div class="codehilite">
<pre>javac HelloWorld.java
</pre>
</div>
<p>生成HelloWorld.class, java中最人性的一点就是把binding的生成直接作为标准了, 这一点比Python和lua要强多了, 也使得JNI的使用是我接触过的语言中, 类似C API最方便的一个.  直接生成C/C++ binding头文件的方式是用javah命令:  </p>
<div class="codehilite">
<pre>javah HelloWorld
</pre>
</div>
<p>从上面的HelloWorld类生成的头文件如下:  </p>
<div class="codehilite">
<pre><span class="cm">/* DO NOT EDIT THIS FILE - it is machine generated */</span>
<span class="cp">#include &lt;jni.h&gt;</span>
<span class="cm">/* Header for class HelloWorld */</span>

<span class="cp">#ifndef _Included_HelloWorld</span>
<span class="cp">#define _Included_HelloWorld</span>
<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
<span class="cp">#endif</span>
  <span class="cm">/*</span>
<span class="cm">   * Class:     HelloWorld</span>
<span class="cm">   * Method:    SayHelloWorld</span>
<span class="cm">   * Signature: ()V</span>
<span class="cm">   */</span>
  <span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span> <span class="n">Java_HelloWorld_SayHelloWorld</span>
    <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">);</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
</pre>
</div>
<p>这实在是相当人性化了, 我们只需要包含HelloWorld.h头文件, 然后实现按照头文件给的签名实现Java_HelloWorld_SayHelloWorld函数就行了, 而不用自己去记住这么复杂的函数名和参数.  实现的HelloWorld.cc文件如下:  </p>
<div class="codehilite">
<pre><span class="c1">// HelloWorld.cc</span>
<span class="cp">#include &quot;HelloWorld.h&quot;</span>
<span class="cp">#include &lt;cstdio&gt;</span>

<span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span> <span class="nf">Java_HelloWorld_SayHelloWorld</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;HelloWorld.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre>
</div>
<p>编译C++代码的时候在MacOS下和在Linux, Windows有所不同, 不是编译成.so或者dll, 而是MacOS自己的jnilib.  并且jni.h的目录也比较特殊, 是<code>/System/Library/Frameworks/JavaVM.framework/Headers/</code>, 这个需要稍微注意一下,  具体的命令如下: </p>
<div class="codehilite">
<pre>g++ -dynamiclib -o libhelloworld.jnilib HelloWorld.cc -framework JavaVM -I/System/Library/Frameworks/JavaVM.framework/Headers
</pre>
</div>
<p>此时一切就绪:  </p>
<div class="codehilite">
<pre>&gt;java HelloWorld
HelloWorld.
</pre>
</div>
<h2 id="_2">带参数的函数</h2>
<p>两个语言之间的来回调用, 在没有任何参数的情况下还好, 有了参数以后, 因为牵涉到两个语言对类型的不同表示方式, 需要进行类型转换, 是最麻烦的地方, 比如在Lua, Python中, 使用C API时, 你就需要记住Lua和Python的各种类型分别对应C语言中的哪个类型, JAVA中在调用C/C++函数时, 在Java中通过javah部分缓解了这个问题, 可以让我们直接知道对应的类型是哪一个, 不过具体每个用C语言表示的JAVA类型该怎么用, 还是查文档吧, 比如下面这个例子:  </p>
<div class="codehilite">
<pre><span class="c1">// ArugmentTest.java</span>
<span class="kn">import</span> <span class="nn">java.lang.System.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArgumentTest</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">native</span> <span class="kt">int</span> <span class="nf">intMethod</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">);</span>
  <span class="kd">public</span> <span class="kd">native</span> <span class="kt">boolean</span> <span class="nf">booleanMethod</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">bool</span><span class="o">);</span>
  <span class="kd">public</span> <span class="kd">native</span> <span class="n">String</span> <span class="nf">stringMethod</span><span class="o">(</span><span class="n">String</span> <span class="n">text</span><span class="o">);</span>
  <span class="kd">public</span> <span class="kd">native</span> <span class="kt">int</span> <span class="nf">intArrayMethod</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">intArray</span><span class="o">);</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">System</span><span class="o">.</span><span class="na">loadLibrary</span><span class="o">(</span><span class="s">&quot;argumenttest&quot;</span><span class="o">);</span>

    <span class="n">ArgumentTest</span> <span class="n">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArgumentTest</span><span class="o">();</span>

    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;intMethod: &quot;</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="na">intMethod</span><span class="o">(</span><span class="mi">5</span><span class="o">));</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;booleanMethod: &quot;</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="na">booleanMethod</span><span class="o">(</span><span class="kc">true</span><span class="o">));</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;stringMethod: &quot;</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="na">stringMethod</span><span class="o">(</span><span class="s">&quot;JAVA&quot;</span><span class="o">));</span>
    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;intArrayMethod: &quot;</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="na">intArrayMethod</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">}));</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre>
</div>
<p>编译后, 用javah生成的头文件如下:  </p>
<div class="codehilite">
<pre><span class="cm">/* DO NOT EDIT THIS FILE - it is machine generated */</span>
<span class="cp">#include &lt;jni.h&gt;</span>
<span class="cm">/* Header for class ArgumentTest */</span>

<span class="cp">#ifndef _Included_ArgumentTest</span>
<span class="cp">#define _Included_ArgumentTest</span>
<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
<span class="cp">#endif</span>
<span class="cm">/*</span>
<span class="cm"> * Class:     ArgumentTest</span>
<span class="cm"> * Method:    intMethod</span>
<span class="cm"> * Signature: (I)I</span>
<span class="cm"> */</span>
<span class="n">JNIEXPORT</span> <span class="n">jint</span> <span class="n">JNICALL</span> <span class="n">Java_ArgumentTest_intMethod</span>
  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">,</span> <span class="n">jint</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Class:     ArgumentTest</span>
<span class="cm"> * Method:    booleanMethod</span>
<span class="cm"> * Signature: (Z)Z</span>
<span class="cm"> */</span>
<span class="n">JNIEXPORT</span> <span class="n">jboolean</span> <span class="n">JNICALL</span> <span class="nf">Java_ArgumentTest_booleanMethod</span>
  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">,</span> <span class="n">jboolean</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Class:     ArgumentTest</span>
<span class="cm"> * Method:    stringMethod</span>
<span class="cm"> * Signature: (Ljava/lang/String;)Ljava/lang/String;</span>
<span class="cm"> */</span>
<span class="n">JNIEXPORT</span> <span class="n">jstring</span> <span class="n">JNICALL</span> <span class="nf">Java_ArgumentTest_stringMethod</span>
  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">,</span> <span class="n">jstring</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Class:     ArgumentTest</span>
<span class="cm"> * Method:    intArrayMethod</span>
<span class="cm"> * Signature: ([I)I</span>
<span class="cm"> */</span>
<span class="n">JNIEXPORT</span> <span class="n">jint</span> <span class="n">JNICALL</span> <span class="nf">Java_ArgumentTest_intArrayMethod</span>
  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">,</span> <span class="n">jintArray</span><span class="p">);</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
</pre>
</div>
<p>这里我们可以看到, 大概的类型对应关系:<br />
Object=&gt;jobject<br />
int=&gt;jint<br />
boolean=&gt;jboolean<br />
String=&gt;jstring<br />
int[]=&gt;jintArray  </p>
<p>但是, jobject, jstring, jintArray具体怎么使用, 总归得再学习一遍.  但是javah的存在还是非常有意义的, 起码我们不用记哪个类型该查什么文档了.<br />
实现的C++文件如下:  </p>
<div class="codehilite">
<pre><span class="c1">// ArgumentTest.cc</span>

<span class="cp">#include &quot;ArgumentTest.h&quot;</span>
<span class="cp">#include &lt;cstring&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="n">JNIEXPORT</span> <span class="n">jint</span> <span class="n">JNICALL</span> <span class="nf">Java_ArgumentTest_intMethod</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span> <span class="n">jint</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">num</span> <span class="o">*</span> <span class="n">num</span><span class="p">;</span> 
<span class="p">}</span>

<span class="n">JNIEXPORT</span> <span class="n">jboolean</span> <span class="n">JNICALL</span> <span class="nf">Java_ArgumentTest_booleanMethod</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span> <span class="n">jboolean</span> <span class="n">boolean</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">!</span><span class="n">boolean</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">JNIEXPORT</span> <span class="n">jstring</span> <span class="n">JNICALL</span> <span class="nf">Java_ArgumentTest_stringMethod</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cstr</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetStringUTFChars</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="kt">char</span> <span class="n">cap</span><span class="p">[</span><span class="mi">128</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;language: &quot;</span><span class="p">;</span>
  <span class="n">strcat</span><span class="p">(</span><span class="n">cap</span><span class="p">,</span> <span class="n">cstr</span><span class="p">);</span>
  <span class="n">env</span><span class="o">-&gt;</span><span class="n">ReleaseStringUTFChars</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">cstr</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">NewStringUTF</span><span class="p">(</span><span class="n">cap</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">JNIEXPORT</span> <span class="n">jint</span> <span class="n">JNICALL</span> <span class="nf">Java_ArgumentTest_intArrayMethod</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">obj</span><span class="p">,</span> <span class="n">jintArray</span> <span class="n">array</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">jsize</span> <span class="n">len</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetArrayLength</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
  <span class="n">jint</span> <span class="o">*</span><span class="n">body</span> <span class="o">=</span> <span class="n">env</span> <span class="o">-&gt;</span><span class="n">GetIntArrayElements</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">body</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="n">env</span><span class="o">-&gt;</span><span class="n">ReleaseIntArrayElements</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>
</pre>
</div>
<p>这里可以看到几个特殊的函数, GetStringUTFChars, GetArrayLength, GetIntArrayElements, ReleaseIntArrayElements等, 还好都不算太复杂.  一旦用了JNI, 需要注意的就是, 你资源的分配释放, 就得和C/C++中一样了, 得自己手动来.<br />
另外, 还值得一提的是, 因为C++对类的直接支持, 所以C++中可以用比C语言更简洁的语法, 大概的区别看了下面的示例:<br />
C代码: <code>(*env)-&gt;GetStringUTFChars(env, string, 0);</code><br />
C++代码: <code>env-&gt;GetStringUTFChars(string, 0);</code></p>
<h2 id="android">Android中的情况</h2>
<p>其实实现和使用方式都类似, 只是编译时, 需要使用不同的命令, 其实因为Android其实就是一种特殊的Linux, 所以对于Android来说, 生成方式和Linux类似, 并且都是生成Unix/Linux通用的<code>.so</code>动态库文件.<br />
另外, 还有一些典型的Android的问题, 比如在Android中去完成前面的ArugmentTest:  </p>
<div class="codehilite">
<pre><span class="kn">import</span> <span class="nn">android.util.Log</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.app.Activity</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.view.View</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.os.Bundle</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ArgumentTest</span> <span class="kd">extends</span> <span class="n">Activity</span>
<span class="o">{</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">LOG_TAG</span> <span class="o">=</span> <span class="s">&quot;ArugmenetTest&quot;</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kd">native</span> <span class="kt">int</span> <span class="nf">intMethod</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">);</span>

  <span class="kd">public</span> <span class="kd">native</span> <span class="kt">boolean</span> <span class="nf">booleanMethod</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">bool</span><span class="o">);</span>

  <span class="kd">public</span> <span class="kd">native</span> <span class="n">String</span> <span class="nf">stringMethod</span><span class="o">(</span><span class="n">String</span> <span class="n">text</span><span class="o">);</span>

  <span class="kd">public</span> <span class="kd">native</span> <span class="kt">int</span> <span class="nf">intArrayMethod</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">intArray</span><span class="o">);</span>

    <span class="cm">/** Called when the activity is first created. */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>

        <span class="cm">/* Create a TextView and set its content.</span>
<span class="cm">         * the text is retrieved by calling a native</span>
<span class="cm">         * function.</span>
<span class="cm">         */</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">LOG_TAG</span><span class="o">,</span> <span class="s">&quot;begin.\n&quot;</span><span class="o">);</span>
        <span class="n">View</span> <span class="n">v</span> <span class="o">=</span> <span class="k">new</span> <span class="n">View</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="n">setContentView</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>

        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">LOG_TAG</span><span class="o">,</span> <span class="s">&quot;intMethod: &quot;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">intMethod</span><span class="o">(</span><span class="mi">5</span><span class="o">));</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">LOG_TAG</span><span class="o">,</span> <span class="s">&quot;booleanMethod: &quot;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">booleanMethod</span><span class="o">(</span><span class="kc">true</span><span class="o">));</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">LOG_TAG</span><span class="o">,</span> <span class="s">&quot;stringMethod: &quot;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">stringMethod</span><span class="o">(</span><span class="s">&quot;JAVA&quot;</span><span class="o">));</span>
        <span class="n">Log</span><span class="o">.</span><span class="na">v</span><span class="o">(</span><span class="n">LOG_TAG</span><span class="o">,</span> <span class="s">&quot;intArrayMethod: &quot;</span> <span class="o">+</span> <span class="k">this</span><span class="o">.</span><span class="na">intArrayMethod</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">}));</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="o">{</span>
      <span class="n">System</span><span class="o">.</span><span class="na">loadLibrary</span><span class="o">(</span><span class="s">&quot;argument_test&quot;</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre>
</div>
<p>需要注意的是, Android中就不要使用System.out这种标准JAVA的库输出了, 用的是android.util.Log这个再LogCat输出的类.  然后, 作为Android的工程, 一个Activity是必须的, 这里就把ArgumentTest做成了Activity了.<br />
编译的时候需要注意, 一方面在Android中, 我们肯定需要指定一个自己的package, 不能像前面那边随意了, 这里的pakcage我用的是com.jtianling.ArgumentTest, 另外, 还需要指定一下android的classpath:  </p>
<div class="codehilite">
<pre>&gt;javac -d ../jni/ com/jtianling/ArgumentTest/ArgumentTest.java -classpath ~/android/sdk/platforms/android-17/android.jar
</pre>
</div>
<p>同样的, pacakge在用javah的时候也必不可少, 不然就算生成了.so, 其实package对不上也是找不到的.  首先进入jni目录, 然后用下面的命令, 指定好package.  </p>
<div class="codehilite">
<pre>&gt;javah com.jtianling.ArgumentTest.ArgumentTest
</pre>
</div>
<p>此时生成的头文件是带package信息的, 大概是下面这样子:<br />
<code>com_jtianling_ArgumentTest_ArgumentTest.h</code>  </p>
<p>文件的函数名也是类似, 也附带了package的信息:  </p>
<div class="codehilite">
<pre><span class="cm">/* DO NOT EDIT THIS FILE - it is machine generated */</span>
<span class="cp">#include &lt;jni.h&gt;</span>
<span class="cm">/* Header for class com_jtianling_ArgumentTest_ArgumentTest */</span>

<span class="cp">#ifndef _Included_com_jtianling_ArgumentTest_ArgumentTest</span>
<span class="cp">#define _Included_com_jtianling_ArgumentTest_ArgumentTest</span>
<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
<span class="cp">#endif</span>
<span class="cm">/*</span>
<span class="cm"> * Class:     com_jtianling_ArgumentTest_ArgumentTest</span>
<span class="cm"> * Method:    intMethod</span>
<span class="cm"> * Signature: (I)I</span>
<span class="cm"> */</span>
<span class="n">JNIEXPORT</span> <span class="n">jint</span> <span class="n">JNICALL</span> <span class="n">Java_com_jtianling_ArgumentTest_ArgumentTest_intMethod</span>
  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">,</span> <span class="n">jint</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Class:     com_jtianling_ArgumentTest_ArgumentTest</span>
<span class="cm"> * Method:    booleanMethod</span>
<span class="cm"> * Signature: (Z)Z</span>
<span class="cm"> */</span>
<span class="n">JNIEXPORT</span> <span class="n">jboolean</span> <span class="n">JNICALL</span> <span class="nf">Java_com_jtianling_ArgumentTest_ArgumentTest_booleanMethod</span>
  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">,</span> <span class="n">jboolean</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Class:     com_jtianling_ArgumentTest_ArgumentTest</span>
<span class="cm"> * Method:    stringMethod</span>
<span class="cm"> * Signature: (Ljava/lang/String;)Ljava/lang/String;</span>
<span class="cm"> */</span>
<span class="n">JNIEXPORT</span> <span class="n">jstring</span> <span class="n">JNICALL</span> <span class="nf">Java_com_jtianling_ArgumentTest_ArgumentTest_stringMethod</span>
  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">,</span> <span class="n">jstring</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Class:     com_jtianling_ArgumentTest_ArgumentTest</span>
<span class="cm"> * Method:    intArrayMethod</span>
<span class="cm"> * Signature: ([I)I</span>
<span class="cm"> */</span>
<span class="n">JNIEXPORT</span> <span class="n">jint</span> <span class="n">JNICALL</span> <span class="nf">Java_com_jtianling_ArgumentTest_ArgumentTest_intArrayMethod</span>
  <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">,</span> <span class="n">jintArray</span><span class="p">);</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
</pre>
</div>
<p>同样的, 按照签名和函数名实现即可, 在一个典型的Android工程中, jni相关的C/C++代码都是放在工程的jni目录下, 我们还需在此目录配置Android.mk文件, 大概如下:  </p>
<div class="codehilite">
<pre><span class="nv">LOCAL_PATH</span> <span class="o">:=</span> <span class="k">$(</span>call my-dir<span class="k">)</span>

<span class="cp">include $(CLEAR_VARS)</span>

<span class="nv">LOCAL_MODULE</span>    <span class="o">:=</span> argument_test
<span class="nv">LOCAL_SRC_FILES</span> <span class="o">:=</span> argument_test.cc

<span class="cp">include $(BUILD_SHARED_LIBRARY)</span>
</pre>
</div>
<p>我们使用ndk-build来编译android的jni动态库.  编译的输入如下:  </p>
<div class="codehilite">
<pre>&gt;ndk-build
Gdbserver      : <span class="o">[</span>arm-linux-androideabi-4.6<span class="o">]</span> libs/armeabi/gdbserver
Gdbsetup       : libs/armeabi/gdb.setup
Compile++ thumb  : argument_test &lt;<span class="o">=</span> argument_test.cc
StaticLibrary  : libstdc++.a
SharedLibrary  : libargument_test.so
Install        : libargument_test.so <span class="o">=</span>&gt; libs/armeabi/libargument_test.so
</pre>
</div>
<p>看到最后的那句Install, 表示编译成功了.<br />
此时, 在eclipse中运行, 就可以看到LogCat输出的结果:  </p>
<div class="codehilite">
<pre><span class="n">V</span><span class="o">/</span><span class="n">ArugmenetTest</span><span class="p">(</span><span class="mi">27895</span><span class="p">)</span><span class="o">:</span> <span class="n">begin</span><span class="p">.</span>
<span class="n">V</span><span class="o">/</span><span class="n">ArugmenetTest</span><span class="p">(</span><span class="mi">27895</span><span class="p">)</span><span class="o">:</span> <span class="n">intMethod</span><span class="o">:</span> <span class="mi">25</span>
<span class="n">V</span><span class="o">/</span><span class="n">ArugmenetTest</span><span class="p">(</span><span class="mi">27895</span><span class="p">)</span><span class="o">:</span> <span class="n">booleanMethod</span><span class="o">:</span> <span class="nb">false</span>
<span class="n">V</span><span class="o">/</span><span class="n">ArugmenetTest</span><span class="p">(</span><span class="mi">27895</span><span class="p">)</span><span class="o">:</span> <span class="n">stringMethod</span><span class="o">:</span> <span class="n">language</span><span class="o">:</span> <span class="n">JAVA</span>
<span class="n">V</span><span class="o">/</span><span class="n">ArugmenetTest</span><span class="p">(</span><span class="mi">27895</span><span class="p">)</span><span class="o">:</span> <span class="n">intArrayMethod</span><span class="o">:</span> <span class="mi">15</span>
</pre>
</div>
<h1 id="ccjava">从C/C++中调用JAVA</h1>
<p>因为在Android中我暂时还没有发现这种需求, 暂时就不太研究了, 稍微看了一下<a href="http://www.ibm.com/developerworks/cn/education/java/j-jni/section3.html">用 JNI 进行 Java 编程, 从 C/C++ 程序调用 Java 代码</a>, 似乎和以前看到的在C/C++中使用v8 js引擎最像, 相当于直接用C/C++代码操作java的虚拟机, 来执行代码.  有兴趣的就直接去看原文吧.  </p>
<h1 id="_3">高级主题</h1>
<p>本文只是介绍了最基础的情况, 实际上情况没有那么简单, 两个语言之间(这里是java和C/C++)的互相调用是很麻烦的, 这里可以从<a href="http://www.ibm.com/developerworks/cn/education/java/j-jni/section4.html">参考1中的高级主题</a>中, 看到一些例子.  </p>
<h1 id="_4">参考</h1>
<ol>
<li><a href="http://www.ibm.com/developerworks/cn/education/java/j-jni/index.html">用 JNI 进行 Java 编程</a>  </li>
<li><a href="http://developer.51cto.com/art/201204/332810.htm">使用JNI进行混合编程：在C/C++中调用Java代码</a>  </li>
<li><a href="https://developer.apple.com/library/mac/#documentation/Java/Conceptual/Java14Development/05-CoreJavaAPIs/CoreJavaAPIs.html">Java Development Guide for Mac</a></li>
</ol>
<div style="text-align:right">
  writen&nbsp;by <a href="http://www.jtianling.com" target="_blank">九天雁翎(JTianLing) -- www.jtianling.com</a>
</div>
