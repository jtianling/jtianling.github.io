---
layout: post
title: SDL源码阅读笔记（2） video dirver的初始化及选择
categories:
- "图形技术"
tags:
- SDL
status: publish
type: post
published: true
meta:
  ratings_users: '0'
  ratings_score: '0'
  ratings_average: '0'
  views: '86'
author:
  login: jtianling
  email: jtianling@gmail.com
  display_name: jtianling
  first_name: ''
  last_name: ''
---

<p style="margin: 1em 0px 0.5em;" align="right"><strong><a style="color: #006bad; text-decoration: none;" href="http://www.jtianling.com">write by 九天雁翎(JTianLing) -- www.jtianling.com</a><br />
</strong></p>
<p style="margin: 1em 0px 0.5em;" align="right"><a style="color: #770000; text-decoration: none;" href="http://groups.google.com/group/jiutianfile/"><strong>讨论新闻组及文件</strong><br />
</a></p>
<p>
<a id="jtqm" title="前一篇文章" href="http://www.jtianling.com/archive/2010/07/24/5761714.aspx" title="前一篇文章">前一篇文章</a><br />
讲了SDL的除video以外的大部分模块。本文主要关注SDL的video模块部分。</p>
<p>SDL中的video模块包含了大部分与平台相关的代码，并且SDL处理的很有技巧性，这里利用C语言的函数指针来模拟了一种类似于面向对象的效果。</p>
<p>主要的关键点在</p>
<p>SDL_VideoDevice *current_video = NULL;</p>
<p>这一句定义的全局变量current_video上，我们先来看看这个变量类型SDL_VideoDevice。</p>
<p>主要在SDL_sysvideo.h这个文件中<br />
<span style="font-family: monospace;"><br />
<span style="color: #008000;">struct</span><br />
&nbsp;SDL_VideoDevice {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;* * </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;The name of this video driver </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">const</span><br />
&nbsp;<span style="color: #008000;">char</span><br />
&nbsp;*name;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;* * </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Initialization/Query functions </span><br />
<span style="color: #804000;">*/</span></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Initialize the native video subsystem, filling 'vformat' with the </span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;best&quot; display pixel format, returning 0 or -1 if there's an error.</span><br /></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*VideoInit)(_THIS, SDL_PixelFormat *vformat);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;List the available video modes for the given pixel format, sorted</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from largest to smallest.</span><br /></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;SDL_Rect **(*ListModes)(_THIS, SDL_PixelFormat *format, Uint32 flags);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Set the requested video mode, returning a surface which will be</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set to the SDL_VideoSurface.&nbsp; The width and height will already</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; be verified by ListModes(), and the video subsystem is free to</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set the mode to a supported bit depth different from the one</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; specified -- the desired bpp will be emulated with a shadow</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; surface if necessary.&nbsp; If a new mode is returned, this function</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; should take care of cleaning up the current mode.</span><br /></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;SDL_Surface *(*SetVideoMode)(_THIS, SDL_Surface *current,</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;width, <span style="color: #008000;">int</span><br />
&nbsp;height, <span style="color: #008000;">int</span><br />
&nbsp;bpp, Uint32 flags);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Toggle the fullscreen mode </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*ToggleFullScreen)(_THIS, <span style="color: #008000;">int</span><br />
&nbsp;on);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;This is called after the video mode has been set, to get the</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; initial mouse state.&nbsp; It should queue events as necessary to</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; properly represent the current mouse focus and position.</span><br /></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;(*UpdateMouse)(_THIS);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Create a YUV video surface (possibly overlay) of the given</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; format.&nbsp; The hardware should be able to perform at least 2x</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scaling on display.</span><br /></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;SDL_Overlay *(*CreateYUVOverlay)(_THIS, <span style="color: #008000;">int</span><br />
&nbsp;width, <span style="color: #008000;">int</span><br />
&nbsp;height,</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Uint32 format, SDL_Surface *display);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Sets the color entries { firstcolor .. (firstcolor+ncolors-1) }</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; of the physical palette to those in 'colors'. If the device is</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; using a software palette (SDL_HWPALETTE not set), then the</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; changes are reflected in the logical palette of the screen</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; as well.</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The return value is 1 if all entries could be set properly</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or 0 otherwise.</span><br /></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*SetColors)(_THIS, <span style="color: #008000;">int</span><br />
&nbsp;firstcolor, <span style="color: #008000;">int</span><br />
&nbsp;ncolors,</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SDL_Color *colors);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;This pointer should exist in the native video subsystem and should</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; point to an appropriate update function for the current video mode</span><br /></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;(*UpdateRects)(_THIS, <span style="color: #008000;">int</span><br />
&nbsp;numrects, SDL_Rect *rects);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Reverse the effects VideoInit() -- called if VideoInit() fails</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or if the application is shutting down the video subsystem.</span><br /></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;(*VideoQuit)(_THIS);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;* * </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Hardware acceleration functions </span><br />
<span style="color: #804000;">*/</span></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Information about the video hardware </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;SDL_VideoInfo info;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;The pixel format used when SDL_CreateRGBSurface creates SDL_HWSURFACEs with alpha </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;SDL_PixelFormat* displayformatalphapixel;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Allocates a surface in video memory </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*AllocHWSurface)(_THIS, SDL_Surface *surface);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Sets the hardware accelerated blit function, if any, based</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; on the current flags of the surface (colorkey, alpha, etc.)</span><br /></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*CheckHWBlit)(_THIS, SDL_Surface *src, SDL_Surface *dst);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Fills a surface rectangle with the given color </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*FillHWRect)(_THIS, SDL_Surface *dst, SDL_Rect *rect, Uint32 color);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Sets video mem colorkey and accelerated blit function </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*SetHWColorKey)(_THIS, SDL_Surface *surface, Uint32 key);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Sets per surface hardware alpha value </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*SetHWAlpha)(_THIS, SDL_Surface *surface, Uint8 value);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Returns a readable/writable surface </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*LockHWSurface)(_THIS, SDL_Surface *surface);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;(*UnlockHWSurface)(_THIS, SDL_Surface *surface);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Performs hardware flipping </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*FlipHWSurface)(_THIS, SDL_Surface *surface);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Frees a previously allocated video surface </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;(*FreeHWSurface)(_THIS, SDL_Surface *surface);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;* * </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Gamma support </span><br />
<span style="color: #804000;">*/</span></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;Uint16 *gamma;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Set the gamma correction directly (emulated with gamma ramps) </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*SetGamma)(_THIS, <span style="color: #008000;">float</span><br />
&nbsp;red, <span style="color: #008000;">float</span><br />
&nbsp;green, <span style="color: #008000;">float</span><br />
&nbsp;blue);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Get the gamma correction directly (emulated with gamma ramps) </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*GetGamma)(_THIS, <span style="color: #008000;">float</span><br />
&nbsp;*red, <span style="color: #008000;">float</span><br />
&nbsp;*green, <span style="color: #008000;">float</span><br />
&nbsp;*blue);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Set the gamma ramp </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*SetGammaRamp)(_THIS, Uint16 *ramp);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Get the gamma ramp </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*GetGammaRamp)(_THIS, Uint16 *ramp);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;* * </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;OpenGL support </span><br />
<span style="color: #804000;">*/</span></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Sets the dll to use for OpenGL and loads it </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*GL_LoadLibrary)(_THIS, <span style="color: #008000;">const</span><br />
&nbsp;<span style="color: #008000;">char</span><br />
&nbsp;*path);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Retrieves the address of a function in the gl library </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
* (*GL_GetProcAddress)(_THIS, <span style="color: #008000;">const</span><br />
&nbsp;<span style="color: #008000;">char</span><br />
&nbsp;*proc);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Get attribute information from the windowing system. </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*GL_GetAttribute)(_THIS, SDL_GLattr attrib, <span style="color: #008000;">int</span><br />
* value);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Make the context associated with this driver current </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*GL_MakeCurrent)(_THIS);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Swap the current buffers in double buffer mode. </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;(*GL_SwapBuffers)(_THIS);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;OpenGL functions for SDL_OPENGLBLIT </span><br />
<span style="color: #804000;">*/</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_OPENGL</span><br />
<br />
<span style="color: #c000c0;">#if !defined(__WIN32__)</span><br />
<br />
<span style="color: #c000c0;">#define WINAPI</span><br />
<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#define SDL_PROC(ret,func,params) ret (WINAPI *func) params;</span><br />
<br />
<span style="color: #c000c0;">#include </span><br />
<span style="color: #008080;">&quot;SDL_glfuncs.h&quot;</span><br />
<br />
<span style="color: #c000c0;">#undef SDL_PROC</span></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Texture id </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;GLuint texture;<br />
<span style="color: #c000c0;">#endif</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;is_32bit;</p>
<p> &nbsp;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;* * </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Window manager functions </span><br />
<span style="color: #804000;">*/</span></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Set the title and icon text </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;(*SetCaption)(_THIS, <span style="color: #008000;">const</span><br />
&nbsp;<span style="color: #008000;">char</span><br />
&nbsp;*title, <span style="color: #008000;">const</span><br />
&nbsp;<span style="color: #008000;">char</span><br />
&nbsp;*icon);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Set the window icon image </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;(*SetIcon)(_THIS, SDL_Surface *icon, Uint8 *mask);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Iconify the window.</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This function returns 1 if there is a window manager and the</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; window was actually iconified, it returns 0 otherwise.</span><br /></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*IconifyWindow)(_THIS);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Grab or ungrab keyboard and mouse input </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;SDL_GrabMode (*GrabInput)(_THIS, SDL_GrabMode mode);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Get some platform dependent window information </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*GetWMInfo)(_THIS, SDL_SysWMinfo *info);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;* * </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Cursor manager functions </span><br />
<span style="color: #804000;">*/</span></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Free a window manager cursor</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This function can be NULL if CreateWMCursor is also NULL.</span><br /></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;(*FreeWMCursor)(_THIS, WMcursor *cursor);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;If not NULL, create a black/white window manager cursor </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;WMcursor *(*CreateWMCursor)(_THIS,</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Uint8 *data, Uint8 *mask, <span style="color: #008000;">int</span><br />
&nbsp;w, <span style="color: #008000;">int</span><br />
&nbsp;h, <span style="color: #008000;">int</span><br />
&nbsp;hot_x, <span style="color: #008000;">int</span><br />
&nbsp;hot_y);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Show the specified cursor, or hide if cursor is NULL </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*ShowWMCursor)(_THIS, WMcursor *cursor);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Warp the window manager cursor to (x,y)</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If NULL, a mouse motion event is posted internally.</span><br /></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;(*WarpWMCursor)(_THIS, Uint16 x, Uint16 y);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;If not NULL, this is called when a mouse motion event occurs </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;(*MoveWMCursor)(_THIS, <span style="color: #008000;">int</span><br />
&nbsp;x, <span style="color: #008000;">int</span><br />
&nbsp;y);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Determine whether the mouse should be in relative mode or not.</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This function is called when the input grab state or cursor</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; visibility state changes.</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If the cursor is not visible, and the input is grabbed, the</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; driver can place the mouse in relative mode, which may result</span><br />
<br />
<span style="color: #804000;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in higher accuracy sampling of the pointer motion.</span><br /></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;(*CheckMouseMode)(_THIS);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;* * </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Event manager functions </span><br />
<span style="color: #804000;">*/</span></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Initialize keyboard mapping for this driver </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;(*InitOSKeymap)(_THIS);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Handle any queued OS events </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;(*PumpEvents)(_THIS);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;* * </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Data common to all drivers </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;SDL_Surface *screen;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;SDL_Surface *shadow;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;SDL_Surface *visible;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDL_Palette *physpal;&nbsp;&nbsp; <span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;physical palette, if != logical palette </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDL_Color *gammacols;&nbsp;&nbsp; <span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;gamma-corrected colours, or NULL </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">char</span><br />
&nbsp;*wm_title;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">char</span><br />
&nbsp;*wm_icon;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;offset_x;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;offset_y;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;SDL_GrabMode input_grab;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Driver information flags </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;handles_any_size;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Driver handles any size video mode </span><br />
<span style="color: #804000;">*/</span></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;* * </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Data used by the GL drivers </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">struct</span><br />
&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;red_size;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;green_size;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;blue_size;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;alpha_size;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;depth_size;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;buffer_size;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;stencil_size;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;double_buffer;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;accum_red_size;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;accum_green_size;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;accum_blue_size;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;accum_alpha_size;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;stereo;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;multisamplebuffers;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;multisamplesamples;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;accelerated;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;swap_control;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;driver_loaded;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">char</span><br />
&nbsp;driver_path[<span style="color: #008080;">256</span><br />
];</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
* dll_handle;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;} gl_config;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;* * </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Data private to this driver </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">struct</span><br />
&nbsp;SDL_PrivateVideoData *hidden;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">struct</span><br />
&nbsp;SDL_PrivateGLData *gl_data;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;* * </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;The function used to dispose of this structure </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;(*free)(_THIS);</p>
<p> };<br />
</span><br /></p>
<p>这个结构主要包含的是函数指针，每个函数指针表示了一个与平台相关的函数。在运行时，给这些函数指针赋值，指定成对应平台的函数实现，以此实现了使用此结构指针current_video的上层的代码的稳定与一致。</p>
<p>这里首先关心两个流程，其一，初始化给这些函数指针赋值的过程。</p>
<p>这个过程在SDL_VideoInit函数中实现：</p>
<p>SDL初始化基本流程：</p>
<p>SDL_Init(SDL_INIT_VIDEO)-&gt;SDL_InitSubSystem（SDL_INIT_VIDEO)-&gt;SDL_VideoInit()</p>
<p>中途会调用以&quot;SDL_VIDEODRIVER&quot;为参数调用SDL_getenv函数来获取全局配置中指定的对应的video driver。</p>
<p>代码如下：<br />
<span style="font-family: monospace;"></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;( SDL_VideoInit(SDL_getenv(<span style="color: #008080;">&quot;SDL_VIDEODRIVER&quot;</span><br />
),</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (flags&amp;SDL_INIT_EVENTTHREAD)) &lt; <span style="color: #008080;">0</span><br />
&nbsp;) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">return</span><br />
(-<span style="color: #008080;">1</span><br />
);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
</span><br /></p>
<p>我没有设定，所以会以name = NULL为第一参数来调用SDL_VideoInit，也就是让SDL自己选择一个video driver。</p>
<p>SDL会从一个<br />
<span style="font-family: monospace;"><br />
<span style="color: #008000;">typedef</span><br />
&nbsp;<span style="color: #008000;">struct</span><br />
&nbsp;VideoBootStrap {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">const</span><br />
&nbsp;<span style="color: #008000;">char</span><br />
&nbsp;*name;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">const</span><br />
&nbsp;<span style="color: #008000;">char</span><br />
&nbsp;*desc;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;(*available)(<span style="color: #008000;">void</span><br />
);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;SDL_VideoDevice *(*create)(<span style="color: #008000;">int</span><br />
&nbsp;devindex);</p>
<p> } VideoBootStrap;<br />
</span><br /></p>
<p>结构的全局变量bootstrap数组中选取一个可以使用的video driver。</p>
<p>一共有这么多可能的video driver:<br />
<span style="font-family: monospace;"><br />
<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Available video drivers </span><br />
<span style="color: #804000;">*/</span><br />
<br />
<span style="color: #008000;">static</span><br />
&nbsp;VideoBootStrap *bootstrap[] = {<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_QUARTZ</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;QZ_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_X11</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;X11_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_DGA</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;DGA_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_NANOX</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;NX_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_IPOD</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;iPod_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_QTOPIA</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;Qtopia_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_WSCONS</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;WSCONS_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_FBCON</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;FBCON_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_DIRECTFB</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;DirectFB_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_PS2GS</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;PS2GS_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_PS3</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;PS3_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_GGI</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;GGI_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_VGL</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;VGL_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_SVGALIB</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;SVGALIB_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_GAPI</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;GAPI_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_WINDIB</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;WINDIB_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_DDRAW</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;DIRECTX_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_BWINDOW</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;BWINDOW_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_TOOLBOX</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;TOOLBOX_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_DRAWSPROCKET</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;DSp_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_PHOTON</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;ph_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_EPOC</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;EPOC_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_XBIOS</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;XBIOS_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_GEM</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;GEM_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_PICOGUI</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;PG_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_DC</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;DC_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_NDS</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;NDS_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_RISCOS</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;RISCOS_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_OS2FS</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;OS2FSLib_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_AALIB</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;AALIB_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_CACA</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;CACA_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br />
<br />
<span style="color: #c000c0;">#if SDL_VIDEO_DRIVER_DUMMY</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&amp;DUMMY_bootstrap,<br />
<span style="color: #c000c0;">#endif</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008080;">NULL</span><br /></p>
<p> };<br />
</span><br /></p>
<p>都是通过宏来筛选的。</p>
<p>-&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;bootstrap&nbsp;&nbsp; &nbsp;0x100a2b1c bootstrap&nbsp;&nbsp; &nbsp;VideoBootStrap * [4]</p>
<p>+&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[0x0]&nbsp;&nbsp; &nbsp;0x100a1160 _WINDIB_bootstrap {name=0x10099428 &quot;windib&quot; desc=0x1009940c &quot;Win95/98/NT/2000/CE GDI&quot; available=0x1005eaf0 ...}&nbsp;&nbsp; &nbsp;VideoBootStrap *</p>
<p>+&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[0x1]&nbsp;&nbsp; &nbsp;0x100a25e8 _DIRECTX_bootstrap {name=0x10099ab4 &quot;directx&quot; desc=0x10099a98 &quot;Win95/98/2000 DirectX&quot; available=0x100651d0 ...}&nbsp;&nbsp; &nbsp;VideoBootStrap *</p>
<p>+&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[0x2]&nbsp;&nbsp; &nbsp;0x100a2aec _DUMMY_bootstrap {name=0x100995a4 &quot;dummy&quot; desc=0x1009b3e4 &quot;SDL dummy video driver&quot; available=0x10072090 ...}&nbsp;&nbsp; &nbsp;VideoBootStrap *</p>
<p>+&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;[0x3]&nbsp;&nbsp; &nbsp;0x00000000 {name=??? desc=??? available=??? ...}&nbsp;&nbsp; &nbsp;VideoBootStrap *</p>
<p>在我的电脑上(Win32），一共有上面3种可能，windib（即GDI）,directX,dummy。事实上OpenGL在Win32的环境中都没有列出来，当然，但是在以前的例子中，我还是使用了SDL+OpenGL来渲染，原因在于video毕竟不是如同其名字所示，仅仅包含渲染或者视频方面的东西，它其实代表了大部分SDL与平台相关的东西，渲染在SDL中也仅仅是占比较小的一部分。</p>
<p>选取video driver的时候，先调用<span style="font-family: monospace;">VideoBootStrap </span><br />
结构中的<span style="font-family: monospace;">available</span><br />
函数来判断此video driver有效则通过此结构的create函数来创建一个video driver.</p>
<p>如下：<br />
<span style="font-family: monospace;"></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">for</span><br />
&nbsp;( i=<span style="color: #008080;">0</span><br />
; bootstrap[i]; ++i ) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;( bootstrap[i]-&gt;available() ) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video = bootstrap[i]-&gt;create(index);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;( video != <span style="color: #008080;">NULL</span><br />
&nbsp;) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">break</span><br />
;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
</span><br /></p>
<p>创建的时候附带index,并且一旦创建成功，就停止了创建过程，在我的例子中，由于GDI方式排在第一，所以事实上，SDL在Win32环境下默认是选择了使用GDI的video driver。</p>
<p>此GDI video driver的create函数如下：<br />
<span style="font-family: monospace;"><br />
<span style="color: #008000;">static</span><br />
&nbsp;SDL_VideoDevice *DIB_CreateDevice(<span style="color: #008000;">int</span><br />
&nbsp;devindex)</p>
<p> {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;SDL_VideoDevice *device;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Initialize all variables that we clean on shutdown </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device = (SDL_VideoDevice *)SDL_malloc(<span style="color: #804000;">sizeof</span><br />
(SDL_VideoDevice));</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;( device ) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDL_memset(device, <span style="color: #008080;">0</span><br />
, (<span style="color: #804000;">sizeof</span><br />
&nbsp;*device));</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;hidden = (<span style="color: #008000;">struct</span><br />
&nbsp;SDL_PrivateVideoData *)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDL_malloc((<span style="color: #804000;">sizeof</span><br />
&nbsp;*device-&gt;hidden));</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
(device-&gt;hidden){</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDL_memset(device-&gt;hidden, <span style="color: #008080;">0</span><br />
, (<span style="color: #804000;">sizeof</span><br />
&nbsp;*device-&gt;hidden));</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;hidden-&gt;dibInfo = (DibInfo *)SDL_malloc((<span style="color: #804000;">sizeof</span><br />
(DibInfo)));</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
(device-&gt;hidden-&gt;dibInfo == <span style="color: #008080;">NULL</span><br />
)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDL_free(device-&gt;hidden);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;hidden = <span style="color: #008080;">NULL</span><br />
;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;device-&gt;gl_data = (<span style="color: #008000;">struct</span><br />
&nbsp;SDL_PrivateGLData *)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDL_malloc((<span style="color: #804000;">sizeof</span><br />
&nbsp;*device-&gt;gl_data));</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;( (device == <span style="color: #008080;">NULL</span><br />
) || (device-&gt;hidden == <span style="color: #008080;">NULL</span><br />
) ||</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (device-&gt;gl_data == <span style="color: #008080;">NULL</span><br />
) ) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SDL_OutOfMemory();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DIB_DeleteDevice(device);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">return</span><br />
(<span style="color: #008080;">NULL</span><br />
);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;SDL_memset(device-&gt;hidden-&gt;dibInfo, <span style="color: #008080;">0</span><br />
, (<span style="color: #804000;">sizeof</span><br />
&nbsp;*device-&gt;hidden-&gt;dibInfo));</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;SDL_memset(device-&gt;gl_data, <span style="color: #008080;">0</span><br />
, (<span style="color: #804000;">sizeof</span><br />
&nbsp;*device-&gt;gl_data));</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Set the function pointers </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;VideoInit = DIB_VideoInit;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;ListModes = DIB_ListModes;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;SetVideoMode = DIB_SetVideoMode;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;UpdateMouse = WIN_UpdateMouse;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;SetColors = DIB_SetColors;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;UpdateRects = <span style="color: #008080;">NULL</span><br />
;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;VideoQuit = DIB_VideoQuit;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;AllocHWSurface = DIB_AllocHWSurface;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;CheckHWBlit = <span style="color: #008080;">NULL</span><br />
;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;FillHWRect = <span style="color: #008080;">NULL</span><br />
;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;SetHWColorKey = <span style="color: #008080;">NULL</span><br />
;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;SetHWAlpha = <span style="color: #008080;">NULL</span><br />
;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;LockHWSurface = DIB_LockHWSurface;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;UnlockHWSurface = DIB_UnlockHWSurface;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;FlipHWSurface = <span style="color: #008080;">NULL</span><br />
;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;FreeHWSurface = DIB_FreeHWSurface;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;SetGammaRamp = DIB_SetGammaRamp;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GetGammaRamp = DIB_GetGammaRamp;<br />
<span style="color: #c000c0;">#if SDL_VIDEO_OPENGL</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GL_LoadLibrary = WIN_GL_LoadLibrary;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GL_GetProcAddress = WIN_GL_GetProcAddress;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GL_GetAttribute = WIN_GL_GetAttribute;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GL_MakeCurrent = WIN_GL_MakeCurrent;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GL_SwapBuffers = WIN_GL_SwapBuffers;<br />
<span style="color: #c000c0;">#endif</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;SetCaption = WIN_SetWMCaption;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;SetIcon = WIN_SetWMIcon;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;IconifyWindow = WIN_IconifyWindow;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GrabInput = WIN_GrabInput;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GetWMInfo = WIN_GetWMInfo;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;FreeWMCursor = WIN_FreeWMCursor;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;CreateWMCursor = WIN_CreateWMCursor;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;ShowWMCursor = WIN_ShowWMCursor;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;WarpWMCursor = WIN_WarpWMCursor;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;CheckMouseMode = WIN_CheckMouseMode;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;InitOSKeymap = DIB_InitOSKeymap;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;PumpEvents = DIB_PumpEvents;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Set up the windows message handling functions </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;WIN_Activate = DIB_Activate;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;WIN_RealizePalette = DIB_RealizePalette;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;WIN_PaletteChanged = DIB_PaletteChanged;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;WIN_WinPAINT = DIB_WinPAINT;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;HandleMessage = DIB_HandleMessage;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;free = DIB_DeleteDevice;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;We're finally ready </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">return</span><br />
&nbsp;device;</p>
<p> }<br />
</span><br /></p>
<p>开始时为video driver分配内存，然后为相应的参数赋值，最最重要的就是为video driver的函数指针赋值，赋值成当前video driver的函数，以此实现我开始说的，以C语言实现类似面向对象的效果。</p>
<p>video driver的那一堆函数指针就像是抽象的接口，这里的函数就像是子类的实现。上层逻辑只需要使用video driver的指针并调用其中的函数即可，完全统一，并且不用关心指针具体是调用了哪个&quot;子类&ldquo;的函数。因为习惯了C++，我很少使用C语言来编写大规模的代码，所以对这些特性并不是非常熟悉，但是在C语言实现面向对象特性方面，我见过几派，我感觉这种方式算是比较好的，比完全使用宏来模拟C++的效果看上去要更加容易理解和自然。当然，因为C语言的确没有&quot;标准&quot;的面向对象实现方式，所以到底那个更好，也只能是见仁见智的问题了，估计也会像&quot;大括号战争&rdquo;一样没有休止。</p>
<p>此处还值得一提的是，SDL_VIDEO_OPENGL宏是默认开启的，也就是说，在Win32下使用GDI这个默认的video driver时，</p>
<p>SDL进行了<br />
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; device-&gt;GL_LoadLibrary = WIN_GL_LoadLibrary;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GL_GetProcAddress = WIN_GL_GetProcAddress;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GL_GetAttribute = WIN_GL_GetAttribute;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GL_MakeCurrent = WIN_GL_MakeCurrent;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GL_SwapBuffers = WIN_GL_SwapBuffers;</span><br /></p>
<p>这些函数的赋值。形成了对OpenGL的支持。这里与我以前了解的有些差异，因为我以前以为SDL在Win32下是默认使用DirectX加速的，现在看来并不是，就如侯捷所言，&quot;源码面前了无秘密&quot;，这些点点滴滴的东西，也算是看源码的一种收获。</p>
<p>然后，我查看了文档：<br />
<span style="color: #8b0000;">《<a id="d5ef" title="SDL支持哪些系统平台？" href="http://www.libsdl.org/intro.cn/whatplatforms.html" title="SDL支持哪些系统平台？">SDL支持哪些系统平台？</a><br />
</span><br />
》</p>
<p>有如下描述：</p>
<p>&nbsp;</p>
<ul>
<li>有两个版本，一个是适合所有基于Win32的系统的安全版本，另一个是基于DirectX的高性能版本。 </li>
<li>安全版本的视频显示采用GDI。高性能版本采用DirectDraw，并支持硬件加速。 </li>
<li>安全版本的音频回放采用waveOut API。高性能版本采用DirectSound。 </li>
</ul>
<p>
这里可以看出，默认的时候SDL使用了Win32系统的安全版本。</p>
<p>&nbsp;</p>
<p>此步初始化后，再利用video driver自己的VideoInit函数再次进行针对特殊的video driver的初始化。然后再开始SDL的事件线程（详细内容见上节）</p>
<p>然后，此时已经回到SDL_InitSubSystem函数了，此函数还需要进行一些其他模块的初始化，比如时间模块，摇杆等，这里就不多讲了。</p>
<p>看到这里，对于初始化部分的流程应该就比较清楚了，现在有个问题：</p>
<p>怎么改变SDL使用的video driver的默认值？比如，改成DirectX版本的。</p>
<p>从上面来看，有两种办法，</p>
<p>其一，改变<span style="font-family: monospace;">bootstrap</span><br />
数组中各driver的顺序，将directX的driver提到第一，那样默认就初始化directX版本了。</p>
<p>其二，<span style="font-family: monospace;">让SDL_getenv(<span style="color: #008080;">&quot;SDL_VIDEODRIVER&quot;</span><br />
)</span><br />
返回directX版本driver的名字。</p>
<p>个人感觉方法二明显更加自然一些，感觉也是SDL作者提供的选择方案。那么，尝试一下，这里我通过SDL提供的接口SDL_putenv来设置环境变量，看看效果。</p>
<p>根据SDL_getenv的调用及前面查看的bootstrap的值，知道SDL查看的环境变量名为SDL_VIDEODRIVER，directX表示的driver名字为directx，所以在初始化前添加如下代码：</p>
<p>SDL_putenv(&quot;SDL_VIDEODRIVER=directx&quot;);</p>
<p>可以看到效果是以&quot;directx&quot;为第一参数调用SDL_VideoInit，并且进入了一下代码：<br />
<span style="font-family: monospace;"></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">for</span><br />
&nbsp;( i=<span style="color: #008080;">0</span><br />
; bootstrap[i]; ++i ) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;( SDL_strcasecmp(bootstrap[i]-&gt;name, driver_name) == <span style="color: #008080;">0</span><br />
) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;( bootstrap[i]-&gt;available() ) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;video = bootstrap[i]-&gt;create(index);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">break</span><br />
;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
</span><br />
此时，通过SDL_strcasecmp的调用，略过了GDI的video driver，然后使用了directX的driver。首先进入的available函数是：DX5_Available，晕了，DX5。。。。。什么年代的东西啊。。。。。。无语中。</p>
<p>在DX5_Available的调用中，仅仅通过以下语句判断了DINPUT.DLL和DDRAW.DLL动态库及DirectDrawCreate函数的存在，来判断DX5 driver是否可用。</p>
<p>DInputDLL = LoadLibrary(TEXT(&quot;DINPUT.DLL&quot;));</p>
<p>DDrawDLL = LoadLibrary(TEXT(&quot;DDRAW.DLL&quot;));</p>
<p>DDrawCreate = (void *)GetProcAddress(DDrawDLL, TEXT(&quot;DirectDrawCreate&quot;));</p>
<p>同时，上述语句也说明，SDL使用的DirectX加速使用的是DX5.....并且使用的是DirectDraw，在那古老的年代，我不知道有没有D3D，不过对DDraw的使用倒是印证了我初看SDL渲染接口时的印象，抽象的接口与DDraw太像了。。。。。。。下面函数赋值的时候应该还能看到。</p>
<p>DX5_CreateDevice为SDL DirectX driver的创建函数，如同GDI版本一样对函数进行赋值。<br />
<span style="font-family: monospace;"></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Set the function pointers </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;VideoInit = DX5_VideoInit;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;ListModes = DX5_ListModes;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;SetVideoMode = DX5_SetVideoMode;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;UpdateMouse = WIN_UpdateMouse;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;CreateYUVOverlay = DX5_CreateYUVOverlay;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;SetColors = DX5_SetColors;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;UpdateRects = <span style="color: #008080;">NULL</span><br />
;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;VideoQuit = DX5_VideoQuit;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;AllocHWSurface = DX5_AllocHWSurface;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;CheckHWBlit = DX5_CheckHWBlit;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;FillHWRect = DX5_FillHWRect;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;SetHWColorKey = DX5_SetHWColorKey;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;SetHWAlpha = DX5_SetHWAlpha;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;LockHWSurface = DX5_LockHWSurface;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;UnlockHWSurface = DX5_UnlockHWSurface;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;FlipHWSurface = DX5_FlipHWSurface;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;FreeHWSurface = DX5_FreeHWSurface;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;SetGammaRamp = DX5_SetGammaRamp;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GetGammaRamp = DX5_GetGammaRamp;<br />
<span style="color: #c000c0;">#if SDL_VIDEO_OPENGL</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GL_LoadLibrary = WIN_GL_LoadLibrary;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GL_GetProcAddress = WIN_GL_GetProcAddress;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GL_GetAttribute = WIN_GL_GetAttribute;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GL_MakeCurrent = WIN_GL_MakeCurrent;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GL_SwapBuffers = WIN_GL_SwapBuffers;<br />
<span style="color: #c000c0;">#endif</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;SetCaption = WIN_SetWMCaption;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;SetIcon = WIN_SetWMIcon;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;IconifyWindow = WIN_IconifyWindow;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GrabInput = WIN_GrabInput;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;GetWMInfo = WIN_GetWMInfo;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;FreeWMCursor = WIN_FreeWMCursor;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;CreateWMCursor = WIN_CreateWMCursor;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;ShowWMCursor = WIN_ShowWMCursor;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;WarpWMCursor = WIN_WarpWMCursor;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;CheckMouseMode = WIN_CheckMouseMode;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;InitOSKeymap = DX5_InitOSKeymap;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;device-&gt;PumpEvents = DX5_PumpEvents;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">/*</span><br />
<span style="color: #804000;">&nbsp;Set up the windows message handling functions </span><br />
<span style="color: #804000;">*/</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;WIN_Activate = DX5_Activate;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;WIN_RealizePalette = DX5_RealizePalette;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;WIN_PaletteChanged = DX5_PaletteChanged;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;WIN_WinPAINT = DX5_WinPAINT;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;HandleMessage = DX5_HandleMessage;</p>
<p>这里我们可以看到，相对GDI版本而言，除了速度之外，DirectX版本明显支持的特性更多，上面的函数指针赋值就没有GDI版本那么多NULL了，全部都有对应的函数。</p>
<p>最让人惊讶的时候，还是有OpenGL的函数。最后经过我测试，的确也是能够使用OpenGL。。。。。。</p>
<p>很显然，关键在于</p>
<p>SDL_Surface* screen = SDL_SetVideoMode( WINDOW_WIDTH, WINDOW_HEIGHT, 16, SDL_OPENGL); </p>
<p>一句的调用。</p>
<p>因为本文太长，在Google Document上输入都已经很卡了，所以留待下篇文章再看。</span></p>
<p><span style="font-family: monospace;"><br />
</span></p>
<p>&nbsp;</p>
<p align="right">原创文章作者保留版权 转载请注明原作者 并给出链接</p>
<p align="right"><strong><a href="http://www.jtianling.com">write by 九天雁翎(JTianLing) -- www.jtianling.com</a><br />
</strong></p>
<p>&nbsp;</p>
