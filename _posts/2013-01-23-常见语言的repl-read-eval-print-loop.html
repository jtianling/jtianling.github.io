---
layout: post
title: "常见语言的REPL(Read-eval-print-loop)"
categories:
- "通用编程技术"
tags:
- repl
status: publish
type: post
published: true
meta:
  mkd_text: "在一般的新脚本语言中, 有REPL是常态, 因为REPL非常的方便, 谁用谁知道.  最近学的语言已经多到几乎超过我的脑容量了, 所以我更加经常的用REPL来验证一些语法,
    所以找到了一些传统不存在REPL语言的REPL环境, 在这里记录和分享一下:\n\n$TOC$\n\n# 原生就有REPL的语言\n## Common Lisp\n一般的Common
    Lisp实现都有REPL, 比如我在Mac下用的[*Clozure CL*](http://clozure.com/index.html), 该实现甚至还有Mac
    App Store的[版本](https://itunes.apple.com/us/app/clozure-cl/id489900618?mt=12).
    \ \n\n## Ruby\n官方实现就带REPL, 只是命令是irb, 意思是Interactive Ruby Shell, 而不是ruby.  `exit()`,
    `quit()`命令都可以退出.  \n同时, 也有个网页版[*tryruby*](http://tryruby.org/)(同时也是个ruby的在线教学),
    不过似乎被墙.  \n\n## Python\n官方实现带REPL, 直接用`python`命令, 不带参数时即进入REPL环境.  用`exit()`退出.\n\n##
    Lua\n官方实现带REPL, 直接用`lua`命令即可. \n\n# 原生不带REPL的语言\n## JavaScript\n类似JavaScript这种量级的脚本语言本来应该都是有REPL的,
    可是JavaScript是个一般在浏览器中运行的语言, 所以有些特殊了.  不过有一些实现.  比如Mozilla的[*Rhino*](https://developer.mozilla.org/en-US/docs/Rhino),
    以前我写过一个*Rhnio*在[Mac下安装的教程](http://www.jtianling.com/articles/2057.html), 这里不再重复了.
    \ \n另外, 我推荐使用最近流行的[node.js](http://nodejs.org/)来做REPL, 虽然node.js一般都被认为是一个服务端的脚本环境,
    但是本身就是个很不错的REPL环境, 还自带一些common javascript的库环境, 同时支持npm, 比Rhnio要更加强大一些.    在Mac下简单的使用node.js方法是用*brew*,
    虽然版本可能有些老.  \n\n## PHP\nPHP作为服务端的一个常用脚本语言, 本身设计就是作为一个apache的mod语言, 所以本身也不带REPL,
    虽然以它的语言类型来说应该是带的, 不过Facebook为我们实现了一个PHP的REPL [*phpsh*](http://www.phpsh.org/).
    \ 有意思的是该实现竟然是通过Python来安装的...  \n\n## JAVA\nJAVA作为传统的静态类型语言, 本身是不带REPL环境的, 但是有[*BeanShell*](http://www.beanshell.org/).
    \ \nBeanShell下载后, 将.jar文件放在JAVA可以找的到的库目录中, 比如Mac下的`~/Library/Java/Extension`目录,
    然后通过命令`java bsh.Interpreter`来运行.  使用`exit();`命令退出.  \n我一般在.bash_profile中用`alias
    ijava='java bsh.Interpreter'`简化为`ijava`命令.  \n同时也有一些人推荐使用类似[*Closure*](http://clojure.org/),
    [*Groovy*](http://groovy.codehaus.org/), [*Scala*](http://www.scala-lang.org/)等jvm上带REPL的语言环境(一般兼容JAVA)来做REPL的,
    没有试用过, 不评价.  \n\n## 'C#'\n[据说](http://stackoverflow.com/questions/1187423/anders-hejlsbergs-c-sharp-4-0-repl)以后将会有官方实现的REPL,
    目前有一些第三方的实现.  比如[*Mono*](http://www.mono-project.com/CsharpRepl)就[自带REPL](http://www.mono-project.com/CsharpRepl).
    \ 安装完Mono后, 执行`csharp`命令就可以进入C#的REPL了.  \n\n## C++\n[*cling*](http://root.cern.ch/drupal/content/cling),
    有Mac版本直接下载, 不过运行的方式有些诡异, 那就是在解压后的目录中运行`./bin/root`(在bin目录中运行反而不行), 需要先安装[*XQuartz*](http://xquartz.macosforge.org/landing/)这个Mac下的X环境.
    \ 用`exit();`退出.  \n发现C++能有REPL真是惊喜, 虽然本质上C++并不是一个适合REPL的语言.  而cling这个REPL甚至都没法方便的定义一个函数.
    \ \n\n## Haxe\n[ihx](https://github.com/ianxm/ihx),  可以直接通过`haxelib install ihx`安装,
    然后通过`haxelib run ihx`运行.  \n也有一个网页运行版本<http://try.haxe.org/>.  \n我在`~/.bash_profile`中添加`alias
    ihx='haxelib run ihx'`, 执行`ihx`即可进入Haxe的REPL.  \n\n# 其他\n## repl.it\n这个不知道怎么归类,
    [*repl.it*](http://repl.it/languages)本身支持多种语言, 运行在网页上.  虽然感觉有些版本比较老(比如Ruby还是1.8.x的版本),
    但是作为网页服务, 并且支持那么多语言, 省事的时候可以尝试一用.  支持的语言如下:  \n\n* 经典的语言(Classic)\n    * QBasic:
    \ Structured programming for beginners.  \n    * Forth:  An interactive stack-oriented
    language.  \n* 实用的语言(Practical)\n    * Ruby (beta):  A natural dynamic object-oriented
    language.  \n    * Python:  A dynamic language emphasizing readability.  \n    *
    Lua:  A lightweight multi-paradigm scripting language.  \n    * Scheme:  An elegant
    dynamic dialect of Lisp.  \n* 诡异的语言(Esoteric)\n    * Emoticon:  Programming with
    an extra dose of smile.  \n    * Brainfuck:  A pure Turing machine controller.
    \ \n    * LOLCODE:  The basic language of lolcats.  \n    * Unlambda:  Functional
    purity given form.  \n    * Bloop:  Nothing but bounded loops.  \n* 网页语言(Web)\n
    \   * JavaScript:  The de facto language of the Web.  \n    * Javascript.next:
    \ The JavaScript of tomorrow.  \n    * Move:  The easy way to program the web.
    \ \n    * Kaffeine:  Extended JavaScript for pros.  \n    * CoffeeScript:  Unfancy
    JavaScript.  \n    * Roy:  Small functional language that compiles to JavaScript.
    \ \n\n## codepad\n[*codepad*](http://codepad.org/)这个算不上REPL, 但是允许你不安装任何编译器就可以在网页上运行很多语言,
    所以有时候也算很方便.  特别是你想简单的给出一些代码片段, 让别人可以迅速的得出结果时.  codepad会自动的生成一个地址, 你直接分享这个地址即可,
    比如这个[Python的片段](http://codepad.org/rryidzqt).  任何人点击`submit`都能很快的看到结果.  这种分享代码片段的方式比[*snipplr*](http://snipplr.com/)和[*github
    gist*](https://gist.github.com/)这种单纯贴代码的方式要更为先进一些.  \n支持的语言如下:  \n\n* C\n* C++\n*
    D\n* Haskell\n* Lua\n* OCaml\n* PHP\n* Perl\n* Plain Text\n* Python\n* Ruby\n*
    Scheme\n* Tcl\n\n# WIKI的列表\n发现这里的列表也挺详细的:<http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop>\n\n<div
    style=\"text-align:right\">\n  writen&nbsp;by <a href=\"http://www.jtianling.com\"
    target=\"_blank\">九天雁翎(JTianLing) -- www.jtianling.com</a>\n</div>"
  views: '209'
  _wp_old_slug: "%e4%b8%80%e7%a7%8d%e8%af%ad%e8%a8%80-%e9%80%82%e5%90%88%e4%bb%bb%e4%bd%95%e6%97%b6%e5%80%99%e4%bd%bf%e7%94%a8-haxe%e7%89%b9%e6%80%a7%e6%9d%82%e8%b0%88"
author:
  login: jtianling
  email: jtianling@gmail.com
  display_name: jtianling
  first_name: ''
  last_name: ''
---
<p>在一般的新脚本语言中, 有REPL是常态, 因为REPL非常的方便, 谁用谁知道.  最近学的语言已经多到几乎超过我的脑容量了, 所以我更加经常的用REPL来验证一些语法, 所以找到了一些传统不存在REPL语言的REPL环境, 在这里记录和分享一下:</p>
<div class="toc">
<ul>
<li><a href="#repl">原生就有REPL的语言</a>
<ul>
<li><a href="#common-lisp">Common Lisp</a></li>
<li><a href="#ruby">Ruby</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#lua">Lua</a></li>
</ul>
</li>
<li><a href="#repl_1">原生不带REPL的语言</a>
<ul>
<li><a href="#javascript">JavaScript</a></li>
<li><a href="#php">PHP</a></li>
<li><a href="#java">JAVA</a></li>
<li><a href="#c">'C#'</a></li>
<li><a href="#c_1">C++</a></li>
<li><a href="#haxe">Haxe</a></li>
</ul>
</li>
<li><a href="#_1">其他</a>
<ul>
<li><a href="#replit">repl.it</a></li>
<li><a href="#codepad">codepad</a></li>
</ul>
</li>
<li><a href="#wiki">WIKI的列表</a></li>
</ul>
</div>
<h1 id="repl">原生就有REPL的语言</h1>
<h2 id="common-lisp">Common Lisp</h2>
<p>一般的Common Lisp实现都有REPL, 比如我在Mac下用的<a href="http://clozure.com/index.html"><em>Clozure CL</em></a>, 该实现甚至还有Mac App Store的<a href="https://itunes.apple.com/us/app/clozure-cl/id489900618?mt=12">版本</a>.  </p>
<h2 id="ruby">Ruby</h2>
<p>官方实现就带REPL, 只是命令是irb, 意思是Interactive Ruby Shell, 而不是ruby.  <code>exit()</code>, <code>quit()</code>命令都可以退出.<br />
同时, 也有个网页版<a href="http://tryruby.org/"><em>tryruby</em></a>(同时也是个ruby的在线教学), 不过似乎被墙.  </p>
<h2 id="python">Python</h2>
<p>官方实现带REPL, 直接用<code>python</code>命令, 不带参数时即进入REPL环境.  用<code>exit()</code>退出.</p>
<h2 id="lua">Lua</h2>
<p>官方实现带REPL, 直接用<code>lua</code>命令即可. </p>
<h1 id="repl_1">原生不带REPL的语言</h1>
<h2 id="javascript">JavaScript</h2>
<p>类似JavaScript这种量级的脚本语言本来应该都是有REPL的, 可是JavaScript是个一般在浏览器中运行的语言, 所以有些特殊了.  不过有一些实现.  比如Mozilla的<a href="https://developer.mozilla.org/en-US/docs/Rhino"><em>Rhino</em></a>, 以前我写过一个<em>Rhnio</em>在<a href="http://www.jtianling.com/articles/2057.html">Mac下安装的教程</a>, 这里不再重复了.<br />
另外, 我推荐使用最近流行的<a href="http://nodejs.org/">node.js</a>来做REPL, 虽然node.js一般都被认为是一个服务端的脚本环境, 但是本身就是个很不错的REPL环境, 还自带一些common javascript的库环境, 同时支持npm, 比Rhnio要更加强大一些.    在Mac下简单的使用node.js方法是用<em>brew</em>, 虽然版本可能有些老.  </p>
<h2 id="php">PHP</h2>
<p>PHP作为服务端的一个常用脚本语言, 本身设计就是作为一个apache的mod语言, 所以本身也不带REPL, 虽然以它的语言类型来说应该是带的, 不过Facebook为我们实现了一个PHP的REPL <a href="http://www.phpsh.org/"><em>phpsh</em></a>.  有意思的是该实现竟然是通过Python来安装的...  </p>
<h2 id="java">JAVA</h2>
<p>JAVA作为传统的静态类型语言, 本身是不带REPL环境的, 但是有<a href="http://www.beanshell.org/"><em>BeanShell</em></a>.<br />
BeanShell下载后, 将.jar文件放在JAVA可以找的到的库目录中, 比如Mac下的<code>~/Library/Java/Extension</code>目录, 然后通过命令<code>java bsh.Interpreter</code>来运行.  使用<code>exit();</code>命令退出.<br />
我一般在.bash_profile中用<code>alias ijava='java bsh.Interpreter'</code>简化为<code>ijava</code>命令.<br />
同时也有一些人推荐使用类似<a href="http://clojure.org/"><em>Closure</em></a>, <a href="http://groovy.codehaus.org/"><em>Groovy</em></a>, <a href="http://www.scala-lang.org/"><em>Scala</em></a>等jvm上带REPL的语言环境(一般兼容JAVA)来做REPL的, 没有试用过, 不评价.  </p>
<h2 id="c">'C#'</h2>
<p><a href="http://stackoverflow.com/questions/1187423/anders-hejlsbergs-c-sharp-4-0-repl">据说</a>以后将会有官方实现的REPL, 目前有一些第三方的实现.  比如<a href="http://www.mono-project.com/CsharpRepl"><em>Mono</em></a>就<a href="http://www.mono-project.com/CsharpRepl">自带REPL</a>.  安装完Mono后, 执行<code>csharp</code>命令就可以进入C#的REPL了.  </p>
<h2 id="c_1">C++</h2>
<p><a href="http://root.cern.ch/drupal/content/cling"><em>cling</em></a>, 有Mac版本直接下载, 不过运行的方式有些诡异, 那就是在解压后的目录中运行<code>./bin/root</code>(在bin目录中运行反而不行), 需要先安装<a href="http://xquartz.macosforge.org/landing/"><em>XQuartz</em></a>这个Mac下的X环境.  用<code>exit();</code>退出.<br />
发现C++能有REPL真是惊喜, 虽然本质上C++并不是一个适合REPL的语言.  而cling这个REPL甚至都没法方便的定义一个函数.  </p>
<h2 id="haxe">Haxe</h2>
<p><a href="https://github.com/ianxm/ihx">ihx</a>,  可以直接通过<code>haxelib install ihx</code>安装, 然后通过<code>haxelib run ihx</code>运行.<br />
也有一个网页运行版本<a href="http://try.haxe.org/">http://try.haxe.org/</a>.<br />
我在<code>~/.bash_profile</code>中添加<code>alias ihx='haxelib run ihx'</code>, 执行<code>ihx</code>即可进入Haxe的REPL.  </p>
<h1 id="_1">其他</h1>
<h2 id="replit">repl.it</h2>
<p>这个不知道怎么归类, <a href="http://repl.it/languages"><em>repl.it</em></a>本身支持多种语言, 运行在网页上.  虽然感觉有些版本比较老(比如Ruby还是1.8.x的版本), 但是作为网页服务, 并且支持那么多语言, 省事的时候可以尝试一用.  支持的语言如下:  </p>
<ul>
<li>经典的语言(Classic)
<ul>
<li>QBasic:  Structured programming for beginners.  </li>
<li>Forth:  An interactive stack-oriented language.  </li>
</ul>
</li>
<li>实用的语言(Practical)
<ul>
<li>Ruby (beta):  A natural dynamic object-oriented language.  </li>
<li>Python:  A dynamic language emphasizing readability.  </li>
<li>Lua:  A lightweight multi-paradigm scripting language.  </li>
<li>Scheme:  An elegant dynamic dialect of Lisp.  </li>
</ul>
</li>
<li>诡异的语言(Esoteric)
<ul>
<li>Emoticon:  Programming with an extra dose of smile.  </li>
<li>Brainfuck:  A pure Turing machine controller.  </li>
<li>LOLCODE:  The basic language of lolcats.  </li>
<li>Unlambda:  Functional purity given form.  </li>
<li>Bloop:  Nothing but bounded loops.  </li>
</ul>
</li>
<li>网页语言(Web)
<ul>
<li>JavaScript:  The de facto language of the Web.  </li>
<li>Javascript.next:  The JavaScript of tomorrow.  </li>
<li>Move:  The easy way to program the web.  </li>
<li>Kaffeine:  Extended JavaScript for pros.  </li>
<li>CoffeeScript:  Unfancy JavaScript.  </li>
<li>Roy:  Small functional language that compiles to JavaScript.  </li>
</ul>
</li>
</ul>
<h2 id="codepad">codepad</h2>
<p><a href="http://codepad.org/"><em>codepad</em></a>这个算不上REPL, 但是允许你不安装任何编译器就可以在网页上运行很多语言, 所以有时候也算很方便.  特别是你想简单的给出一些代码片段, 让别人可以迅速的得出结果时.  codepad会自动的生成一个地址, 你直接分享这个地址即可, 比如这个<a href="http://codepad.org/rryidzqt">Python的片段</a>.  任何人点击<code>submit</code>都能很快的看到结果.  这种分享代码片段的方式比<a href="http://snipplr.com/"><em>snipplr</em></a>和<a href="https://gist.github.com/"><em>github gist</em></a>这种单纯贴代码的方式要更为先进一些.<br />
支持的语言如下:  </p>
<ul>
<li>C</li>
<li>C++</li>
<li>D</li>
<li>Haskell</li>
<li>Lua</li>
<li>OCaml</li>
<li>PHP</li>
<li>Perl</li>
<li>Plain Text</li>
<li>Python</li>
<li>Ruby</li>
<li>Scheme</li>
<li>Tcl</li>
</ul>
<h1 id="wiki">WIKI的列表</h1>
<p>发现这里的列表也挺详细的:<a href="http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop</a></p>
<div style="text-align:right">
  writen&nbsp;by <a href="http://www.jtianling.com" target="_blank">九天雁翎(JTianLing) -- www.jtianling.com</a>
</div>
