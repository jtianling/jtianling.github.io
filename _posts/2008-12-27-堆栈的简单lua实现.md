---
layout: post
title: "堆栈的简单lua实现"
categories:
- Lua
- "算法"
tags:
- Lua
- "堆栈"
status: publish
type: post
published: true
meta:
  ratings_users: '0'
  ratings_score: '0'
  ratings_average: '0'
  views: '29'
author:
  login: jtianling
  email: jtianling@gmail.com
  display_name: jtianling
  first_name: ''
  last_name: ''
---

  

# 堆栈的简单lua实现

**_write by_**** _九天雁翎_**** _(JTianLing) --  
blog.csdn.net/vagrxie_**

 1 #!/usr/bin/env lua  
 2 require "CList"  
 3   
 4 CStack = CList:New()  
 5   
 6 function CStack:Top()  
 7     **return**  self:End():MovePrev().pos.data  
 8 end  
 9   
10 function CStack:Push(a)  
11     self:PushBack(a)  
12 end  
13   
14 function CStack:Pop()  
15     self:PopBack()  
16 end  
17   
18 function CStack:Size()  
19     **return**  CList.Size(self)  
20 end  
21   
22 \-- Test CStact  
23 s = CStack:New()  
24 s:Push(10)  
25 print(s:Top())  
26 s:Push(20)  
27 print(s:Top())  
28 s:Push(30)  
29 print(s:Top())  
30 s:Pop()  
31 print(s:Top())  
32 print(s:Size())  
33   
34   
35   
36   
37

 

CList的是一个我用链表实现的表（仿照C++中list 实现）

具体实现见

http://www.jtianling.com/archive/2008/12/25/3606972.aspx

其实到了这个层次的lua语法（用一个类去实现另一个类），我已经不是太了解了，Programming in lua中也没有出现类似的语法，只简单的提到了怎么去New,书中是用这种方式去实现继承的。第19行的语法纯粹是自己摸索出来的，一开始用self:Size()，结果并没有从CList中去找，而是陷入了纯粹的递推自身调用。

 

**_write by_**** _九天雁翎(JTianLing) --  
blog.csdn.net/vagrxie_**

 
