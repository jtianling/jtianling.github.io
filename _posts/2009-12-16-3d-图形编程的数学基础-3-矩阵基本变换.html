---
layout: post
title: 3D 图形编程的数学基础(3) 矩阵基本变换
categories:
- "图形技术"
tags:
- "数学"
- "矩阵变换"
status: publish
type: post
published: true
meta:
  ratings_users: '0'
  ratings_score: '0'
  ratings_average: '0'
  views: '18'
author:
  login: jtianling
  email: jtianling@gmail.com
  display_name: jtianling
  first_name: ''
  last_name: ''
---

<p style="padding-bottom: 0px; margin: 1em 0px 0.5em; padding-left: 0px; padding-right: 0px; padding-top: 0px" align="right"><b><a style="color: rgb(0,107,173); text-decoration: none" href="http://www.jtianling.com">write by 九天雁翎(JTianLing) -- www.jtianling.com</a></b><b></b><b><u></u></b></p>
<p style="padding-bottom: 0px; margin: 1em 0px 0.5em; padding-left: 0px; padding-right: 0px; padding-top: 0px" align="right"><a style="color: rgb(119,0,0); text-decoration: none" href="http://groups.google.com/group/jiutianfile/"><b>讨论新闻组及文件</b></a></p>
<p align="left">这里开始，是真正的与3D图形编程相关的知识了，前两节只能算是纯数学。</p>
<p align="left">&#160;</p>
<h3>平移矩阵</h3>
<p>要想将向量(x, y, z, 1)沿x轴平移<a href="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_1d45df16_2.gif"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; margin-left: 0px; border-left-width: 0px; margin-right: 0px" title="yyyy_html_1d45df16" border="0" hspace="8" alt="yyyy_html_1d45df16" src="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_1d45df16_thumb.gif" width="25" height="21" /></a>个单位，沿y轴平移<a href="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_m6cec65e6_2.gif"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; margin-left: 0px; border-left-width: 0px; margin-right: 0px" title="yyyy_html_m6cec65e6" border="0" hspace="8" alt="yyyy_html_m6cec65e6" src="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_m6cec65e6_thumb.gif" width="25" height="21" /></a>，沿z轴平移<a href="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_m63b4a2d4_2.gif"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; margin-left: 0px; border-left-width: 0px; margin-right: 0px" title="yyyy_html_m63b4a2d4" border="0" hspace="8" alt="yyyy_html_m63b4a2d4" src="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_m63b4a2d4_thumb.gif" width="24" height="21" /></a>个单位，我们只需要将该向量与如下矩阵相乘。</p>
<p>N(p) = <a href="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_m1964a5f8%5B4%5D.gif"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; margin-left: 0px; border-left-width: 0px; margin-right: 0px" title="yyyy_html_m1964a5f8[4]" border="0" hspace="8" alt="yyyy_html_m1964a5f8[4]" src="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_m1964a5f8%5B4%5D_thumb.gif" width="123" height="87" /></a></p>
<p>从中可以看出4*4矩阵N中的N41,N42,N43分别控制其在x轴y轴z轴上的平移单位. </p>
<p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_m75c5e44f_2.gif"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; margin-left: 0px; border-left-width: 0px; margin-right: 0px" title="yyyy_html_m75c5e44f" border="0" hspace="8" alt="yyyy_html_m75c5e44f" src="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_m75c5e44f_thumb.gif" width="100" height="85" /></a>是单位矩阵，我们已经知道，乘以其他矩阵相当于没有乘的家伙。这个矩阵就是从单位矩阵稍微变下型，多了第4行的几个值。我们先来看<a href="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_1d45df16_2.gif"><img title="yyyy_html_1d45df16" border="0" hspace="8" alt="yyyy_html_1d45df16" src="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_1d45df16_thumb.gif" width="25" height="21" /></a>为最后结果做出的贡献，向量M(x,y,z,1)与矩阵N(p)相乘后，最后X坐标的值（也就是矩阵M11的值）为x*1 + y*0 + z*0 + 1*px = x + px。（套一下矩形相乘的公式）</p>
<p>y,z的公式一样，就不多说了。这里可以看到，对于实施矩阵平移计算来说，需要将原向量（3维）扩充的一维（一般用w表示)设为1，不然的话，上述x坐标=x*1 + y*0 + z*0 + 0*px=x，也就是说，完全不会改变原矩阵了。</p>
<p>GNU Octave(matlab) 验证一下：</p>
<table border="1">
<tbody>
<tr>
<td>
<pre>&gt; p = [1,0,0,0;0,1,0,0;0,0,1,0;2,3,4,1]
p =

   1   0   0   0
   0   1   0   0
   0   0   1   0
   2   3   4   1

octave-3.2.3.exe:6:d:/Octave/3.2.3_gcc-
&gt; x
x =

   1   2   3   1

octave-3.2.3.exe:7:d:/Octave/3.2.3_gcc-
&gt; x * p
ans =

   3   5   7   1

octave-3.2.3.exe:8:d:/Octave/3.2.3_gcc-</pre>
</td>
</tr>
</tbody>
</table>
<p>x = 2 + 1 = 3,依次类推，结果正确。</p>
<p>在irrlicht中，平移矩阵的代码直接偷懒。。。。。利用了上述公式的推导结果，转换后的x值为x+px。。。。汗-_-!，理论和实际果然还是有差距的。不过想想，说来也是，一个加法就可以完成的平移，为啥非要整个矩阵乘法去完成？此公式的存在就让人郁闷。。。难道仅仅是因为需要的是用矩阵进行的计算。。。。。。<span style="color: blue"></span></p>
<pre class="code"><span style="color: blue">template </span>&lt;<span style="color: blue">class </span><span style="color: #050005">T</span>&gt;
<span style="color: blue">inline void </span><span style="color: #050005">CMatrix4</span>&lt;<span style="color: #050005">T</span>&gt;::<span style="color: #050005">translateVect</span>( <span style="color: #050005">vector3df</span>&amp; <span style="color: #050005">vect </span>) <span style="color: blue">const
</span>{
    <span style="color: #050005">vect</span>.<span style="color: #050005">X </span>= <span style="color: #050005">vect</span>.<span style="color: #050005">X</span>+<span style="color: #050005">M</span>[12];
    <span style="color: #050005">vect</span>.<span style="color: #050005">Y </span>= <span style="color: #050005">vect</span>.<span style="color: #050005">Y</span>+<span style="color: #050005">M</span>[13];
    <span style="color: #050005">vect</span>.<span style="color: #050005">Z </span>= <span style="color: #050005">vect</span>.<span style="color: #050005">Z</span>+<span style="color: #050005">M</span>[14];
}</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>D3D中利用函数：</p>
<pre class="code"><span style="color: green">// Build a matrix which translates by (x, y, z)
</span><span style="color: #050005">D3DXMATRIX</span>* <span style="color: #050005">WINAPI D3DXMatrixTranslation
    </span>( <span style="color: #050005">D3DXMATRIX </span>*<span style="color: #050005">pOut</span>, <span style="color: #050005">FLOAT x</span>, <span style="color: #050005">FLOAT y</span>, <span style="color: #050005">FLOAT z </span>);</pre>
<p><a href="http://11011.net/software/vspaste"></a>实现矩阵的平移，具体方式不明。</p>
<p>&#160;</p>
<h3>缩放矩阵</h3>
<p>我们将一单位矩阵沿X轴缩放X倍,Y轴缩放Y倍,Z轴缩放Z倍,可令该向量与下列矩阵相乘。</p>
<p><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; margin-left: 0px; border-left-width: 0px; margin-right: 0px" title="html_html_m2794d7de" border="0" hspace="8" alt="html_html_m2794d7de" src="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_html_html_m2794d7de_thumb.gif" width="102" height="85" /></p>
<p>按公式推导：X(M11)坐标值为X*x+y*0+z*0+0*0=X*x</p>
<p>y,z的推导类似。</p>
<p>GNU Octave(matlab):</p>
<table border="1">
<tbody>
<tr>
<td>
<pre>&gt; x = [1,2,3,0]
x =

   1   2   3   0

octave-3.2.3.exe:6:f:
&gt; p
p =

   2   0   0   0
   0   3   0   0
   0   0   4   0
   0   0   0   1

octave-3.2.3.exe:7:f:
&gt; x * p
ans =

    2    6   12    0</pre>
</td>
</tr>
</tbody>
</table>
<p>结果正确。其实看了实现的源代码后也会发现这种公式还是没事找事，事实上直接乘多省事啊。</p>
<p>irrlicht中利用下面的实现来构造一个缩放矩阵：</p>
<pre class="code">    <span style="color: blue">template </span>&lt;<span style="color: blue">class </span>T&gt;
    <span style="color: blue">inline </span>CMatrix4&lt;T&gt;&amp; CMatrix4&lt;T&gt;::setScale( <span style="color: blue">const </span>vector3d&lt;T&gt;&amp; scale )
    {
        M[0] = scale.X;
        M[5] = scale.Y;
        M[10] = scale.Z;
<span style="color: blue">#if defined </span>( USE_MATRIX_TEST )
        <span style="color: gray">definitelyIdentityMatrix=false;
</span><span style="color: blue">#endif
        return </span>*<span style="color: blue">this</span>;
    }</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>&#160;</p>
<p>D3D中利用下面的实现完成缩放运算，直接乘就好了。。。。。。</p>
<pre class="code">D3DXINLINE D3DXVECTOR3* D3DXVec3Scale
    ( D3DXVECTOR3 *pOut, CONST D3DXVECTOR3 *pV, FLOAT s)
{
<span style="color: blue">#ifdef </span>D3DX_DEBUG
    <span style="color: gray">if(!pOut || !pV)
        return NULL;
</span><span style="color: blue">#endif

    </span>pOut-&gt;x = pV-&gt;x * s;
    pOut-&gt;y = pV-&gt;y * s;
    pOut-&gt;z = pV-&gt;z * s;
    <span style="color: blue">return </span>pOut;
}</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>&#160;</p>
<p>&#160;</p>
<h3>旋转矩阵：</h3>
<p>旋转矩阵是在乘以一个向量的时候有改变向量的方向但不改变大小的效果的矩阵。旋转矩阵不包括反演，它可以把右手坐标系改变成左手坐标系或反之。所有旋转加上反演形成了正交矩阵的集合。需要注意的是，进行旋转变换时，扩充3维向量的办法是令w=0；</p>
<p>我们可用如下3个矩阵将一个分量分别绕着x,y,z轴顺时针旋转θ弧度。</p>
<p>X(θ) = <a href="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_m5a3e8644_2.gif"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; margin-left: 0px; border-left-width: 0px; margin-right: 0px" title="yyyy_html_m5a3e8644" border="0" hspace="8" alt="yyyy_html_m5a3e8644" src="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_m5a3e8644_thumb.gif" width="155" height="85" /></a></p>
<p>Y(θ) = <a href="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_6d8ae198_3.gif"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; margin-left: 0px; border-left-width: 0px; margin-right: 0px" title="yyyy_html_6d8ae198" border="0" hspace="8" alt="yyyy_html_6d8ae198" src="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_6d8ae198_thumb.gif" width="153" height="85" /></a></p>
<p>Z(θ) = <a href="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_html_html_3de18d4c_2.gif"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; margin-left: 0px; border-left-width: 0px; margin-right: 0px" title="html_html_3de18d4c" border="0" hspace="8" alt="html_html_3de18d4c" src="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_html_html_3de18d4c_thumb.gif" width="154" height="85" /></a></p>
<p align="left">还是先看第一个公式，向量M(x,y,z,0)与矩阵X(θ)相乘后，最后X(M11)坐标值为x*1+y*0+z*0+0*0=x,Y(M12)坐标值为x*0+y*cosθ+z*(-sinθ)+0*0 = y*cosθ + z * (-sinθ),Z(M13)坐标值为x*0+y*sinθ+z*cosθ+0*0 = y*sinθ + z*cosθ，w(m14)坐标为x*0+y*0+z*0+0*1 = 0。</p>
<p align="left">这个就复杂了。。。。。不太好直观的看到验证的结果，我们将其收到2维去看结果。</p>
<p align="left">我们利用GNU Octave(matlab) 的compass命令在2维空间中直观的显示出向量x = [ 1, tan(pi/3), 0, 0](实际显示在x,y平面中）</p>
<p align="left">我们用其围绕Z轴顺时针旋转30度时，方式是乘以θ为30的如上矩阵，结果如下：</p>
<p align="left"><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_image_6_633965303463826250.png"><img style="border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px" title="image" border="0" alt="image" src="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_image_thumb_2_633965303466482500.png" width="705" height="515" /></a> </p>
<p align="left">&#160;</p>
<table border="1">
<tbody>
<tr>
<td>
<pre>&gt; a = pi / 6</pre>
<pre>&gt; p = [cos(a),sin(a),0,0;-sin(a),cos(a),0,0;0,0,1,0;0,0,0,1]
p =

   0.86603   0.50000   0.00000   0.00000
  -0.50000   0.86603   0.00000   0.00000
   0.00000   0.00000   1.00000   0.00000
   0.00000   0.00000   0.00000   1.00000

octave-3.2.3.exe:26:f:/Octave/3.2.3_gcc-4.4.0/bin
&gt; x = [1, tan(pi/3), 0, 0]
x =

   1.00000   1.73205   0.00000   0.00000

octave-3.2.3.exe:27:f:/Octave/3.2.3_gcc-4.4.0/bin
&gt; x2 = x * p
x2 =

   0.00000   2.00000   0.00000   0.00000

octave-3.2.3.exe:28:f:/Octave/3.2.3_gcc-4.4.0/bin
&gt;</pre>
</td>
</tr>
</tbody>
</table>
<p align="left">精确的30度。</p>
<p>irrlicht中设置旋转矩阵就有学问了：</p>
<pre class="code">    <span style="color: blue">template </span>&lt;<span style="color: blue">class </span>T&gt;
    <span style="color: blue">inline </span>CMatrix4&lt;T&gt;&amp; CMatrix4&lt;T&gt;::setRotationRadians( <span style="color: blue">const </span>vector3d&lt;T&gt;&amp; rotation )
    {
        <span style="color: blue">const </span>f64 cr = cos( rotation.X );
        <span style="color: blue">const </span>f64 sr = sin( rotation.X );
        <span style="color: blue">const </span>f64 cp = cos( rotation.Y );
        <span style="color: blue">const </span>f64 sp = sin( rotation.Y );
        <span style="color: blue">const </span>f64 cy = cos( rotation.Z );
        <span style="color: blue">const </span>f64 sy = sin( rotation.Z );

        M[0] = (T)( cp*cy );
        M[1] = (T)( cp*sy );
        M[2] = (T)( -sp );

        <span style="color: blue">const </span>f64 srsp = sr*sp;
        <span style="color: blue">const </span>f64 crsp = cr*sp;

        M[4] = (T)( srsp*cy-cr*sy );
        M[5] = (T)( srsp*sy+cr*cy );
        M[6] = (T)( sr*cp );

        M[8] = (T)( crsp*cy+sr*sy );
        M[9] = (T)( crsp*sy-sr*cy );
        M[10] = (T)( cr*cp );
<span style="color: blue">#if defined </span>( USE_MATRIX_TEST )
        <span style="color: gray">definitelyIdentityMatrix=false;
</span><span style="color: blue">#endif
        return </span>*<span style="color: blue">this</span>;
    }</pre>
<p>为了解释这个函数的作用，看看下列程序：</p>
<pre class="code"><span style="color: blue">#include </span><span style="color: #a31515">&quot;irrlicht.h&quot;
</span><span style="color: blue">#include </span><span style="color: #a31515">&lt;math.h&gt;

</span><span style="color: blue">#pragma comment</span>(<span style="color: blue">lib</span>, <span style="color: #a31515">&quot;Irrlicht.lib&quot;</span>)

<span style="color: blue">using namespace </span>irr;
<span style="color: blue">using namespace </span>irr::core;

<span style="color: blue">int </span>_tmain(<span style="color: blue">int </span>argc, _TCHAR* argv[])
{

    f32 a = 30;
    f32 M[16] = { 1, 0, 0, 0, 
                  0, 1, 0, 0,
                  0, 0, 1, 0,
                  0, 0, 0, 1};
    matrix4 mt;
    mt.setM(M);

    vector3df vec(0.0, 0.0, PI / 6);

    mt.setRotationRadians(vec);

    <span style="color: blue">for</span>(<span style="color: blue">int </span>i = 0; i &lt; 4; ++i)
    {
        <span style="color: blue">for</span>(<span style="color: blue">int </span>j = 0; j &lt; 4; ++j)
        {
            printf(<span style="color: #a31515">&quot;%.6f/t&quot;</span>, mt(i, j));
        }
        printf(<span style="color: #a31515">&quot;/n&quot;</span>);
    }


    <span style="color: blue">return </span>0;
}</pre>
<p><a href="http://11011.net/software/vspaste"></a>运行结果为：</p>
<table border="1">
<tbody>
<tr>
<td>
<pre>0.866025        0.500000        -0.000000       0.000000
-0.500000       0.866025        0.000000        0.000000
0.000000        0.000000        1.000000        0.000000
0.000000        0.000000        0.000000        1.000000</pre>
</td>
</tr>
</tbody>
</table>
<p>看到是啥了吗？没错，就是GNU Octave(matlab) 那个例子中的矩阵：</p>
<p>p = [cos(a),sin(a),0,0;-sin(a),cos(a),0,0;0,0,1,0;0,0,0,1]</p>
<p>事实上，上面程序中的vec表示不绕x,y轴旋转，绕Z轴旋转PI/6，实际的作用就是构造了上述的矩阵P。</p>
<p>上述矩阵通过以下成员函数应用以使用生成的矩阵，其实就是乘法-_-!</p>
<pre class="code"><span style="color: blue">template </span>&lt;<span style="color: blue">class </span>T&gt;
<span style="color: blue">inline void </span>CMatrix4&lt;T&gt;::rotateVect( vector3df&amp; vect ) <span style="color: blue">const
</span>{
    vector3df tmp = vect;
    vect.X = tmp.X*M[0] + tmp.Y*M[4] + tmp.Z*M[8];
    vect.Y = tmp.X*M[1] + tmp.Y*M[5] + tmp.Z*M[9];
    vect.Z = tmp.X*M[2] + tmp.Y*M[6] + tmp.Z*M[10];
}

<span style="color: green">//! An alternate transform vector method, writing into a second vector
</span><span style="color: blue">template </span>&lt;<span style="color: blue">class </span>T&gt;
<span style="color: blue">inline void </span>CMatrix4&lt;T&gt;::rotateVect(core::vector3df&amp; out, <span style="color: blue">const </span>core::vector3df&amp; in) <span style="color: blue">const
</span>{
    out.X = in.X*M[0] + in.Y*M[4] + in.Z*M[8];
    out.Y = in.X*M[1] + in.Y*M[5] + in.Z*M[9];
    out.Z = in.X*M[2] + in.Y*M[6] + in.Z*M[10];
}

<span style="color: green">//! An alternate transform vector method, writing into an array of 3 floats
</span><span style="color: blue">template </span>&lt;<span style="color: blue">class </span>T&gt;
<span style="color: blue">inline void </span>CMatrix4&lt;T&gt;::rotateVect(T *out, <span style="color: blue">const </span>core::vector3df&amp; in) <span style="color: blue">const
</span>{
    out[0] = in.X*M[0] + in.Y*M[4] + in.Z*M[8];
    out[1] = in.X*M[1] + in.Y*M[5] + in.Z*M[9];
    out[2] = in.X*M[2] + in.Y*M[6] + in.Z*M[10];
}</pre>
<p>上面程序后加上如下几句，使用上面刚生成的矩阵：</p>
<pre class="code">vector3df x(1.0, tan(PI/3), 0.0);
mt.rotateVect(x);

printf(<span style="color: #a31515">&quot;x = [%f, %f, %f]/n&quot;</span>, x.X, x.Y, x.Z);</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>输出结果:</p>
<table border="1">
<tbody>
<tr>
<td>
<pre>x = [-0.000000, 2.000000, 0.000000]</pre>
</td>
</tr>
</tbody>
</table>
<p>与通过GNU Octave(matlab) 的一样,精确的30度旋转。</p>
<p>与旋转有关的还有vector的几个函数：</p>
<pre class="code"><span style="color: green">//! Rotates the vector by a specified number of degrees around the Y axis and the specified center.
/** /param degrees Number of degrees to rotate around the Y axis.
/param center The center of the rotation. */
</span><span style="color: blue">void </span>rotateXZBy(f64 degrees, <span style="color: blue">const </span>vector3d&lt;T&gt;&amp; center=vector3d&lt;T&gt;())
{
    degrees *= DEGTORAD64;
    f64 cs = cos(degrees);
    f64 sn = sin(degrees);
    X -= center.X;
    Z -= center.Z;
    set((T)(X*cs - Z*sn), Y, (T)(X*sn + Z*cs));
    X += center.X;
    Z += center.Z;
}

<span style="color: green">//! Rotates the vector by a specified number of degrees around the Z axis and the specified center.
/** /param degrees: Number of degrees to rotate around the Z axis.
/param center: The center of the rotation. */
</span><span style="color: blue">void </span>rotateXYBy(f64 degrees, <span style="color: blue">const </span>vector3d&lt;T&gt;&amp; center=vector3d&lt;T&gt;())
{
    degrees *= DEGTORAD64;
    f64 cs = cos(degrees);
    f64 sn = sin(degrees);
    X -= center.X;
    Y -= center.Y;
    set((T)(X*cs - Y*sn), (T)(X*sn + Y*cs), Z);
    X += center.X;
    Y += center.Y;
}

<span style="color: green">//! Rotates the vector by a specified number of degrees around the X axis and the specified center.
/** /param degrees: Number of degrees to rotate around the X axis.
/param center: The center of the rotation. */
</span><span style="color: blue">void </span>rotateYZBy(f64 degrees, <span style="color: blue">const </span>vector3d&lt;T&gt;&amp; center=vector3d&lt;T&gt;())
{
    degrees *= DEGTORAD64;
    f64 cs = cos(degrees);
    f64 sn = sin(degrees);
    Z -= center.Z;
    Y -= center.Y;
    set(X, (T)(Y*cs - Z*sn), (T)(Y*sn + Z*cs));
    Z += center.Z;
    Y += center.Y;
}</pre>
<p>事实上这些函数就是前面两步的一步实现，实际就是利用了上述公式推导最后的结果，可以去对比一下。</p>
<p>比如下列代码：</p>
<pre class="code">vector3df x(1.0, tan(PI/3), 0.0);
x.rotateXYBy(30);

printf(<span style="color: #a31515">&quot;x = [%f, %f, %f]/n&quot;</span>, x.X, x.Y, x.Z);</pre>
<p><a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a></p>
<p>输出：</p>
<table border="1">
<tbody>
<tr>
<td>
<pre>x = [-0.000000, 2.000000, 0.000000]</pre>
</td>
</tr>
</tbody>
</table>
<p>就是前面通过两步得出的结果。上面irrlicht代码需要注意的是，参数是degree是表示单位是度数，其他时候都默认为弧度。</p>
<p>D3D中使用下列函数实现旋转，没有实现源代码，没有太多好说的。</p>
<pre class="code"><span style="color: green">// Build a matrix which rotates around the X axis
</span>D3DXMATRIX* WINAPI D3DXMatrixRotationX
    ( D3DXMATRIX *pOut, FLOAT Angle );

<span style="color: green">// Build a matrix which rotates around the Y axis
</span>D3DXMATRIX* WINAPI D3DXMatrixRotationY
    ( D3DXMATRIX *pOut, FLOAT Angle );

<span style="color: green">// Build a matrix which rotates around the Z axis
</span>D3DXMATRIX* WINAPI D3DXMatrixRotationZ
    ( D3DXMATRIX *pOut, FLOAT Angle );</pre>
<p>&#160;</p>
<p align="right">原创文章作者保留版权 转载请注明原作者 并给出链接<b></b></p>
<p align="right"><b><a href="http://www.jtianling.com">write by 九天雁翎(JTianLing) -- www.jtianling.com</a></b></p>
