---
layout: post
title: "在Unity3D中使用iPhone原生UI(Use iPhone Native UI in Unity3D)"
categories:
- iOS
- "游戏开发"
tags:
- Cocoa Touch
- Objective-C
- Unity3D
status: publish
type: post
published: true
meta:
  mkd_text: "众所周知, Unity中没有提供UI解决方案, 只能靠第三方的插件来完成.  比较著名的有NGUI等, 但是这种方案不仅需要额外付费(虽然不多),
    并且类似NGUI的插件还不那么易用, 使用起来过于复杂.  \n这里我尝试使用iPhone的原生UI(Cocoa Touch)来作为Unity的UI.  这个听起来似乎很容易的事情,
    其实却比我想象的要难的多的多.  主要原因就在于Unity根本就不是想让你这么用的, 3D引擎为了效率, 一般都需要比较专横的占用系统资源, 在本来速度有限的移动平台就更加需要这样了,
    这样才能发挥出硬件的极限水平, 制作出更精良的游戏.  鉴于这个原因, 这种方法并不适于性能要求高的游戏.  \n\n$TOC$\n\n# 用原生UI的优点\n*
    易用: 原生UI的使用简单, 可用的第三方界面库也很丰富, 特别是对于已经有很多iOS app开发经验的人来说.\n* App风格: 风格上可以很贴近原生app,
    假如真有这样的需求, 那么这个优势是无限大的, 要在Unity去模拟iOS Native UI是个能让开发者自杀的需求.  要是模拟的不到位, 更加会不伦不类.
    \ \n* 免费: 因为NGUI等第三方的UI插件比起Unity本身来说并不贵, 所以这也不算多大的好处.  \n\n# 用原生UI的缺点\n* 自定义功能弱:
    要是需要一个很牛, 很炫的UI, 特别是想要3D效果的UI, 自定义起来, 还是类似NGUI的UI插件要更加强大和方便.  \n* 效率更低: 比起在Unity中直接绘制UI,
    用原生UI效率要更低, 这个很好理解, 因为在Unity中绘制UI时, Unity可以尽可能的优化, 用尽量少的draw call去绘制UI, 而Native
    UI并不受控制.  \n* 不跨平台: 假如你用了iOS的原生UI, 那么你就无法简单的把游戏移植到其他平台了, 起码UI部分你得完全重做.  \n* 开发麻烦:
    作为不能跨平台的衍生问题, 本来Unity的游戏你可以完全在PC/Mac上开发和运行, 然后最后在iPhone/Android上发布, 而一旦用了原生的UI,
    几乎是必然的, 你运行时一定需要在设备上才能运行.  这不仅是原生UI的限制, Unity的对iOS的插件机制也有这样的要求.  另外, 大家都知道, 一旦牵涉到跨语言的开发,
    调试起来就会很麻烦, 用原生UI也不例外, 这算是另外一个增加了开发难度的事情.  \n* 最后一个问题, 而且是最重要的问题是, 从Unity生成一个XCode工程,
    然后到XCode编译完成, 再到载入真机的过程是相当~相当~相当~相当~相当的漫长, 真的很长, Unity的技术团队简直是担心C#的开发着享受不到C++开发者的福利啊~~~~呵呵,
    C++开发者, 你懂的.   \n![代码正在编译](http://d.hiphotos.bdimg.com/album/w%3D1600%3Bq%3D90/sign=60dfd7ed0eb30f24359ae805f8a5ea32/5243fbf2b2119313ab28833c64380cd790238dd6.jpg)
    \ \n但是, 在这种情况下, 开发效率会受到相当~相当~相当~相当~相当大的影响, 相信我, 买个好机器吧... 或者, 哭去吧...  \n\n# 开发环境\n以下所有代码仅在Mac
    OS X 10.8.2, Unity 4.0.0f7, XCode 4.5.2(4G2008a) 环境下测试, 其他环境不保证可用.  \n\n# 基础:
    Unity 插件编写(managed-to-unmanaged)\n这是在Unity中使用Objective-C的唯一方法.  所以这是使用原生UI的基础,
    首先简述一下.  \n主要参考Unity的文档[*Plugins (Pro/Mobile-Only Feature)*](http://docs.unity3d.com/Documentation/Manual/Plugins.html)和[*Building
    Plugins for iOS*](http://docs.unity3d.com/Documentation/Manual/PluginsForIOS.html)\n\n步骤:\n1.在Unity的脚本中使用
    `[DllImport (\"__Internal\")]` 特性(attribute)来标识用Objective-C/C++实现的函数. 如下:\n\n
    \   :::C#\n    [DllImport (\"__Internal\")]\n    private static extern float FooPluginFunction
    ();\n\n2.其次, 在Objective-C/C++中用`extern \"C\"`标识接口:  \n\n    :::objc\n    // .mm\n
    \   extern \"C\" {\n      float FooPluginFunction () {\n        return 10.1f;\n
    \     }\n    }\n\n3.全部的C#文件实现为一个组件(即继承于`MonoBehavior`如下:  \n\n    :::C#\n    using
    UnityEngine;\n    using System.Runtime.InteropServices;\n\n    public class NativeBinding
    : MonoBehaviour {\n\n      // Use this for initialization\n      void Start ()
    {\n      \n      }\n      \n      // Update is called once per frame\n      void
    Update () {\n      \n      }\n      \n      [DllImport (\"__Internal\")]\n      private
    static extern float FooPluginFunction();\n      \n      void Awake() {\n        print
    (FooPluginFunction());\n      }\n    }\n\n注意`using System.Runtime.InteropServices;`必不可少.
    \ \n然后, 当然将这个组件绑定到某个对象上也是必不可少, 不然`Awake`永远不会运行.  \n\n4.在最新版的Unity中, 多了个很方便的特性.
    \ 当把原生代码放在Assets/Plugins/iOS中时(不允许再有子目录了), 在生成XCode工程的后, 代码都会放在`Libraries`中, 解决了以前生成工程后还需要自己添加代码的问题.
    \ \n\n编译运行后可以看到会输出`10.1`(一定能够要真机运行).\n\n# 原生代码调用Unity的Script代码(native-to-managed)\n通过`UnitySendMessage`函数,
    有个问题是似乎没法获得返回值.  还是接上个例子, 通过反过来调用的方式, 输出10.1后再输出一个10.2.  \n\n    :::objc\n    //
    .mm\n    extern \"C\" {\n      float FooPluginFunction () {\n        UnitySendMessage(\"Main
    Camera\", \"Print\", \"10.2\");\n        return 10.1f;\n      }\n    }\n\n上述代码就能直接调用`Main
    Camera`的`Print`函数.  \n\n    :::C#\n    void Print(string message) {\n      print
    (message);\n    }\n\n需要注意的是, 上述调用并不是同步的,, 所以能看到, 虽然上述代码是先调用的`UnitySendMessage`函数,
    但是实际上, `10.2`字符串输出的会晚于`10.1`, 官方文档说`UnitySendMessage`会在下一帧被调用.  \n可以看到这个接口带来的问题不仅不能返回值,
    同时传递的参数还只能是字符串.  \n\n# UnitySendMessage的一个研究\n我看的这个接口的第一反应是, 这个`UnitySendMessage`在Unity中用的是`SendMessage`实现的,
    因为一个Unity对象绑定的组件可能有多个, 也可能有多个同样命名的函数, 此时会同时调用所有符合条件的函数, 这体现了Unity整体设计的动态性.  事实检验,
    果真如此.  \n\n# 显示原生UI的尝试(Try to use Native UI in Unity)\n这是本文真正想做的事情. 在互联网上搜了一圈,
    问这个问题的多, 但是知道回答的太少.  我想可能需要我写完本文后给他们一一回答... 是不是有些托大啊-_-!  \n\n## UI显示\n首先, 讲前面的知识用上,
    并且取个厚道的名字:\n\n    :::objc\n    // .h\n    #import <Foundation/Foundation.h>\n\n
    \   // .mm\n    #import \"NativeBinding.h\"\n    extern \"C\" {\n      void _ActivateUI()
    {\n      }\n\n      void _DeactivateUI() {\n      }\n    }\n\n然后, 添加一个我们用于显示UI的类.
    \ 我这里直接用XCode生成了.  其他代码都不变, 增加一个单件的接口和实现. 代码就很简单了.   \n\n    :::objc\n    // .h\n
    \   #import <UIKit/UIKit.h>\n\n    @interface RootViewController : UIViewController\n\n
    \   + (id) sharedManager;\n\n    @end\n\n    // .mm\n    #import \"RootViewController.h\"\n\n
    \   static RootViewController *sharedRootViewController = nil;\n\n    @interface
    RootViewController ()\n\n    @end\n\n    @implementation RootViewController\n\n
    \   + (id) sharedManager {\n      if (!sharedRootViewController) {\n        sharedRootViewController
    = [[self alloc] initWithNibName:nil bundle:nil];\n      }\n      \n      return
    sharedRootViewController;\n    }\n\n    - (id)initWithNibName:(NSString *)nibNameOrNil
    bundle:(NSBundle *)nibBundleOrNil\n    {\n        self = [super initWithNibName:nibNameOrNil
    bundle:nibBundleOrNil];\n        if (self) {\n            // Custom initialization\n
    \       }\n        return self;\n    }\n\n    - (void)viewDidLoad\n    {\n        [super
    viewDidLoad];\n        // Do any additional setup after loading the view from
    its nib.\n    }\n\n    - (void)didReceiveMemoryWarning\n    {\n        [super
    didReceiveMemoryWarning];\n        // Dispose of any resources that can be recreated.\n
    \   }\n\n    @end\n\n然后把`RootViewController`的显示代码加入到Script调用中去, 怎么加呢? 最关键的代码是在:
    \ \n\n    :::objc\n    UIWindow *window = [[UIApplication sharedApplication] keyWindow];\n\n不需要琢磨OpenGL的那个View怎么改了,
    取得`keyWindow`就行了.  然后就是`addSubView`的事情而已了.  \n完整的代码如下:  \n\n    :::objc\n    //
    .mm\n    #import \"NativeBinding.h\"\n    #import \"RootViewController.h\"\n\n
    \   extern \"C\" {\n\n      void _ActivateUI() {\n\n        //Get the applications
    UIWindow\n        UIWindow *window = [[UIApplication sharedApplication] keyWindow];\n\n
    \       NSLog(@\"window = %@\", window);\n\n        //Create the RootViewController
    from a XIB file.\n        RootViewController *rootViewController = [RootViewController
    sharedManager];\n\n        //Add the RootViewController view to the main window.\n
    \       [window addSubview: rootViewController.view];\n      }\n\n      void _DeactivateUI()
    {\n        if ([RootViewController sharedManager] != nil) {\n          // Code
    ~~\n        }\n      }\n\n    }\n\n此时只要在Unity中直接调用_ActiveUI就OK了.  \n\n    :::c#\n
    \   using UnityEngine;\n    using System.Runtime.InteropServices;\n\n    public
    class NativeBinding : MonoBehaviour {\n\n      void Start () {\n        ActivateUI();\n
    \     }\n\n      [DllImport (\"__Internal\")]\n      private static extern void
    _ActivateUI();\n      \n      public static void ActivateUI() {\n        print
    (\"ActivateUI\");\n      \n        if (Application.platform == RuntimePlatform.IPhonePlayer)
    {\n          _ActivateUI();\n        }\n      }\n      \n      [DllImport (\"__Internal\")]\n
    \     private static extern void _DeactivateUI();\n      \n      public static
    void DeactivateUI() {\n        print (\"ActivateUI\");\n        \n        if (Application.platform
    == RuntimePlatform.IPhonePlayer) {\n          _DeactivateUI();\n        }\n      }\n
    \   }\n\n这里比前面的代码稍微正式一点, 判断了一下平台, 其他的内容其实已经讲过了.  此时运行程序(还是在真机啊~~~), 然后就能看到一个白屏了.
    \ 为了稍微有些内容, 在Interface builder中随意添加控件吧.  一顿乱摆之后:  \n\n![Unity中显示原生UI](http://jtianling.s3.amazonaws.com/images/native_ui_in_unity.png
    \"Unity中显示原生UI\")  \n\n## UI + Unity\n这个是第二个难点了, 目前的实现方式有个很大很大的问题, Unity的View全都挡住了,
    Development编译时右下角那行字都没有了.  这个根本没法用嘛.  \n刚开始我还考虑是不是通过分离控件, 即通过将控件的尺寸调整到合适大小, 合适位置,
    直接加到keyWindow上去, 后来发现其实没有这个必要, 直接把View的background调整为透明即可... 这个真是比我想象的要简单太多...
    \ \n另外, 假如还想更像app呢, 可以在工程配置里面把status bar弄出来.(在Unity生成的工程中, status bar默认隐藏了.)  \n下面是显示效果,
    为了展示Unity的场景, 我按照惯例显示了一个3D的Hello World, 并且给了一个打了动态光源的球. enjoy it!  \n![Unity中混合显示原生UI和Unity场景](https://jtianling.s3.amazonaws.com/images/native_ui_with_unity_screen.png
    \"Unity中混合显示原生UI和Unity场景\")\n\n# 总结\n其实到此为止, 想要实现的功能基本都能实现了, 剩下的也就是一些细节了.  但是,
    Unity的开发团队都不太推荐这种方式, 同样的, 我也不推荐大家使用... 使用后才能知道到底有多痛苦, 特别是非常非常非常非常漫长的编译过程...\n\n#
    参考\nGregg的*An Experiment with iPhone Native UI and Unity 3 Pro*给了我很大的启发.  不知道为什么,
    Gregg自己把他博客上的文章删掉了-_#  \n\n<div style=\"text-align:right\">\n  writen&nbsp;by
    <a href=\"http://www.jtianling.com\" target=\"_blank\">九天雁翎(JTianLing) -- www.jtianling.com</a>\n</div>"
  views: '2386'
  _aioseop_title: "在Unity3D中使用iPhone原生UI(Use iPhone Native UI in Unity3D)"
  _pingme: '1'
  _encloseme: '1'
author:
  login: jtianling
  email: jtianling@gmail.com
  display_name: jtianling
  first_name: ''
  last_name: ''
---
<p>众所周知, Unity中没有提供UI解决方案, 只能靠第三方的插件来完成.  比较著名的有NGUI等, 但是这种方案不仅需要额外付费(虽然不多), 并且类似NGUI的插件还不那么易用, 使用起来过于复杂.<br />
这里我尝试使用iPhone的原生UI(Cocoa Touch)来作为Unity的UI.  这个听起来似乎很容易的事情, 其实却比我想象的要难的多的多.  主要原因就在于Unity根本就不是想让你这么用的, 3D引擎为了效率, 一般都需要比较专横的占用系统资源, 在本来速度有限的移动平台就更加需要这样了, 这样才能发挥出硬件的极限水平, 制作出更精良的游戏.  鉴于这个原因, 这种方法并不适于性能要求高的游戏.  </p>
<div class="toc">
<ul>
<li><a href="#ui">用原生UI的优点</a></li>
<li><a href="#ui_1">用原生UI的缺点</a></li>
<li><a href="#_1">开发环境</a></li>
<li><a href="#unity-managed-to-unmanaged">基础: Unity 插件编写(managed-to-unmanaged)</a></li>
<li><a href="#unityscriptnative-to-managed">原生代码调用Unity的Script代码(native-to-managed)</a></li>
<li><a href="#unitysendmessage">UnitySendMessage的一个研究</a></li>
<li><a href="#uitry-to-use-native-ui-in-unity">显示原生UI的尝试(Try to use Native UI in Unity)</a>
<ul>
<li><a href="#ui_2">UI显示</a></li>
<li><a href="#ui-unity">UI + Unity</a></li>
</ul>
</li>
<li><a href="#_2">总结</a></li>
<li><a href="#_3">参考</a></li>
</ul>
</div>
<h1 id="ui">用原生UI的优点</h1>
<ul>
<li>易用: 原生UI的使用简单, 可用的第三方界面库也很丰富, 特别是对于已经有很多iOS app开发经验的人来说.</li>
<li>App风格: 风格上可以很贴近原生app, 假如真有这样的需求, 那么这个优势是无限大的, 要在Unity去模拟iOS Native UI是个能让开发者自杀的需求.  要是模拟的不到位, 更加会不伦不类.  </li>
<li>免费: 因为NGUI等第三方的UI插件比起Unity本身来说并不贵, 所以这也不算多大的好处.  </li>
</ul>
<h1 id="ui_1">用原生UI的缺点</h1>
<ul>
<li>自定义功能弱: 要是需要一个很牛, 很炫的UI, 特别是想要3D效果的UI, 自定义起来, 还是类似NGUI的UI插件要更加强大和方便.  </li>
<li>效率更低: 比起在Unity中直接绘制UI, 用原生UI效率要更低, 这个很好理解, 因为在Unity中绘制UI时, Unity可以尽可能的优化, 用尽量少的draw call去绘制UI, 而Native UI并不受控制.  </li>
<li>不跨平台: 假如你用了iOS的原生UI, 那么你就无法简单的把游戏移植到其他平台了, 起码UI部分你得完全重做.  </li>
<li>开发麻烦: 作为不能跨平台的衍生问题, 本来Unity的游戏你可以完全在PC/Mac上开发和运行, 然后最后在iPhone/Android上发布, 而一旦用了原生的UI, 几乎是必然的, 你运行时一定需要在设备上才能运行.  这不仅是原生UI的限制, Unity的对iOS的插件机制也有这样的要求.  另外, 大家都知道, 一旦牵涉到跨语言的开发, 调试起来就会很麻烦, 用原生UI也不例外, 这算是另外一个增加了开发难度的事情.  </li>
<li>最后一个问题, 而且是最重要的问题是, 从Unity生成一个XCode工程, 然后到XCode编译完成, 再到载入真机的过程是相当~相当~相当~相当~相当的漫长, 真的很长, Unity的技术团队简直是担心C#的开发着享受不到C++开发者的福利啊~~~~呵呵, C++开发者, 你懂的. <br />
<img alt="代码正在编译" src="http://d.hiphotos.bdimg.com/album/w%3D1600%3Bq%3D90/sign=60dfd7ed0eb30f24359ae805f8a5ea32/5243fbf2b2119313ab28833c64380cd790238dd6.jpg" /><br />
但是, 在这种情况下, 开发效率会受到相当~相当~相当~相当~相当大的影响, 相信我, 买个好机器吧... 或者, 哭去吧...  </li>
</ul>
<h1 id="_1">开发环境</h1>
<p>以下所有代码仅在Mac OS X 10.8.2, Unity 4.0.0f7, XCode 4.5.2(4G2008a) 环境下测试, 其他环境不保证可用.  </p>
<h1 id="unity-managed-to-unmanaged">基础: Unity 插件编写(managed-to-unmanaged)</h1>
<p>这是在Unity中使用Objective-C的唯一方法.  所以这是使用原生UI的基础, 首先简述一下.<br />
主要参考Unity的文档<a href="http://docs.unity3d.com/Documentation/Manual/Plugins.html"><em>Plugins (Pro/Mobile-Only Feature)</em></a>和<a href="http://docs.unity3d.com/Documentation/Manual/PluginsForIOS.html"><em>Building Plugins for iOS</em></a></p>
<p>步骤:<br />
1.在Unity的脚本中使用 <code>[DllImport ("__Internal")]</code> 特性(attribute)来标识用Objective-C/C++实现的函数. 如下:</p>
<div class="codehilite">
<pre><span class="p">[</span><span class="n">DllImport</span> <span class="p">(</span><span class="s">&quot;__Internal&quot;</span><span class="p">)]</span>
<span class="n">private</span> <span class="k">static</span> <span class="k">extern</span> <span class="kt">float</span> <span class="n">FooPluginFunction</span> <span class="p">();</span>
</pre>
</div>
<p>2.其次, 在Objective-C/C++中用<code>extern "C"</code>标识接口:  </p>
<div class="codehilite">
<pre><span class="c1">// .mm</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
  <span class="kt">float</span> <span class="n">FooPluginFunction</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mf">10.1f</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>
<p>3.全部的C#文件实现为一个组件(即继承于<code>MonoBehavior</code>如下:  </p>
<div class="codehilite">
<pre><span class="n">using</span> <span class="n">UnityEngine</span><span class="p">;</span>
<span class="n">using</span> <span class="n">System</span><span class="p">.</span><span class="n">Runtime</span><span class="p">.</span><span class="n">InteropServices</span><span class="p">;</span>

<span class="n">public</span> <span class="n">class</span> <span class="n">NativeBinding</span> <span class="o">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>

  <span class="c1">// Use this for initialization</span>
  <span class="kt">void</span> <span class="n">Start</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">}</span>

  <span class="c1">// Update is called once per frame</span>
  <span class="kt">void</span> <span class="n">Update</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">}</span>

  <span class="p">[</span><span class="n">DllImport</span> <span class="p">(</span><span class="s">&quot;__Internal&quot;</span><span class="p">)]</span>
  <span class="n">private</span> <span class="k">static</span> <span class="k">extern</span> <span class="kt">float</span> <span class="n">FooPluginFunction</span><span class="p">();</span>

  <span class="kt">void</span> <span class="nf">Awake</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">print</span> <span class="p">(</span><span class="n">FooPluginFunction</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>
<p>注意<code>using System.Runtime.InteropServices;</code>必不可少.<br />
然后, 当然将这个组件绑定到某个对象上也是必不可少, 不然<code>Awake</code>永远不会运行.  </p>
<p>4.在最新版的Unity中, 多了个很方便的特性.  当把原生代码放在Assets/Plugins/iOS中时(不允许再有子目录了), 在生成XCode工程的后, 代码都会放在<code>Libraries</code>中, 解决了以前生成工程后还需要自己添加代码的问题.  </p>
<p>编译运行后可以看到会输出<code>10.1</code>(一定能够要真机运行).</p>
<h1 id="unityscriptnative-to-managed">原生代码调用Unity的Script代码(native-to-managed)</h1>
<p>通过<code>UnitySendMessage</code>函数, 有个问题是似乎没法获得返回值.  还是接上个例子, 通过反过来调用的方式, 输出10.1后再输出一个10.2.  </p>
<div class="codehilite">
<pre><span class="c1">// .mm</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
  <span class="kt">float</span> <span class="n">FooPluginFunction</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">UnitySendMessage</span><span class="p">(</span><span class="s">&quot;Main Camera&quot;</span><span class="p">,</span> <span class="s">&quot;Print&quot;</span><span class="p">,</span> <span class="s">&quot;10.2&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mf">10.1f</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>
<p>上述代码就能直接调用<code>Main Camera</code>的<code>Print</code>函数.  </p>
<div class="codehilite">
<pre><span class="kt">void</span> <span class="nf">Print</span><span class="p">(</span><span class="n">string</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span> <span class="p">(</span><span class="n">message</span><span class="p">);</span>
<span class="p">}</span>
</pre>
</div>
<p>需要注意的是, 上述调用并不是同步的,, 所以能看到, 虽然上述代码是先调用的<code>UnitySendMessage</code>函数, 但是实际上, <code>10.2</code>字符串输出的会晚于<code>10.1</code>, 官方文档说<code>UnitySendMessage</code>会在下一帧被调用.<br />
可以看到这个接口带来的问题不仅不能返回值, 同时传递的参数还只能是字符串.  </p>
<h1 id="unitysendmessage">UnitySendMessage的一个研究</h1>
<p>我看的这个接口的第一反应是, 这个<code>UnitySendMessage</code>在Unity中用的是<code>SendMessage</code>实现的, 因为一个Unity对象绑定的组件可能有多个, 也可能有多个同样命名的函数, 此时会同时调用所有符合条件的函数, 这体现了Unity整体设计的动态性.  事实检验, 果真如此.  </p>
<h1 id="uitry-to-use-native-ui-in-unity">显示原生UI的尝试(Try to use Native UI in Unity)</h1>
<p>这是本文真正想做的事情. 在互联网上搜了一圈, 问这个问题的多, 但是知道回答的太少.  我想可能需要我写完本文后给他们一一回答... 是不是有些托大啊-_-!  </p>
<h2 id="ui_2">UI显示</h2>
<p>首先, 讲前面的知识用上, 并且取个厚道的名字:</p>
<div class="codehilite">
<pre><span class="c1">// .h</span>
<span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>

<span class="c1">// .mm</span>
<span class="cp">#import &quot;NativeBinding.h&quot;</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">_ActivateUI</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">_DeactivateUI</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>
<p>然后, 添加一个我们用于显示UI的类.  我这里直接用XCode生成了.  其他代码都不变, 增加一个单件的接口和实现. 代码就很简单了.   </p>
<div class="codehilite">
<pre><span class="c1">// .h</span>
<span class="cp">#import &lt;UIKit/UIKit.h&gt;</span>

<span class="k">@interface</span> <span class="nc">RootViewController</span> : <span class="nc">UIViewController</span>

<span class="k">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span> <span class="nf">sharedManager</span><span class="p">;</span>

<span class="k">@end</span>

<span class="c1">// .mm</span>
<span class="cp">#import &quot;RootViewController.h&quot;</span>

<span class="k">static</span> <span class="n">RootViewController</span> <span class="o">*</span><span class="n">sharedRootViewController</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>

<span class="k">@interface</span> <span class="nc">RootViewController</span> <span class="p">()</span>

<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">RootViewController</span>

<span class="k">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span> <span class="nf">sharedManager</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sharedRootViewController</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sharedRootViewController</span> <span class="o">=</span> <span class="p">[[</span><span class="n">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithNibName</span><span class="o">:</span><span class="nb">nil</span> <span class="n">bundle</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">sharedRootViewController</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithNibName:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">nibNameOrNil</span> <span class="nf">bundle:</span><span class="p">(</span><span class="n">NSBundle</span> <span class="o">*</span><span class="p">)</span><span class="nv">nibBundleOrNil</span>
<span class="p">{</span>
    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">initWithNibName</span><span class="o">:</span><span class="n">nibNameOrNil</span> <span class="n">bundle</span><span class="o">:</span><span class="n">nibBundleOrNil</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Custom initialization</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
    <span class="c1">// Do any additional setup after loading the view from its nib.</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">didReceiveMemoryWarning</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">super</span> <span class="n">didReceiveMemoryWarning</span><span class="p">];</span>
    <span class="c1">// Dispose of any resources that can be recreated.</span>
<span class="p">}</span>

<span class="k">@end</span>
</pre>
</div>
<p>然后把<code>RootViewController</code>的显示代码加入到Script调用中去, 怎么加呢? 最关键的代码是在:  </p>
<div class="codehilite">
<pre><span class="n">UIWindow</span> <span class="o">*</span><span class="n">window</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="n">keyWindow</span><span class="p">];</span>
</pre>
</div>
<p>不需要琢磨OpenGL的那个View怎么改了, 取得<code>keyWindow</code>就行了.  然后就是<code>addSubView</code>的事情而已了.<br />
完整的代码如下:  </p>
<div class="codehilite">
<pre><span class="c1">// .mm</span>
<span class="cp">#import &quot;NativeBinding.h&quot;</span>
<span class="cp">#import &quot;RootViewController.h&quot;</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>

  <span class="kt">void</span> <span class="n">_ActivateUI</span><span class="p">()</span> <span class="p">{</span>

    <span class="c1">//Get the applications UIWindow</span>
    <span class="n">UIWindow</span> <span class="o">*</span><span class="n">window</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="n">keyWindow</span><span class="p">];</span>

    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;window = %@&quot;</span><span class="p">,</span> <span class="n">window</span><span class="p">);</span>

    <span class="c1">//Create the RootViewController from a XIB file.</span>
    <span class="n">RootViewController</span> <span class="o">*</span><span class="n">rootViewController</span> <span class="o">=</span> <span class="p">[</span><span class="n">RootViewController</span> <span class="n">sharedManager</span><span class="p">];</span>

    <span class="c1">//Add the RootViewController view to the main window.</span>
    <span class="p">[</span><span class="n">window</span> <span class="n">addSubview</span><span class="o">:</span> <span class="n">rootViewController</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">_DeactivateUI</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">([</span><span class="n">RootViewController</span> <span class="n">sharedManager</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Code ~~</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="p">}</span>
</pre>
</div>
<p>此时只要在Unity中直接调用_ActiveUI就OK了.  </p>
<div class="codehilite">
<pre><span class="n">using</span> <span class="n">UnityEngine</span><span class="p">;</span>
<span class="n">using</span> <span class="n">System</span><span class="p">.</span><span class="n">Runtime</span><span class="p">.</span><span class="n">InteropServices</span><span class="p">;</span>

<span class="n">public</span> <span class="n">class</span> <span class="n">NativeBinding</span> <span class="o">:</span> <span class="n">MonoBehaviour</span> <span class="p">{</span>

  <span class="kt">void</span> <span class="n">Start</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">ActivateUI</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="p">[</span><span class="n">DllImport</span> <span class="p">(</span><span class="s">&quot;__Internal&quot;</span><span class="p">)]</span>
  <span class="n">private</span> <span class="k">static</span> <span class="k">extern</span> <span class="kt">void</span> <span class="n">_ActivateUI</span><span class="p">();</span>

  <span class="n">public</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">ActivateUI</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">print</span> <span class="p">(</span><span class="s">&quot;ActivateUI&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Application</span><span class="p">.</span><span class="n">platform</span> <span class="o">==</span> <span class="n">RuntimePlatform</span><span class="p">.</span><span class="n">IPhonePlayer</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">_ActivateUI</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="p">[</span><span class="n">DllImport</span> <span class="p">(</span><span class="s">&quot;__Internal&quot;</span><span class="p">)]</span>
  <span class="n">private</span> <span class="k">static</span> <span class="k">extern</span> <span class="kt">void</span> <span class="n">_DeactivateUI</span><span class="p">();</span>

  <span class="n">public</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">DeactivateUI</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">print</span> <span class="p">(</span><span class="s">&quot;ActivateUI&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Application</span><span class="p">.</span><span class="n">platform</span> <span class="o">==</span> <span class="n">RuntimePlatform</span><span class="p">.</span><span class="n">IPhonePlayer</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">_DeactivateUI</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>
<p>这里比前面的代码稍微正式一点, 判断了一下平台, 其他的内容其实已经讲过了.  此时运行程序(还是在真机啊~~~), 然后就能看到一个白屏了.  为了稍微有些内容, 在Interface builder中随意添加控件吧.  一顿乱摆之后:  </p>
<p><img alt="Unity中显示原生UI" src="http://b.hiphotos.bdimg.com/album/w%3D1600%3Bq%3D90/sign=9640f0849a504fc2a25fb403d5eddc60/cefc1e178a82b901f3febfbf728da9773812efef.jpg" />  </p>
<h2 id="ui-unity">UI + Unity</h2>
<p>这个是第二个难点了, 目前的实现方式有个很大很大的问题, Unity的View全都挡住了, Development编译时右下角那行字都没有了.  这个根本没法用嘛.<br />
刚开始我还考虑是不是通过分离控件, 即通过将控件的尺寸调整到合适大小, 合适位置, 直接加到keyWindow上去, 后来发现其实没有这个必要, 直接把View的background调整为透明即可... 这个真是比我想象的要简单太多...<br />
另外, 假如还想更像app呢, 可以在工程配置里面把status bar弄出来.(在Unity生成的工程中, status bar默认隐藏了.)<br />
下面是显示效果, 为了展示Unity的场景, 我按照惯例显示了一个3D的Hello World, 并且给了一个打了动态光源的球. enjoy it!<br />
<img alt="Unity中混合显示原生UI和Unity场景" src="http://d.hiphotos.bdimg.com/album/w%3D1600%3Bq%3D90/sign=203e067ed462853592e0d627a0df4db7/8b82b9014a90f603c8e3e0cb3812b31bb151edef.jpg" /></p>
<h1 id="_2">总结</h1>
<p>其实到此为止, 想要实现的功能基本都能实现了, 剩下的也就是一些细节了.  但是, Unity的开发团队都不太推荐这种方式, 同样的, 我也不推荐大家使用... 使用后才能知道到底有多痛苦, 特别是非常非常非常非常漫长的编译过程...</p>
<h1 id="_3">参考</h1>
<p>Gregg的<em>An Experiment with iPhone Native UI and Unity 3 Pro</em>给了我很大的启发.  不知道为什么, Gregg自己把他博客上的文章删掉了-_#  </p>
<div style="text-align:right">
  writen&nbsp;by <a href="http://www.jtianling.com" target="_blank">九天雁翎(JTianLing) -- www.jtianling.com</a>
</div>
