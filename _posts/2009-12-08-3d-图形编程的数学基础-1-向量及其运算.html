---
layout: post
title: 3D 图形编程的数学基础(1) 向量及其运算
categories:
- "图形技术"
tags:
- "向量"
- "数学"
status: publish
type: post
published: true
meta:
  ratings_users: '0'
  ratings_score: '0'
  ratings_average: '0'
  views: '17'
author:
  login: jtianling
  email: jtianling@gmail.com
  display_name: jtianling
  first_name: ''
  last_name: ''
---

<p style="padding-bottom: 0px; margin: 1em 0px 0.5em; padding-left: 0px; padding-right: 0px; padding-top: 0px" align="right"><b><a style="color: rgb(0,107,173); text-decoration: none" href="http://www.jtianling.com">write by 九天雁翎(JTianLing) -- www.jtianling.com</a></b><b></b><b><u></u></b></p>
<p style="padding-bottom: 0px; margin: 1em 0px 0.5em; padding-left: 0px; padding-right: 0px; padding-top: 0px" align="right"><a style="color: rgb(119,0,0); text-decoration: none" href="http://groups.google.com/group/jiutianfile/"><b>讨论新闻组及文件</b></a></p>
<div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:0767317B-992E-4b12-91E0-4F059A8CECA8:cf6fe57a-d6d3-42bf-90c8-71a0e01f8f62" class="wlWriterEditableSmartContent">Technorati 标签: <a href="http://technorati.com/tags/%e5%90%91%e9%87%8f" rel="tag">向量</a>,<a href="http://technorati.com/tags/3D" rel="tag">3D</a>,<a href="http://technorati.com/tags/%e5%9d%90%e6%a0%87%e7%b3%bb" rel="tag">坐标系</a>,<a href="http://technorati.com/tags/%e8%a7%84%e8%8c%83%e5%8c%96" rel="tag">规范化</a>,<a href="http://technorati.com/tags/%e7%82%b9%e7%a7%af" rel="tag">点积</a>,<a href="http://technorati.com/tags/%e5%8f%89%e7%a7%af" rel="tag">叉积</a></div>
<h2>&#160;</h2>
<h2>说明</h2>
<p>因为大学时在高等数学课程中学习过线性代数相关的内容，所以学习3D编程的时候这一段事实上是跳过去了，学习到某些内容的时候觉得很郁闷，（4，5年没有用了，难免忘掉）最后常常依靠高级API完成，但是事实上这些高级API的算法具体实现啥的基本看不懂，于是还是决定回来好好的将基础部分弄明白，当然，首先是数学部分。为了更好的达到直观的效果，还有在复杂矩阵运算的时候验证运算结果，将引入freemat或者scilab（5.1.1）或者GNU Octave(3.2.3)的使用，将此三个软件作为matlab的替代品来使用。不能用庞大的matlab也是种解脱，默认使用freemat,不行的时候考虑其他替代。具体牵涉到计算的时尽量实现DirectX与Irrlicht两个版本，也会参考部分源代码。（主要用于看看公式用C/C++的实现）基本上，我希望能以概念的讲解为主，最好是直观的讲解。 </p>
<h3>&#160;</h3>
<h2>向量</h2>
<p>只用大小就能表示的量叫数量，比如温度，质量等。既需要用大小表示，同时还要指明方向的量叫向量，比如位移，速度等。几何学中，我们用有向线段来表示向量。有两个变量可以确定一个向量,即向量的长度和向量的方向。量与位置无关，有相同长度和方向的两个向量是相等的。在irrlicht中有专门的类vector2d,vector3d分别来表示2维的，3维的向量。在DirectX中用于表示向量的是结构D3DXVECTOR2，D3DXVECTOR3,D3DXVECTOR4。 </p>
<p>&#160; </p>
<h2>左右手坐标系</h2>
<p>一图胜前言，不懂怎么用手扭曲的去比划的看看图，就明白啥是左手，啥是右手坐标系了。在OpenGL中使用的是右手坐标系，DirectX,Irrlicht中使用的是左手坐标系。（图片来自于网络） </p>
<p><a href="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_image_2_633958280582656250.png"><img style="border-right-width: 0px; display: block; float: none; border-top-width: 0px; border-bottom-width: 0px; margin-left: auto; border-left-width: 0px; margin-right: auto" title="image" border="0" alt="image" src="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_image_thumb_633958280585000000.png" width="364" height="242" /></a> </p>
<h2>向量的模</h2>
<p>向量的大小（或长度）称为向量的模，向量a的模记为||a||。下面以3维的向量（3D中用的最多）为例：<a href="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_abc2_html_8d5f713_2.gif"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; margin-left: 0px; border-left-width: 0px; margin-right: 0px" title="abc2_html_8d5f713" border="0" alt="abc2_html_8d5f713" src="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_abc2_html_8d5f713_thumb.gif" width="155" height="31" /></a> </p>
<p>在irrlicht中获取向量模的函数是vector3d的成员函数</p>
<pre class="code"><span style="color: green">//! Get length of the vector.
</span><span style="color: #050005">T getLength</span>() <span style="color: blue">const </span>{ <span style="color: blue">return </span><span style="color: #050005">core</span>::<span style="color: #050005">squareroot</span>( <span style="color: #050005">X</span>*<span style="color: #050005">X </span>+ <span style="color: #050005">Y</span>*<span style="color: #050005">Y </span>+ <span style="color: #050005">Z</span>*<span style="color: #050005">Z </span>); }

<span style="color: green">//! Get squared length of the vector.
/** This is useful because it is much faster than getLength().
/return Squared length of the vector. */
</span><span style="color: #050005">T getLengthSQ</span>() <span style="color: blue">const </span>{ <span style="color: blue">return </span><span style="color: #050005">X</span>*<span style="color: #050005">X </span>+ <span style="color: #050005">Y</span>*<span style="color: #050005">Y </span>+ <span style="color: #050005">Z</span>*<span style="color: #050005">Z</span>; }</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>可以看出公式的实现，其中getLengthSQ用于某些时候使用不开根号，直接使用平方值的方法来优化代码。 </p>
<p>DirectX中的实现差不多一样，只是使用的是C风格的接口没有使用C++的类而已。</p>
<pre class="code"><span style="color: #050005">D3DXINLINE FLOAT D3DXVec3Length
    </span>( <span style="color: #050005">CONST D3DXVECTOR3 </span>*<span style="color: #050005">pV </span>)
{
<span style="color: blue">#ifdef </span><span style="color: #050005">D3DX_DEBUG
    </span><span style="color: gray">if(!pV)
        return 0.0f;
</span><span style="color: blue">#endif

#ifdef </span><span style="color: #050005">__cplusplus
    </span><span style="color: blue">return </span><span style="color: #050005">sqrtf</span>(<span style="color: #050005">pV</span>-&gt;<span style="color: #050005">x </span>* <span style="color: #050005">pV</span>-&gt;<span style="color: #050005">x </span>+ <span style="color: #050005">pV</span>-&gt;<span style="color: #050005">y </span>* <span style="color: #050005">pV</span>-&gt;<span style="color: #050005">y </span>+ <span style="color: #050005">pV</span>-&gt;<span style="color: #050005">z </span>* <span style="color: #050005">pV</span>-&gt;<span style="color: #050005">z</span>);
<span style="color: blue">#else
    </span><span style="color: gray">return (FLOAT) sqrt(pV-&gt;x * pV-&gt;x + pV-&gt;y * pV-&gt;y + pV-&gt;z * pV-&gt;z);
</span><span style="color: blue">#endif
</span>}

<span style="color: #050005">D3DXINLINE FLOAT D3DXVec3LengthSq
    </span>( <span style="color: #050005">CONST D3DXVECTOR3 </span>*<span style="color: #050005">pV </span>)
{
<span style="color: blue">#ifdef </span><span style="color: #050005">D3DX_DEBUG
    </span><span style="color: gray">if(!pV)
        return 0.0f;
</span><span style="color: blue">#endif

    return </span><span style="color: #050005">pV</span>-&gt;<span style="color: #050005">x </span>* <span style="color: #050005">pV</span>-&gt;<span style="color: #050005">x </span>+ <span style="color: #050005">pV</span>-&gt;<span style="color: #050005">y </span>* <span style="color: #050005">pV</span>-&gt;<span style="color: #050005">y </span>+ <span style="color: #050005">pV</span>-&gt;<span style="color: #050005">z </span>* <span style="color: #050005">pV</span>-&gt;<span style="color: #050005">z</span>;
}</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>FreeMat:</p>
<table border="1">
<tbody>
<tr>
<td>
<pre>--&gt; a = [1, 1, 1]
a =
 1 1 1
--&gt; b = norm(a)
b =
    1.7321
--&gt; </pre>
</td>
</tr>
</tbody>
</table>
<p>&#160; </p>
<h2>三维空间中两点的距离</h2>
<p>公式：<a href="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_abc4_html_m257962b9_2.gif"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; margin-left: 0px; border-left-width: 0px; margin-right: 0px" title="abc4_html_m257962b9" border="0" alt="abc4_html_m257962b9" src="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_abc4_html_m257962b9_thumb.gif" width="348" height="31" /></a> </p>
<p>Irrlicht的实现：</p>
<pre class="code"><span style="color: green">//! Get distance from another point.
/** Here, the vector is interpreted as point in 3 dimensional space. */
</span><span style="color: #050005">T getDistanceFrom</span>(<span style="color: blue">const </span><span style="color: #050005">vector3d</span>&lt;<span style="color: #050005">T</span>&gt;&amp; <span style="color: #050005">other</span>) <span style="color: blue">const
</span>{
    <span style="color: blue">return </span><span style="color: #050005">vector3d</span>&lt;<span style="color: #050005">T</span>&gt;(<span style="color: #050005">X </span>- <span style="color: #050005">other</span>.<span style="color: #050005">X</span>, <span style="color: #050005">Y </span>- <span style="color: #050005">other</span>.<span style="color: #050005">Y</span>, <span style="color: #050005">Z </span>- <span style="color: #050005">other</span>.<span style="color: #050005">Z</span>).<span style="color: #050005">getLength</span>();
}

<span style="color: green">//! Returns squared distance from another point.
/** Here, the vector is interpreted as point in 3 dimensional space. */
</span><span style="color: #050005">T getDistanceFromSQ</span>(<span style="color: blue">const </span><span style="color: #050005">vector3d</span>&lt;<span style="color: #050005">T</span>&gt;&amp; <span style="color: #050005">other</span>) <span style="color: blue">const
</span>{
    <span style="color: blue">return </span><span style="color: #050005">vector3d</span>&lt;<span style="color: #050005">T</span>&gt;(<span style="color: #050005">X </span>- <span style="color: #050005">other</span>.<span style="color: #050005">X</span>, <span style="color: #050005">Y </span>- <span style="color: #050005">other</span>.<span style="color: #050005">Y</span>, <span style="color: #050005">Z </span>- <span style="color: #050005">other</span>.<span style="color: #050005">Z</span>).<span style="color: #050005">getLengthSQ</span>();
}</pre>
<p><a href="http://11011.net/software/vspaste"></a>也有平方的SQ函数版本。</p>
<h4>&#160;</h4>
<h2>向量的规范化</h2>
<p>向量的规范化也称（归一化）就是使向量的模变为1，即变为单位向量。可以通过将向量都除以该向量的模来实现向量的规范化。规范化后的向量相当于与向量同方向的单位向量，可以用它表示向量的方向。由于方向的概念在3D编程中非常重要，所以此概念也很重要，单位向量有很多重要的性质，在表示物体表面的法线向量时用的更是频繁。 </p>
<p>基本的公式： <a href="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_clip_image002_2.gif"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; margin-left: 0px; border-left-width: 0px; margin-right: 0px" title="clip_image002" border="0" alt="clip_image002" src="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_clip_image002_thumb.gif" width="212" height="42" /></a></p>
<p align="left">在irrlicht中的调用函数及实现：</p>
<pre class="code"><span style="color: green">//! Normalizes the vector.
/** In case of the 0 vector the result is still 0, otherwise
the length of the vector will be 1.
/return Reference to this vector after normalization. */
</span><span style="color: #050005">vector3d</span>&lt;<span style="color: #050005">T</span>&gt;&amp; <span style="color: #050005">normalize</span>()
{
    <span style="color: #050005">f64 length </span>= (<span style="color: #050005">f32</span>)(<span style="color: #050005">X</span>*<span style="color: #050005">X </span>+ <span style="color: #050005">Y</span>*<span style="color: #050005">Y </span>+ <span style="color: #050005">Z</span>*<span style="color: #050005">Z</span>);
    <span style="color: blue">if </span>(<span style="color: #050005">core</span>::<span style="color: #050005">equals</span>(<span style="color: #050005">length</span>, 0.0)) <span style="color: green">// this check isn't an optimization but prevents getting NAN in the sqrt.
        </span><span style="color: blue">return </span>*<span style="color: blue">this</span>;
    <span style="color: #050005">length </span>= <span style="color: #050005">core</span>::<span style="color: #050005">reciprocal_squareroot </span>( (<span style="color: #050005">f64</span>) (<span style="color: #050005">X</span>*<span style="color: #050005">X </span>+ <span style="color: #050005">Y</span>*<span style="color: #050005">Y </span>+ <span style="color: #050005">Z</span>*<span style="color: #050005">Z</span>) );

    <span style="color: #050005">X </span>= (<span style="color: #050005">T</span>)(<span style="color: #050005">X </span>* <span style="color: #050005">length</span>);
    <span style="color: #050005">Y </span>= (<span style="color: #050005">T</span>)(<span style="color: #050005">Y </span>* <span style="color: #050005">length</span>);
    <span style="color: #050005">Z </span>= (<span style="color: #050005">T</span>)(<span style="color: #050005">Z </span>* <span style="color: #050005">length</span>);
    <span style="color: blue">return </span>*<span style="color: blue">this</span>;
}</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p align="left">上述代码中首先计算length以防其为0，然后直接计算1/||u||,（这样做的目的从代码实现上来看是因为SSE,Nviadia都有可以直接计算此值的能力） 然后再分别与各坐标值进行乘法运算。</p>
<p align="left">DirectX中的调用函数：(无实现可看）</p>
<pre class="code"><span style="color: #050005">D3DXVECTOR3</span>* <span style="color: #050005">WINAPI D3DXVec3Normalize
    </span>( <span style="color: #050005">D3DXVECTOR3 </span>*<span style="color: #050005">pOut</span>, <span style="color: #050005">CONST D3DXVECTOR3 </span>*<span style="color: #050005">pV </span>);</pre>
<pre class="code">&#160;</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<h2>向量的加减法，数乘</h2>
<p>太简单，不多描述，无非就是对应的加，减，乘罢了，几何意义讲一下，加法可以看做是两个向量综合后的方向，减法可以看做两个向量的差异方向（甚至可以用于追踪算法），数乘用于对向量进行缩放。</p>
<p>为了完整，这里从<a href="http://baike.baidu.com/view/77260.htm?fr=ala0" target="_blank">百度百科</a>拷贝一段资料过来：（以下都是2维的，放到3维也差不多）</p>
<p>设<b>a</b>=（x，y），<b>b</b>=(x'，y')。 </p>
<h3>1、向量的加法</h3>
<p>向量的加法满足平行四边形法则和三角形法则。 </p>
<p><b>AB</b>+<b>BC</b>=<b>AC</b>。 </p>
<p><b>a</b>+<b>b</b>=(x+x'，y+y')。 </p>
<p><b>a</b>+<b>0</b>=<b>0</b>+<b>a</b>=<b>a。</b> </p>
<p>向量加法的运算律： </p>
<p>交换律：<b>a</b>+<b>b</b>=<b>b</b>+<b>a；</b> </p>
<p>结合律：(<b>a</b>+<b>b</b>)+<b>c</b>=<b>a</b>+(<b>b</b>+<b>c</b>)。 </p>
<h3>2、向量的减法</h3>
<p>如果<b>a</b>、<b>b</b>是互为相反的向量，那么<b>a</b>=-<b>b</b>，<b>b</b>=-<b>a</b>，<b>a</b>+<b>b</b>=<b>0. 0</b>的反向量为<b>0</b></p>
<p><b>AB</b>-<b>AC</b>=<b>CB. </b>即“共同起点，指向被减” </p>
<p><b>a</b>=(x,y)<b> b</b>=(x',y') 则<b> a</b>-<b>b</b>=(x-x',y-y'). </p>
<h3>3、数乘向量</h3>
<p>实数λ和向量<b>a</b>的乘积是一个向量，记作λ<b>a</b>，且∣λa∣=∣λ∣<b>·</b>∣a∣。 </p>
<p>当λ＞0时，λ<b>a</b>与<b>a</b>同方向； </p>
<p>当λ＜0时，λ<b>a</b>与<b>a</b>反方向； </p>
<p>当λ=0时，λ<b>a</b>=<b>0</b>，方向任意。 </p>
<p>当<b>a</b>=<b>0</b>时，对于任意实数λ，都有λ<b>a</b>=<b>0</b>。 </p>
<p>注：按定义知，如果λ<b>a</b>=<b>0</b>，那么λ=0或<b>a</b>=<b>0</b>。 </p>
<p>实数λ叫做向量<b>a</b>的系数，乘数向量λ<b>a</b>的几何意义就是将表示向量<b>a</b>的有向线段伸长或压缩。 </p>
<p>当∣λ∣＞1时，表示向量a的有向线段在原方向（λ＞0）或反方向（λ＜0）上伸长为原来的∣λ∣倍； </p>
<p>当∣λ∣＜1时，表示向量a的有向线段在原方向（λ＞0）或反方向（λ＜0）上缩短为原来的∣λ∣倍。 </p>
<p>数与向量的乘法满足下面的运算律 </p>
<p>结合律：(λ<b>a</b>)<b>·b</b>=λ(<b>a</b>·<b>b)</b>=(<b>a</b>·λ<b>b</b>)。 </p>
<p>向量对于数的分配律（第一分配律）：(λ+μ)<b>a</b>=λ<b>a</b>+μ<b>a.</b> </p>
<p>数对于向量的分配律（第二分配律）：λ(<b>a</b>+<b>b</b>)=λ<b>a</b>+λ<b>b.</b> </p>
<p>数乘向量的消去律：① 如果实数λ≠0且λ<b>a=</b>λ<b>b</b>，那么<b>a=b</b>。② 如果<b>a</b>≠<b>0</b>且λ<b>a=</b>μ<b>a</b>，那么λ<b>=</b>μ。 </p>
<p>&#160;</p>
<h2>点积(dot product)又称数量积或内积</h2>
<p>v0 . v1 = v0.x*v1.x+v0.y*v1.y+v0.z*v1.z;<br />
  <br />所以向量的点积结果是一个数，而非向量。 </p>
<p>点积等于向量v0的长度乘以v1的长度，再乘以它们之间夹角的余弦，即|v0|*|v1|*cos(θ). </p>
<p>通过点积，可以计算两个向量之间的夹角。 </p>
<p>cos(θ)=v0.v1/|v0||v1|; </p>
<p>θ=Math.acos(v0.v1/|v0||v1|); </p>
<p>如果两个向量都是单位向量，上面的公式可以简化为 </p>
<p>θ=Math.acos(v0.v1); </p>
<p>V0.v1=0 =》两个向量互相垂直 </p>
<p>V0.v1&gt;0 =》两个向量的夹角小于90度 </p>
<p>V0.v1&lt;0 =》两个向量的夹角大于90度 </p>
<p>Irrlicht中的实现：（很简单的公式，很直白的实现）</p>
<pre class="code"><span style="color: green">//! Get the dot product with another vector.
</span><span style="color: #050005">T dotProduct</span>(<span style="color: blue">const </span><span style="color: #050005">vector3d</span>&lt;<span style="color: #050005">T</span>&gt;&amp; <span style="color: #050005">other</span>) <span style="color: blue">const
</span>{
    <span style="color: blue">return </span><span style="color: #050005">X</span>*<span style="color: #050005">other</span>.<span style="color: #050005">X </span>+ <span style="color: #050005">Y</span>*<span style="color: #050005">other</span>.<span style="color: #050005">Y </span>+ <span style="color: #050005">Z</span>*<span style="color: #050005">other</span>.<span style="color: #050005">Z</span>;
}</pre>
<p>DirectX中的实现：（很简单的公式，也是很直白的实现）</p>
<pre class="code"><span style="color: #050005">D3DXINLINE FLOAT D3DXVec3Dot
    </span>( <span style="color: #050005">CONST D3DXVECTOR3 </span>*<span style="color: #050005">pV1</span>, <span style="color: #050005">CONST D3DXVECTOR3 </span>*<span style="color: #050005">pV2 </span>)
{
<span style="color: blue">#ifdef </span><span style="color: #050005">D3DX_DEBUG
    </span><span style="color: gray">if(!pV1 || !pV2)
        return 0.0f;
</span><span style="color: blue">#endif

    return </span><span style="color: #050005">pV1</span>-&gt;<span style="color: #050005">x </span>* <span style="color: #050005">pV2</span>-&gt;<span style="color: #050005">x </span>+ <span style="color: #050005">pV1</span>-&gt;<span style="color: #050005">y </span>* <span style="color: #050005">pV2</span>-&gt;<span style="color: #050005">y </span>+ <span style="color: #050005">pV1</span>-&gt;<span style="color: #050005">z </span>* <span style="color: #050005">pV2</span>-&gt;<span style="color: #050005">z</span>;
}</pre>
<pre class="code">&#160;</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<h2>叉积(cross product)：也称向量积</h2>
<p>叉积的结果是一个向量，该向量垂直于相乘的两个向量。 </p>
<p>公式：<a href="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_1b72d65e_2.gif"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; margin-left: 0px; border-left-width: 0px; margin-right: 0px" title="yyyy_html_1b72d65e" border="0" alt="yyyy_html_1b72d65e" src="http://p.blog.csdn.net/images/p_blog_csdn_net/vagrxie/555576/o_yyyy_html_1b72d65e_thumb.gif" width="385" height="21" /></a> </p>
<p>注意：叉积不满足交换律，反过来相乘得到的向量与原向量方向相反。<br />
  <br />左手坐标系可以通过左手法则来确定叉积返回的向量的方向，从第一个向量向第二个向量弯曲左手，这是拇指所指的方向就是求得的向量的方向。右手坐标系同样的，可以通过右手法则来确定叉积返回的向量的方向，从第一个向量向第二个向量弯曲右手，这是拇指所指的方向就是求得的向量的方向。因此，事实上叉积获得的向量总是垂直于原来两个向量所在的平面。 </p>
<p>如果两个向量方向相同或相反，叉积结果将是一个零向量。（即a//b) </p>
<p>叉乘的一个重要应用就是求三角形的法向量。 </p>
<h3>Irrlicht的实现：</h3>
<pre class="code"><span style="color: green">//! Calculates the cross product with another vector.
/** /param p Vector to multiply with.
/return Crossproduct of this vector with p. */
</span><span style="color: #050005">vector3d</span>&lt;<span style="color: #050005">T</span>&gt; <span style="color: #050005">crossProduct</span>(<span style="color: blue">const </span><span style="color: #050005">vector3d</span>&lt;<span style="color: #050005">T</span>&gt;&amp; <span style="color: #050005">p</span>) <span style="color: blue">const
</span>{
    <span style="color: blue">return </span><span style="color: #050005">vector3d</span>&lt;<span style="color: #050005">T</span>&gt;(<span style="color: #050005">Y </span>* <span style="color: #050005">p</span>.<span style="color: #050005">Z </span>- <span style="color: #050005">Z </span>* <span style="color: #050005">p</span>.<span style="color: #050005">Y</span>, <span style="color: #050005">Z </span>* <span style="color: #050005">p</span>.<span style="color: #050005">X </span>- <span style="color: #050005">X </span>* <span style="color: #050005">p</span>.<span style="color: #050005">Z</span>, <span style="color: #050005">X </span>* <span style="color: #050005">p</span>.<span style="color: #050005">Y </span>- <span style="color: #050005">Y </span>* <span style="color: #050005">p</span>.<span style="color: #050005">X</span>);
}</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p align="left">&#160;</p>
<h3>DirectX的实现：</h3>
<pre class="code"><span style="color: #050005">D3DXINLINE D3DXVECTOR3</span>* <span style="color: #050005">D3DXVec3Cross
    </span>( <span style="color: #050005">D3DXVECTOR3 </span>*<span style="color: #050005">pOut</span>, <span style="color: #050005">CONST D3DXVECTOR3 </span>*<span style="color: #050005">pV1</span>, <span style="color: #050005">CONST D3DXVECTOR3 </span>*<span style="color: #050005">pV2 </span>)
{
    <span style="color: #050005">D3DXVECTOR3 v</span>;

<span style="color: blue">#ifdef </span><span style="color: #050005">D3DX_DEBUG
    </span><span style="color: gray">if(!pOut || !pV1 || !pV2)
        return NULL;
</span><span style="color: blue">#endif

    </span><span style="color: #050005">v</span>.<span style="color: #050005">x </span>= <span style="color: #050005">pV1</span>-&gt;<span style="color: #050005">y </span>* <span style="color: #050005">pV2</span>-&gt;<span style="color: #050005">z </span>- <span style="color: #050005">pV1</span>-&gt;<span style="color: #050005">z </span>* <span style="color: #050005">pV2</span>-&gt;<span style="color: #050005">y</span>;
    <span style="color: #050005">v</span>.<span style="color: #050005">y </span>= <span style="color: #050005">pV1</span>-&gt;<span style="color: #050005">z </span>* <span style="color: #050005">pV2</span>-&gt;<span style="color: #050005">x </span>- <span style="color: #050005">pV1</span>-&gt;<span style="color: #050005">x </span>* <span style="color: #050005">pV2</span>-&gt;<span style="color: #050005">z</span>;
    <span style="color: #050005">v</span>.<span style="color: #050005">z </span>= <span style="color: #050005">pV1</span>-&gt;<span style="color: #050005">x </span>* <span style="color: #050005">pV2</span>-&gt;<span style="color: #050005">y </span>- <span style="color: #050005">pV1</span>-&gt;<span style="color: #050005">y </span>* <span style="color: #050005">pV2</span>-&gt;<span style="color: #050005">x</span>;

    *<span style="color: #050005">pOut </span>= <span style="color: #050005">v</span>;
    <span style="color: blue">return </span><span style="color: #050005">pOut</span>;
}</pre>
<p><a href="http://11011.net/software/vspaste"></a>基本上也就是按公式来了。 </p>
<p align="left">作为最后一个概念，这里用代码实践一下。</p>
<p align="left">求a=(2,2,1)和b=(4,5,3)的叉积。</p>
<h3>freemat:</h3>
<table border="1">
<tbody>
<tr>
<td>
<pre>--&gt; a = [2,2,1]
a =
 2 2 1
--&gt; b = [4,5,3]
b =
 4 5 3
--&gt; c = cross(a,b)
c =
  1 -2  2
--&gt; </pre>
</td>
</tr>
</tbody>
</table>
<h3>Irrlicht:</h3>
<pre class="code"><span style="color: blue">#include </span><span style="color: #a31515">&lt;stdio.h&gt;
</span><span style="color: blue">#include </span><span style="color: #a31515">&lt;irrlicht.h&gt;
</span><span style="color: blue">using namespace </span><span style="color: #050005">irr</span>::<span style="color: #050005">core</span>;


<span style="color: blue">int </span><span style="color: #050005">_tmain</span>(<span style="color: blue">int </span><span style="color: #050005">argc</span>, <span style="color: #050005">_TCHAR</span>* <span style="color: #050005">argv</span>[])
{
    <span style="color: #050005">vector3df a</span>(2.0f, 2.0f, 1.0f);
    <span style="color: #050005">vector3df b</span>(4.0f, 5.0f, 3.0f);

    <span style="color: #050005">vector3df c </span>= <span style="color: #050005">a</span>.<span style="color: #050005">crossProduct</span>(<span style="color: #050005">b</span>);

    <span style="color: #050005">printf</span>(<span style="color: #a31515">&quot;c = (%f, %f, %f)&quot;</span>, <span style="color: #050005">c</span>.<span style="color: #050005">X</span>, <span style="color: #050005">c</span>.<span style="color: #050005">Y</span>, <span style="color: #050005">c</span>.<span style="color: #050005">Z</span>);


    <span style="color: blue">return </span>0;
}</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p align="left">&#160;</p>
<p align="left">输出：</p>
<p align="left">c = (1.000000, -2.000000, 2.000000)</p>
<h3>DirectX:</h3>
<pre class="code"><span style="color: blue">#include </span><span style="color: #a31515">&lt;stdio.h&gt;
</span><span style="color: blue">#include </span><span style="color: #a31515">&lt;d3dx9.h&gt;

</span><span style="color: blue">int </span><span style="color: #050005">_tmain</span>(<span style="color: blue">int </span><span style="color: #050005">argc</span>, <span style="color: #050005">_TCHAR</span>* <span style="color: #050005">argv</span>[])
{
    <span style="color: #050005">D3DXVECTOR3 a</span>(2.0f, 2.0f, 1.0f);
    <span style="color: #050005">D3DXVECTOR3 b</span>(4.0f, 5.0f, 3.0f);

    <span style="color: #050005">D3DXVECTOR3 c</span>;
    <span style="color: #050005">D3DXVec3Cross</span>(&amp;<span style="color: #050005">c</span>, &amp;<span style="color: #050005">a</span>, &amp;<span style="color: #050005">b</span>);

    <span style="color: #050005">printf</span>(<span style="color: #a31515">&quot;c = (%f, %f, %f)&quot;</span>, <span style="color: #050005">c</span>.<span style="color: #050005">x</span>, <span style="color: #050005">c</span>.<span style="color: #050005">y</span>, <span style="color: #050005">c</span>.<span style="color: #050005">z</span>);

    <span style="color: blue">return </span>0;
}</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>输出： </p>
<p>c = (1.000000, -2.000000, 2.000000) </p>
<p>这里给出个较为完整的例子是希望大家了解一下Irrlicht这种C++风格的接口及DirectX的C风格接口使用上的不同，这里就不对两种风格的接口提出更多评论了，以防引起口水战。 </p>
<p>下一篇预计讲矩阵的计算</p>
<p>参考资料：</p>
<p>1.《DirectX 9.0 3D游戏开发编程基础》 ，（美）Frank D.Luna著，段菲译，清华大学出版社</p>
<p>2.《大学数学》湖南大学数学与计量经济学院组编，高等教育出版社</p>
<p>3.百度百科及wikipedia</p>
<p>&#160; </p>
<p align="right">原创文章作者保留版权 转载请注明原作者 并给出链接<b></b></p>
<p align="right"><b><a href="http://www.jtianling.com">write by 九天雁翎(JTianLing) -- www.jtianling.com</a></b></p>
<p><script type="text/javascript">var sitebro_tracker_atc_kw = {u:'http://www.sitebot.com.cn/754892/',w:'NzU0ODky',bt:'#804000',bg:'#EEEEDD',fs:1,ca:'#770000',bh:'#f4f4c6',cp:'',l:10,s:1,lang:'zh_CN'};</script><script type="text/javascript" src="http://www.sitebot.com.cn/js/widget_track2/tracker_atc_kw.js"></script><script type="text/javascript">&lt;!--<br />
var sitebro_tracker_atc={u:'http://www.sitebot.com.cn/754892/',w:'NzU0ODky',bt:'#804000',bg:'#EEEEDD',cf:'#ffffff',ca:'#770000',bh:'#DDDDCC',cp:'%E6%9C%AC%E7%AB%99%E7%83%AD%E9%97%A8%E6%96%87%E7%AB%A0',l:10,s:0,lang:'zh_CN'};<br />
// --&gt;</script><script src="http://www.sitebot.com.cn/js/widget_track2/tracker_atc.js" type="text/javascript"></script></p>
