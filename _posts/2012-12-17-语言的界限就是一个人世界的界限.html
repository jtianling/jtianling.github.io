---
layout: post
title: "语言的界限就是一个人世界的界限"
categories:
- "通用编程技术"
tags:
- C++
- JAVA
- Python
- Ruby
- Ruby on Rails
- vim
status: publish
type: post
published: true
meta:
  views: '155'
  mkd_text: "$TOC$\n>\t语言的界限就是一个人世界的界限\t\n>\t-- 维特根斯坦\n\n# Ruby on Rails的世界\n很多人会告诉你,
    学习不同编程语言能够让你看到新的世界, 改变你思考的方式, 在*程序员修炼之道*中甚至会建议'每年至少学习一门新语言', 也有Peter Norvig在[*十年学会编程*](http://daiyuwen.freeshell.org/gb/misc/21-days-cn.html)中提出的那样,
    学会至少半打语言.  我是比较赞同这种观点的.  \n\n我是从C++开始学习编程的, 大部分工作时间也是在用C++, 但是常常会受到一些人的'蛊惑', 看到一些鼓吹某个语言好的文章后,
    就会忍不住的学习这个语言, 然后理解一下为啥好.  再加上工作本身的需要, 已经学习了一堆的语言了.  但是, 没有哪一次像这次学Ruby on Rails感受更多.
    \ 一般提到学习新语言的时候都会说离现在的知识越远越好, 其实本质上就是需要你接触到一个完全不同的环境, 进入一个完全不同的领域.但是我以前没有太理解, 语言学了一大堆,
    但是其实一直在做游戏, 学个新语言吧还都去找找这个语言写的游戏引擎(或者用这个脚本语言驱动的游戏引擎)弄来弄去也就那么几个概念, 甚至于用的工具变来变去都差不太多.
    \ 当然, 在以前出现这样的情况, 部分原因是我刻意的, 为了专注于游戏.  这一次静下心来, 好好的把Ruby on Rails学了过来, 虽然还并不是做纯粹的网页,
    而是做一个客户端的后端, 但是感觉已经和写游戏完全不一样了.  其中最大的感受在于网页开发领域的自动化程度之高, 让游戏开发简直就像是还停留在上个世纪, 让我都有些怀疑自己是不是还没有接触过真正牛的游戏开发.
    \ \n\n特别是[Gem](http://rubygems.org/)和[Bundle](http://gembundler.com/). Gem这个Ruby的包管理系统真是太方便了,
    发现一个新的库? 简单的`gem install xxx`就行了, 同时还会自动下载依赖的所有其他库. 要加到工程里面去, 在Gemfile里面添加一行`Gem
    'xxx'`, `Bundle install`就行了. 联想一下C++里面怎么在VS里面加一个新的库删一个库或者库更新, 我都要哭了.  在C++里面,
    配置和加载一个大点的库都可以单独写篇博客了, 比如Boost, Qt啥的, 我还真[写过](http://www.jtianling.com/articles/1002.html)...
    \ 同时, 真正把Ruby当作一个平台来管理的, 还有配套的[Gem网站](http://rubygems.org/)和[ruby-toolbox](http://www.ruby-toolbox.com),
    当有多个类似的Gem不知道用哪一个的时候, 看看这个网站上的下载量, 你基本上就有得选择了. 在没有特殊要求的时候, 在开源的世界里面, 选择最热门的, 一定是够用的选择.
    \ 不会是最差的, 虽然也不一定是最好的.  我用过类似yum, apt, brew等包管理, 但是还没有真正在某一个开发语言里面见识过.(真是惭愧)  \n\n#
    Ruby on Rails的世界以外\n我的反应是, 其他的环境难道就没有类似Gem的包管理系统吗?  让我惭愧的是, 原来真的有, 只是我从来都不知道而已,
    Python的[pip](http://pypi.python.org/pypi/pip), Objective-C的[cocoapods](http://cocoapods.org/),
    最让我惊喜的是, 还有类似Bundle思想的Vim的插件管理[Vim Bundle](https://github.com/benmills/vim-bundle),
    从这个名字就知道这个哥们是从哪学来的这种自动化管理思想了.  值得思考的是, 为什么我一直不知道它们的存在, 仅仅是因为我孤陋寡闻吗?  我几乎是与学习Ruby同时就知道了Gem,
    因为几乎每个第三方库都会告诉你用Gem来安装, 而其他语言不是...  这就是生态系统的差异.  BTW: Gem从Ruby1.9开始, 就已经内置在Ruby了.\n\n#
    C++的世界?\nObjC都有了cocoapods, 那C++呢?  C++因为本身跨平台的负担, 各类库的编译方式各式各样, 再加上历史传承原因, 老旧并存,
    从原始的makefile, 到autoconf, 到稍微新一点的CMake, 甚至还有用ant的, 编译器也有VS, g++, llvm等几家了, 要做一个让第三方库能通用的包管理,
    就我的想法几乎是不可能的, 但是针对特定环境的, 比如针对Windows的VS, Linux/Unix的G++等, 还是有可能的.  有意思的是, 还真的有,
    虽然好像都不成熟. 找到一个所谓windows-package-manager, [Npackd](http://code.google.com/p/windows-package-manager/)好像能下载一些库,
    不可思议的是, 这些哥们竟然还特意开发了一个UI... 真是思维的差异啊... 难道大家都认为没有UI的东西在Windows上就不会有人用吗? 因为Windows那烂的不可用的shell吗?
    \ 支持VS的[NuGet](http://nuget.org/), 不过好像专门用于管理.Net, 悲哀.  在这个过程中, 我还发现了[Apache Maven](http://maven.apache.org/),
    一个Apache发起的用于JAVA的包管理工具.\n\n不用怀疑, 结果是很明显的, C++还没有一个稍微成熟点, 到可用地步的包管理工具, 不管是VS里面还是g++上,
    也是因为这样原因, 我在学习Python的时候, 甚至都没有考虑到去找类似的工具... 其实easy\\_install和pip的成熟度还是较高的, 但是从C++来的思维方式,
    限制了我, 这是我现在的真实感受.  回忆起开发的过程, 在VS中配置一个工程真的是一个痛苦的过程, 以至于没有一点经验还真干不了, 并且还容易出错, 格式,
    目录什么的要是乱了还影响后来的开发, 因为这个原因, 在我刚工作的时候, 即使是一个我自己从头开发的全新服务端程序,(我是从服务端开始开发的)都是我们主程配置好了工程,
    解决了一些自己库和第三方库的依赖问题后, 然后我再开始编码的. 而这个服务端的程序配置, 是全手动的, 为了简化, 是从一个我们自己做的模板上clone出来,
    然后再去做调整. 到我带团队的时候, 初期也都是自己配置工程, 直到比较后期了才敢让其他人来干这个活, 尽管我早就已经对他们的代码相当放心了. 回忆一下这个过程,
    就能知道这个过程有多么痛苦了.  不管C++本身有多少负担, 实际的开发过程相对于ROR来说, 的确是太原始了.  从以上的体验来说, 尽管C++被大家公认来说是一个非常难学难写好的语言,
    但其实正确配置第三方库和C++的工程甚至比写C++本身来说还要困难...-\\_-! 可能正是这个原因, C++库的开发社区有种反向的潮流, 那就是以自己库尽量少的依赖第三方库为优点,
    简单的来说, 你要依赖第三方库太多, 配置太麻烦, 根本就不会有人愿意用你的库... 而这个, 假如有个好的包管理, 根本就不应该是问题.  这在某种程度上其实也限制了社区的良性发展,
    每个库都带一堆的基础库算什么回事啊.  这个问题在C语言中似乎更加严重, 因为连STL都没有...\n\n# 最后的感叹\n想起以前一个经典的C++程序员与Python程序员之间的争论,
    当时还感叹中国人的吵架智慧, [见这里](http://www.jtianling.com/articles/1278.html), C++的使用者们(包括我)很多时候都把自己使用C++开发的效率低归结为C++语言本身为了效率所做的牺牲,
    即其本身的复杂性. 就如BS说的*'绝对复杂的问题需要相对复杂的工具来解决'*. 事实上, 还有一部分在于我们的开发环境, 包括上面提到的典型的项目配置过程,
    只是我们没有意识到而已.  \n\n# 列表\n这里是我整理的一些包管理软件列表:  \n\n* Ruby: [Gem](http://rubygems.org/)和[Bundle](http://gembundler.com/)
    \n* Python: [pip](http://pypi.python.org/pypi/pip)\n* Objective-C:  [cocoapods](http://cocoapods.org/)\n*
    Vim插件: [Vim Bundle](https://github.com/benmills/vim-bundle)\n* Lua: [LuaDist](http://luadist.org/)和[LuaRocks](http://luarocks.org/)\n*
    javascript: [cpm](https://github.com/kriszyp/cpm)和[jam](https://github.com/caolan/jam)\n*
    nodejs: [npm](https://npmjs.org/)\n* JAVA: [Maven](http://maven.apache.org/)\n*
    .Net: [NuGet](http://nuget.org/)\n* PHP: [PEAR](), [composer](https://github.com/composer/composer),
    [Maven for PHP](http://www.php-maven.org/)\n* Windows: [Npackd](http://code.google.com/p/windows-package-manager/)"
  _wp_old_slug: "%e5%af%bb%e6%89%be%e4%b8%80%e7%a7%8d%e4%bb%a5%e6%96%87%e6%9c%ac%e6%a0%bc%e5%bc%8f%e5%86%99%e5%8d%9a%e5%ae%a2%e7%9a%84%e5%8a%9e%e6%b3%95-2-2"
  _edit_last: '1'
  _aioseop_title: "语言的界限就是一个人世界的界限"
author:
  login: jtianling
  email: jtianling@gmail.com
  display_name: jtianling
  first_name: ''
  last_name: ''
---
<div class="toc">
<ul>
<li><a href="#ruby-on-rails">Ruby on Rails的世界</a></li>
<li><a href="#ruby-on-rails_1">Ruby on Rails的世界以外</a></li>
<li><a href="#c">C++的世界?</a></li>
<li><a href="#_1">最后的感叹</a></li>
<li><a href="#_2">列表</a></li>
</ul>
</div>
<blockquote>
<p>语言的界限就是一个人世界的界限<br />
  -- 维特根斯坦</p>
</blockquote>
<h1 id="ruby-on-rails">Ruby on Rails的世界</h1>
<p>很多人会告诉你, 学习不同编程语言能够让你看到新的世界, 改变你思考的方式, 在<em>程序员修炼之道</em>中甚至会建议'每年至少学习一门新语言', 也有Peter Norvig在<a href="http://daiyuwen.freeshell.org/gb/misc/21-days-cn.html"><em>十年学会编程</em></a>中提出的那样, 学会至少半打语言.  我是比较赞同这种观点的.  </p>
<p>我是从C++开始学习编程的, 大部分工作时间也是在用C++, 但是常常会受到一些人的'蛊惑', 看到一些鼓吹某个语言好的文章后, 就会忍不住的学习这个语言, 然后理解一下为啥好.  再加上工作本身的需要, 已经学习了一堆的语言了.  但是, 没有哪一次像这次学Ruby on Rails感受更多.  一般提到学习新语言的时候都会说离现在的知识越远越好, 其实本质上就是需要你接触到一个完全不同的环境, 进入一个完全不同的领域.但是我以前没有太理解, 语言学了一大堆, 但是其实一直在做游戏, 学个新语言吧还都去找找这个语言写的游戏引擎(或者用这个脚本语言驱动的游戏引擎)弄来弄去也就那么几个概念, 甚至于用的工具变来变去都差不太多.  当然, 在以前出现这样的情况, 部分原因是我刻意的, 为了专注于游戏.  这一次静下心来, 好好的把Ruby on Rails学了过来, 虽然还并不是做纯粹的网页, 而是做一个客户端的后端, 但是感觉已经和写游戏完全不一样了.  其中最大的感受在于网页开发领域的自动化程度之高, 让游戏开发简直就像是还停留在上个世纪, 让我都有些怀疑自己是不是还没有接触过真正牛的游戏开发.  </p>
<p>特别是<a href="http://rubygems.org/">Gem</a>和<a href="http://gembundler.com/">Bundle</a>. Gem这个Ruby的包管理系统真是太方便了, 发现一个新的库? 简单的<code>gem install xxx</code>就行了, 同时还会自动下载依赖的所有其他库. 要加到工程里面去, 在Gemfile里面添加一行<code>Gem 'xxx'</code>, <code>Bundle install</code>就行了. 联想一下C++里面怎么在VS里面加一个新的库删一个库或者库更新, 我都要哭了.  在C++里面, 配置和加载一个大点的库都可以单独写篇博客了, 比如Boost, Qt啥的, 我还真<a href="http://www.jtianling.com/articles/1002.html">写过</a>...  同时, 真正把Ruby当作一个平台来管理的, 还有配套的<a href="http://rubygems.org/">Gem网站</a>和<a href="http://www.ruby-toolbox.com">ruby-toolbox</a>, 当有多个类似的Gem不知道用哪一个的时候, 看看这个网站上的下载量, 你基本上就有得选择了. 在没有特殊要求的时候, 在开源的世界里面, 选择最热门的, 一定是够用的选择.  不会是最差的, 虽然也不一定是最好的.  我用过类似yum, apt, brew等包管理, 但是还没有真正在某一个开发语言里面见识过.(真是惭愧)  </p>
<h1 id="ruby-on-rails_1">Ruby on Rails的世界以外</h1>
<p>我的反应是, 其他的环境难道就没有类似Gem的包管理系统吗?  让我惭愧的是, 原来真的有, 只是我从来都不知道而已, Python的<a href="http://pypi.python.org/pypi/pip">pip</a>, Objective-C的<a href="http://cocoapods.org/">cocoapods</a>, 最让我惊喜的是, 还有类似Bundle思想的Vim的插件管理<a href="https://github.com/benmills/vim-bundle">Vim Bundle</a>, 从这个名字就知道这个哥们是从哪学来的这种自动化管理思想了.  值得思考的是, 为什么我一直不知道它们的存在, 仅仅是因为我孤陋寡闻吗?  我几乎是与学习Ruby同时就知道了Gem, 因为几乎每个第三方库都会告诉你用Gem来安装, 而其他语言不是...  这就是生态系统的差异.  BTW: Gem从Ruby1.9开始, 就已经内置在Ruby了.</p>
<h1 id="c">C++的世界?</h1>
<p>ObjC都有了cocoapods, 那C++呢?  C++因为本身跨平台的负担, 各类库的编译方式各式各样, 再加上历史传承原因, 老旧并存, 从原始的makefile, 到autoconf, 到稍微新一点的CMake, 甚至还有用ant的, 编译器也有VS, g++, llvm等几家了, 要做一个让第三方库能通用的包管理, 就我的想法几乎是不可能的, 但是针对特定环境的, 比如针对Windows的VS, Linux/Unix的G++等, 还是有可能的.  有意思的是, 还真的有, 虽然好像都不成熟. 找到一个所谓windows-package-manager, <a href="http://code.google.com/p/windows-package-manager/">Npackd</a>好像能下载一些库, 不可思议的是, 这些哥们竟然还特意开发了一个UI... 真是思维的差异啊... 难道大家都认为没有UI的东西在Windows上就不会有人用吗? 因为Windows那烂的不可用的shell吗?  支持VS的<a href="http://nuget.org/">NuGet</a>, 不过好像专门用于管理.Net, 悲哀.  在这个过程中, 我还发现了<a href="http://maven.apache.org/">Apache Maven</a>, 一个Apache发起的用于JAVA的包管理工具.</p>
<p>不用怀疑, 结果是很明显的, C++还没有一个稍微成熟点, 到可用地步的包管理工具, 不管是VS里面还是g++上, 也是因为这样原因, 我在学习Python的时候, 甚至都没有考虑到去找类似的工具... 其实easy_install和pip的成熟度还是较高的, 但是从C++来的思维方式, 限制了我, 这是我现在的真实感受.  回忆起开发的过程, 在VS中配置一个工程真的是一个痛苦的过程, 以至于没有一点经验还真干不了, 并且还容易出错, 格式, 目录什么的要是乱了还影响后来的开发, 因为这个原因, 在我刚工作的时候, 即使是一个我自己从头开发的全新服务端程序,(我是从服务端开始开发的)都是我们主程配置好了工程, 解决了一些自己库和第三方库的依赖问题后, 然后我再开始编码的. 而这个服务端的程序配置, 是全手动的, 为了简化, 是从一个我们自己做的模板上clone出来, 然后再去做调整. 到我带团队的时候, 初期也都是自己配置工程, 直到比较后期了才敢让其他人来干这个活, 尽管我早就已经对他们的代码相当放心了. 回忆一下这个过程, 就能知道这个过程有多么痛苦了.  不管C++本身有多少负担, 实际的开发过程相对于ROR来说, 的确是太原始了.  从以上的体验来说, 尽管C++被大家公认来说是一个非常难学难写好的语言, 但其实正确配置第三方库和C++的工程甚至比写C++本身来说还要困难...-_-! 可能正是这个原因, C++库的开发社区有种反向的潮流, 那就是以自己库尽量少的依赖第三方库为优点, 简单的来说, 你要依赖第三方库太多, 配置太麻烦, 根本就不会有人愿意用你的库... 而这个, 假如有个好的包管理, 根本就不应该是问题.  这在某种程度上其实也限制了社区的良性发展, 每个库都带一堆的基础库算什么回事啊.  这个问题在C语言中似乎更加严重, 因为连STL都没有...</p>
<h1 id="_1">最后的感叹</h1>
<p>想起以前一个经典的C++程序员与Python程序员之间的争论, 当时还感叹中国人的吵架智慧, <a href="http://www.jtianling.com/articles/1278.html">见这里</a>, C++的使用者们(包括我)很多时候都把自己使用C++开发的效率低归结为C++语言本身为了效率所做的牺牲, 即其本身的复杂性. 就如BS说的<em>'绝对复杂的问题需要相对复杂的工具来解决'</em>. 事实上, 还有一部分在于我们的开发环境, 包括上面提到的典型的项目配置过程, 只是我们没有意识到而已.  </p>
<h1 id="_2">列表</h1>
<p>这里是我整理的一些包管理软件列表:  </p>
<ul>
<li>Ruby: <a href="http://rubygems.org/">Gem</a>和<a href="http://gembundler.com/">Bundle</a> </li>
<li>Python: <a href="http://pypi.python.org/pypi/pip">pip</a></li>
<li>Objective-C:  <a href="http://cocoapods.org/">cocoapods</a></li>
<li>Vim插件: <a href="https://github.com/benmills/vim-bundle">Vim Bundle</a></li>
<li>Lua: <a href="http://luadist.org/">LuaDist</a>和<a href="http://luarocks.org/">LuaRocks</a></li>
<li>javascript: <a href="https://github.com/kriszyp/cpm">cpm</a>和<a href="https://github.com/caolan/jam">jam</a></li>
<li>nodejs: <a href="https://npmjs.org/">npm</a></li>
<li>JAVA: <a href="http://maven.apache.org/">Maven</a></li>
<li>.Net: <a href="http://nuget.org/">NuGet</a></li>
<li>PHP: <a href="">PEAR</a>, <a href="https://github.com/composer/composer">composer</a>, <a href="http://www.php-maven.org/">Maven for PHP</a></li>
<li>Windows: <a href="http://code.google.com/p/windows-package-manager/">Npackd</a></li>
</ul>
