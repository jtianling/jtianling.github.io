---
layout: post
title: "不远的将来 程序语言是怎样的"
categories:
- "随笔"
tags: []
status: publish
type: post
published: true
meta:
  ratings_users: '0'
  ratings_score: '0'
  ratings_average: '0'
  views: '26'
author:
  login: jtianling
  email: jtianling@gmail.com
  display_name: jtianling
  first_name: ''
  last_name: ''
---

<p style="margin:1em 0px 0.5em;text-align:right"><b><a href="http://www.jtianling.com" style="color:#006bad;text-decoration:none">write by 九天雁翎(JTianLing) -- www.jtianling.com</a></b></p>
<p style="margin:1em 0px 0.5em;text-align:right"><a href="http://groups.google.com/group/jiutianfile/" style="color:#770000;text-decoration:none"><b>讨论新闻组及文件</b></a></p>
<p>其实很久就看到Bruce Eckel的文章了《<span class="ts"><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=284730" id="v6.d" title="Programming in the Mid-Future">Programming in the Mid-Future</a></span>》，原文发表于2010-3-10日.作为一个经常被自己无聊的求知欲所控制的程序员,我利用工作或者业余时间学习了N多种语言,也常常在想,到底怎么样的语言才是我们需要的,真的想要的,是能让(绝)大部分程序员所能接受的,公认的好语言,而不是一提到某某语言,就必定引发一场无休止的口水战呢?<br />Bruce Eckel提出了一些他的看法,虽然他不仅讲述了关于程序语言的内容,而是涵盖了程序设计的各个方面,但是,很显然,程序设计再多方面,主要的内容还是在程序设计语言上面. 在这里,大牛面前,我发表太多言论就类似班门弄斧了,这里先摘录一下原文的小标题及核心内容.<br />在Bruce Eckel心中,不远的将来 程序语言是这样的:
<p>1.极端动态(Extremely dynamic)</p>
<p>有越来越多的问题是静态语言解决不了的,所以,程序语言将向越来越动态的方向发展.</p>
<p></p>
<p>2.极其简单的并行(Stupidly parallel objects)</p>
<p>对象将管理他们自己的进程,就算不知道啥叫并行编程,也能无误的使用.</p>
<p></p>
<p>3.无盘持久化环境(Persistent diskless environment)</p>
<p>你将创建对象并随时使用它们,而不用关心它们在哪里,对象将在必要的时候包含必要的数据.</p>
<p></p>
<p>4.本地开发和云部署开发一致(Transparency between local and cloud)</p>
<p align="left">程序员将不用考虑这些问题,它们将自动化.</p>
<p align="left"></p>
<p align="left">5.自动覆盖测试<a id="swarm-testing" name="swarm-testing"></a>(Swarm testing)</p>
<p align="left">将来的测试要更快,更周密,更自动化,为测试所写的代码也要少的多.</p>
<p align="left"></p>
<p align="left">6.代码安全测试(Security via suspicious systems)</p>
<p align="left">将来的测试不仅包含现在普通意义上的测试,逻辑测试,安全测试也将存在.</p>
<p align="left"></p>
<p align="left">7.以查询为基础的数据模型(Query-based data)</p>
<p>将来查询数据库就像使用Google一样简单............</p>
<p></p>
<p>8.更大尺度上的复用(Reusability on a vast scale)</p>
<p align="left">未来的对象交互会以'组件'为基础,组件间的接口将是通用的,向一个系统中添加一个新的组件将非常容易.</p>
<p align="left"></p>
<p align="left">9.简单的系统集成(<a id="effortless-system-integration" name="effortless-system-integration"></a>Effortless System Integration)</p>
<p>你可以自由选择单独使用一个程序/组件,或使用由这些程序构成的更大的系统.</p>
<p align="left"></p>
<p align="left">10.可复用的用户界面元素(<a id="reusable-uis" name="reusable-uis"></a>Reusable UIs)</p>
<p>用户界面的元素将分类存储,并且获取和显示数据,大部分时间,我们选择并粘贴它们到系统中就能添加某个功能.</p>
<p></p>
<p>11.简单的效率伸缩性(<a id="effortlessly-scalable" name="effortlessly-scalable"></a>Effortlessly Scalable)</p>
<p>一个程序在无论在多大规模下使用都不需要进行更改.</p>
<p></p>
<p>12.内建的可进化性(Built-in Evolvability)</p>
<p>无论向多大规模的程序中添加新特性,都是一样的简单.</p>
<p style="text-align:right"></p>
<p style="text-align:right">原创文章作者保留版权 转载请注明原作者 并给出链接</p>
<p style="text-align:right"><b><a href="http://www.jtianling.com">write by 九天雁翎(JTianLing) -- www.jtianling.com</a></b></p>
<p></p>
