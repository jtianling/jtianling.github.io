---
layout: post
title: Bullet物理引擎不完全指南(Bullet Physics Engine not complete Guide)
categories:
- "游戏开发"
tags:
- Bullet
status: publish
type: post
published: true
meta:
  ratings_users: '0'
  ratings_score: '0'
  ratings_average: '0'
  views: '47'
author:
  login: jtianling
  email: jtianling@gmail.com
  display_name: jtianling
  first_name: ''
  last_name: ''
---

<p style="margin: 1em 0px 0.5em; text-align: right;"><strong><a style="color: #006bad; text-decoration: none;" href="http://www.jtianling.com">write by 九天雁翎(JTianLing) -- www.jtianling.com</a><br />
</strong></p>
<p style="margin: 1em 0px 0.5em; text-align: right;"><a style="color: #770000; text-decoration: none;" href="http://groups.google.com/group/jiutianfile/"><strong>讨论新闻组及文件</strong><br />
</a></p>
<h2>前言</h2>
<p>
&nbsp;&nbsp; &nbsp;Bullet据称为游戏世界占有率为第三的物理引擎，也是前几大引擎目前唯一能够找到的支持iPhone，开源，免费(Zlib协议，非常自由，且商业免费）的物理引擎，但是文档资料并不是很好，Demo虽然多，但是主要出于特性测试/展示的目的，会让初学者无从看起，一头雾水。我刚学习Bullet的时候困于没有好的文档及资料，非常没有头绪，折腾了很久，所以就发挥没有就创造的精神，写作及整理此文，（以整理资料为主，自己写 为辅）希望大家在学习Bullet的时候不要再像我开始一样没有头绪。因为我实在没有精力去完成一个包含Bullet方方面面的完全指南，所以本文只能是不完全版本，这个就请大家谅解了，但是期望能够真正的完成一个简单的由浅入深的教程，并提供尽量详尽的额外信息链接，只能说让初学者比看官方的WIKI和Demo效果更好，大家有好的信息和资料而本文没有包含的，也请告诉我，我可以在新版中添加进来。因为我学习Bullet的时间也比较短，有不对的地方请高人指点。</p>
<p>&nbsp;&nbsp;&nbsp; 前段时间简单的学习了一下Bullet,牵涉到图形部分的时候主要都是研究Bullet与Ogre的结合，所以使用了OgreBullet这个Ogre的Addon，其实真正的学习当然还是直接利用Bullet本身附带的简单的debug OpenGL绘制就好了。本文就完全以Bullet本身的Debug功能来学习，虽然简陋，但是可以排除干扰，专注于bullet。也许除了本文，会有个额外的文章，稍微研究下Ogre与Bullet的整合和分析一下OgreBullet的源码。</p>
<p>&nbsp;&nbsp;&nbsp; </p>
<h2>Bullet介绍</h2>
<p>
&nbsp;&nbsp;&nbsp; Bullet的<a id="qjmi" title="主页" href="http://bulletphysics.org/wordpress/" title="主页">主页</a><br />
。最新版本在这里<a id="tb7w" title="下载" href="http://code.google.com/p/bullet/downloads/list" title="下载">下载</a><br />
。简单的中文介绍见<a id="c9l_" title="百度百科" href="http://baike.baidu.com/view/449998.htm" title="百度百科">百度百科</a><br />
。一些也许可以促使你选择Bullet的小故事在以前的文章中有提及，参考<a id="o2ed" title="这里" href="http://www.jtianling.com/archive/2010/10/09/5928695.aspx" title="这里">这里</a><br />
的开头--为什么选择Bullet。很遗憾的是前几天看到的一篇很详细的bullet中文介绍找不到了，将来也许补上。</p>
<h2>安装</h2>
<p>
&nbsp;&nbsp; &nbsp;Bullet作为一款开源物理引擎，你可以选择作者<a id="l.yq" title="编译好的SDK" href="http://code.google.com/p/bullet/downloads/list" title="编译好的SDK">编译好的SDK</a><br />
，或者直接从源码编译自己的版本（Windows版本自带VS工程）。得益于CMake，在其他平台从源码自己编译也非常简单，<a id="yry_" title="参考这里" href="http://bulletphysics.org/mediawiki-1.5.8/index.php/Installation" title="参考这里">参考这里</a><br />
。iPhone版本的话参考<a id="kz4e" title="这里" href="http://www.jtianling.com/archive/2010/10/09/5928695.aspx" title="这里">这里</a><br />
。想要更详细点的图文教程可以参考<a id="vplt" title="Creating_a_project_from_scratch" href="http://bulletphysics.org/mediawiki-1.5.8/index.php/Creating_a_project_from_scratch" title="Creating_a_project_from_scratch">Creating_a_project_from_scratch</a><br />
。</p>
<h2><span class="mw-headline">Hello World Application</span><br />
</h2>
<p>
&nbsp;&nbsp;&nbsp; 在学习之前，没有接触过物理引擎的可以参考一下这个<a id="tc4." title="术语表" href="http://bulletphysics.org/mediawiki-1.5.8/index.php/Glossary_of_Terms" title="术语表">术语表</a><br />
。</p>
<p>&nbsp;&nbsp; &nbsp;<a id="u96x" title="这里" href="http://bulletphysics.org/mediawiki-1.5.8/index.php/Hello_World" title="这里">这里</a><br />
有个较为详细的教程。也包含在Bullet本身的一个名叫 AppHelloWorld 的Demo中。（注释也很详细，但是和WIKI上的版本略有不同）可以大概的对Bullet有个感觉。</p>
<p>&nbsp;&nbsp;&nbsp; 其实Bullet与Ogre走的一条路线，为了灵活，增加了很多使用的复杂性。（真怀念Box2D和Irrlicht的简单啊）其实即使希望通过strategy模式来增加灵活度，让用户可以自由的选择各类算法和解决方案，但是我还是感觉首先提供默认解决方案，用户需要不同方案的时候通过Set方式改变(甚至也可以new的时候修改）但是大牛们研究这些东西那么透，总是会觉得这个世界上不存在默认方案。。。。。因为没有方案是最优的，是适合大多数情况的，所以导致Bullet的HelloWorld程序源代码都已经超过100行。。。。。。。。。。-_-!发了点牢骚。。。。。</p>
<p>&nbsp;&nbsp;&nbsp; 通过HelloWorld程序，我们大概可以知道一些东西，比如建立一个Bullet物理世界的步骤，比如Bullet的类以bt（变态-_-!)开头，比如Bullet与Box2D这样的2D物理引擎一样，专注于数据的计算，本身没有图形输出，比如创建一个物理实体的时候也有shape的概念，然后通过一个结构作为参数(BodyConstructionInfo）来创建真实的物体，大概的熟悉一下就好，具体的细节还不懂，没有关系，一步一步来。</p>
<p>&nbsp;&nbsp;&nbsp; 另外，建议趁这个机会，确定自己机器使用Bullet的环境，特别是Win32下，我的使用方法是，利用BULLET_HOME环境变量指明Bullet安装的位置，BULLTE_LIBS指明最后编译完的静态库的位置，工程中利用这两个环境变量来确定位置。（这种用法很适合屏蔽各机器的环境不同）最后的Hello World工程见https://bullet-sample.jtianling.googlecode.com/hg/中的Bullet-HelloWorld。</p>
<p>&nbsp;&nbsp;&nbsp; 请确保该Hello World程序能够运行（无论是你自己的还是用我的）然后才继续下面的内容。</p>
<h2>让你坐在司机的位置上</h2>
<p>
&nbsp;&nbsp;&nbsp; 该怎么学习的问题，向来都是各执一词，有人认为该从最基础的学起，就像建房子一样打好地基，有人会更加推崇自上而下的学习(Top-Down Approach），我属于后一派，能先写有用的可以摸到的程序，然后一层一层的向下学习，这样会更加有趣味性，并且学习曲线也会更加平缓，假如你是前一派，那么推荐你先看完Bullet的User Manual，然后是Bullet所有的<a id="atpt" title="Tutorial Articles" href="http://bulletphysics.org/mediawiki-1.5.8/index.php/Tutorial_Articles" title="Tutorial Articles">Tutorial Articles</a><br />
，然后再自己一个一个看Demo。</p>
<p>&nbsp;&nbsp;&nbsp; 在Hello World的例子中你已经可以看到文本数据的输出，能够看到球/Box的落下了，但是很明显太不直观了，得益于Bullet良好的debug输出支持，我们要先能直观的通过图形看到球的落下！先坐在司机的位置上才能学会开车^^你也不至于被乏味的汽车/交通理论闷死。</p>
<p>&nbsp;&nbsp;&nbsp; Bullet像Ogre一样，提供了一个DemoApplication类，方便我们学习，我们先看看Bullet的DemoApplication是怎么样的。先看看Bullet自己提供的AppBasicDemo这个Demo。忽略那些作者用#if 0关闭的内容和hashmap的测试内容，看看DemoApplication的用法。</p>
<p>首先是BasicDemo类，从class BasicDemo : public PlatformDemoApplication可以看到，DemoApplication是给你继承使用的，这里的PlatformDemoApplication实际是GlutDemoApplication。（Win32那个作者好像只是预留的）</p>
<p>怎么去实现这个类先放一边，看看整个类的使用：</p>
<p>&nbsp;&nbsp;&nbsp; GLDebugDrawer&nbsp;&nbsp; &nbsp;gDebugDrawer;</p>
<p>&nbsp;&nbsp; &nbsp;BasicDemo ccdDemo;</p>
<p>&nbsp;&nbsp; &nbsp;ccdDemo.initPhysics();</p>
<p>&nbsp;&nbsp; &nbsp;ccdDemo.getDynamicsWorld()-&gt;setDebugDrawer(&amp;gDebugDrawer);</p>
<p>&nbsp;&nbsp; &nbsp;glutmain(argc, argv,640,480,&quot;Bullet Physics Demo. http://bulletphysics.com&quot;,&amp;ccdDemo);</p>
<p>实际就这5句，很简单，构造debug,BasicDemo，调用initPhysics函数，设定debug，调用glutmain这个函数，参数也一目了然。这里就不看了。看实现一个有用的DemoApplication的过程。</p>
<p>&nbsp;&nbsp;&nbsp; 大概看看DemoApplication这个基类和GlutDemoApplication知道必须要实现的两个纯虚函数是</p>
<p>virtual&nbsp;&nbsp; &nbsp;void initPhysics() = 0;</p>
<p>virtual void clientMoveAndDisplay() = 0;</p>
<p>看BasicDemo的实现后，知道还需要实现displayCallback这个现实回调，基本上就没有其他东西了，理解起来也还算容易。</p>
<p>initPhysics的部分，一看就知道，与HelloWorld中过程几乎一致，也就是实际构建物理世界的过程。只是多了&nbsp;&nbsp;&nbsp; </p>
<p>setTexturing(true);</p>
<p>setShadows(true);</p>
<p>setCameraDistance(btScalar(SCALING*50.));</p>
<p>这三个与显示有关的东西（其实这些代码放到myinit中去也可以，毕竟与物理无关）</p>
<p>最后还多了个clientResetScene的调用，我们知道这个过程就好，具体函数的实现先不管。</p>
<p>clientMoveAndDisplay和displayCallback部分</p>
<p>其实非常简单，几乎可以直接放到glutExampleApplication中去。（事实上不从灵活性考虑，我觉得放到glutExampleApplication中更好）</p>
<p>原来的程序有些代码重复，其实只要下列代码就够了：（一般的程序也不需要修改）<br />
<span style="color: #008000;">void</span><br />
&nbsp;BasicDemo::clientMoveAndDisplay()</p>
<p> {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">//simple dynamics world doesn't handle fixed-time-stepping</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">float</span><br />
&nbsp;ms = getDeltaTimeMicroseconds();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">///step the simulation</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;(m_dynamicsWorld)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_dynamicsWorld-&gt;stepSimulation(ms / <span style="color: #008080;">1000000.f</span><br />
);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;displayCallback();</p>
<p> }</p>
<p><span style="color: #008000;">void</span><br />
&nbsp;BasicDemo::displayCallback(<span style="color: #008000;">void</span><br />
) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); </p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;renderme();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">//optional but useful: debug drawing to detect problems</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;(m_dynamicsWorld)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_dynamicsWorld-&gt;debugDrawWorld();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;glFlush();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;swapBuffers();</p>
<p> }</p>
<p>运行该程序能够看到中间一个很多Box堆起来的大方块，点击鼠标右键还能发射一个方块出去。</p>
<p>了解这个Demo以后，我们就可以直接来用Bullet构建我们自己的物理世界了，暂时不用考虑图形的问题，甚至不用知道Bullet使用<a id="fpor" title="GLUI" href="http://www.opengl.org/resources/libraries/glut/" title="GLUI">GLUT</a><br />
作为debug图形的输出，<a id="i.:d" title="GLUI" href="http://glui.sourceforge.net/" title="GLUI">GLUI</a><br />
做界面，都不用知道，只需要知道上面demoApplication的使用和在initPhysics函数中完成构建物理世界的代码。另外，你愿意的话，也可以先看看exitPhysics的内容，用于分配资源的释放，作为C++程序，一开始就关注资源的释放问题是个好习惯。虽然对于我们这样简单的demo程序来说是无所谓的。</p>
<p>看过上面Demo后，也许你已经有些了解，也许你还是一头雾水，不管怎么样，Bullet的Demo毕竟还是别人的东西，现在，从零开始，构建一个HelloWorld程序描述的世界。先自己尝试一下！假如你成功了，那么直接跳过一下的内容，失败了，再回头了看看，提醒你步骤：</p>
<p>1.继承DemoApplication，拷贝上面clientMoveAndDisplay和displayCallback部分的代码，实现这两个函数。</p>
<p>2.在initPhysics函数中完成构建物理世界的代码。（构建过程参考HelloWorld）</p>
<p>3.Main中的使用代码：</p>
<p>&nbsp;&nbsp;&nbsp; GLDebugDrawer&nbsp;&nbsp; &nbsp;gDebugDrawer;</p>
<p>&nbsp;&nbsp; &nbsp;BasicDemo ccdDemo;</p>
<p>&nbsp;&nbsp; &nbsp;ccdDemo.initPhysics();</p>
<p>&nbsp;&nbsp; &nbsp;ccdDemo.getDynamicsWorld()-&gt;setDebugDrawer(&amp;gDebugDrawer);</p>
<p>&nbsp;&nbsp; &nbsp;glutmain(argc, argv,640,480,&quot;Bullet Physics Demo. http://bulletphysics.com&quot;,&amp;ccdDemo);</p>
<p>4.注意工程需要多包含$(BULLET_HOME)/Demos/OpenGL的头文件目录</p>
<p>和库：</p>
<p>$(BULLET_HOME)/Glut/glut32.lib</p>
<p>opengl32.lib</p>
<p>glu32.lib</p>
<p>麻烦点的是glut是个动态库，你需要将dll文件拷贝到你工程的运行目录。</p>
<p>现在应该成功了吧？</p>
<p>我实现的工程见https://bullet-sample.jtianling.googlecode.com/hg/中的Bullet-WithGL。</p>
<p>于是乎，现在你已经可以看到Hello World中那个不曾显示的电脑凭空现象的球了。大概是下面这个样子滴：(因为现在Google Docs写完文章后很久就不能够直接post到CSDN的博客中去了，所以每次写完文章后都得到新建文章中去复制粘贴，图片还需要重新上传然后插入，非常麻烦，所以最近的文章都尽量的减少了图片的使用，见谅。其实说来，只有看热闹的人才需要截图，真的看教程的人估计自己的程序都已经运行起来了，也没有必要看我的截图了)</p>
<div id="jc5w" style="text-align: left;">
</div>
<p>
<img src="http://hi.csdn.net/attachment/201010/19/0_1287495180CII2.gif" alt="" /><br /></p>
<p>到目前为止，你已经有了可以自己happy一下的程序了，你可以立即深入的学习，去研究ExampleApplication的源代码，去了解Bullet是怎么与图形交互的，但是在这个之前，特别是对于以前没有使用过其他物理引擎的人，先多在这个图形版的HelloWorld的程序的基础上玩玩，比如现在球很明显没有弹性，调整一下反弹的系数看看，比如多生成几个球，比如加上速度，演示两个球的碰撞，比如因为现在没有设置debugmode，所以实际没有debug信息输出，尝试输出aabb等debug信息，有助于进一步学习。有了图形，就有了丰富的世界，先对Bullet的各个概念先熟悉一下（特别是btRigidBodyConstructionInfo中的各个变量，还有各个shape）然后再前进吧。事实上，得益于ExampleApplication，现在甚至可以用鼠标左键拖拽物理，右键发射箱子的功能也还在，还能按左右键调整camera。（其实还有一堆功能，自己尝试一下吧）因为比较简单，在本教程中不会再有关于这些基础信息的内容，只能自己去找资料或者尝试了。其实就我使用物理引擎的经验，学习并使用一款物理引擎并不会太难，最麻烦的地方在于后期游戏中各个参数的调整，尽量使游戏的效果变得真实，自然，或者达到你想要的效果，这种调整很多时候需要靠你自己的感觉，而这个感觉的建立，那就是多多尝试一个物理引擎中的在各个参数下呈现的不同效果了，这种感觉的建立，经验的获得，不是任何教程，文档或者演示程序能够给你的。</p>
<p>比如，下面是Bullet支持的5种基本物体形状：</p>
<div id="la36" style="text-align: left;">
</div>
<p>
<img src="http://hi.csdn.net/attachment/201010/19/0_1287495221z3jW.gif" alt="" /><br /></p>
<p>其实上面的内容是最关键的，此时学开车的你已经在司机的位置了，学游泳的你已经在水里了，剩下的Bullet相关的内容虽然还有很多，但是其实已经完全可以自己独立折腾了，因为每个折腾的成果你都已经能够实时的看到，能够很哈皮的去折腾了。</p>
<h2>与显示的整合，MotionState</h2>
<p>
&nbsp;&nbsp;&nbsp; 一个只有数据运算的物理引擎，一般而言只能为显示引擎提供数据，这就牵涉到与图形引擎整合的问题，像Box2D这样的物理引擎就是直接需要直接向各个物理实体去查询位置，然后更新显示，这种方式虽然简单，但是我感觉非常不好，因为难免在update中去更新这种东西，导致游戏逻辑部分需要处理物理引擎+图形引擎两部分的内容。（可以参考Box2D与Cocos2D for iPhone的整合）而且，对于完全没有移动的物体也会进行一次查询和移动操作。（即使优化，对不移动物体也是进行了两次查询）</p>
<p>&nbsp;&nbsp; &nbsp;Bullet为了解决此问题，提供了新的解决方案，MotionState。其实就是当活动物体状态改变时提供一种回调，而且就Bullet的文档中说明，此种回调还带有适当的插值以优化显示。通过这种方法，在MotionState部分就已经可以完成显示的更新，不用再需要在update中添加这种更新的代码。而且，注意，仅仅对活动物体状态改变时才会进行回调，这样完全避免了不活动物体的性能损失。</p>
<p>&nbsp;&nbsp; &nbsp;首先看看ExampleApplication中是怎么利用default的MotionState来显示上面的图形的，然后再看看复杂点的例子，与Ogre的整合。</p>
<p>先看看回调接口：</p>
<p><span style="color: #804000;">///The btMotionState interface class allows the dynamics world to synchronize and interpolate the updated world transforms with graphics</span><br />
<br />
<span style="color: #804000;">///For optimizations, potentially only moving objects get synchronized (using setWorldPosition/setWorldOrientation)</span><br />
<br />
<span style="color: #008000;">class</span><br />
&nbsp;&nbsp; btMotionState</p>
<p> {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">public</span><br />
:</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">virtual</span><br />
&nbsp;~btMotionState()</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">virtual</span><br />
&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;&nbsp;getWorldTransform(btTransform&amp; worldTrans ) <span style="color: #008000;">const</span><br />
&nbsp;=<span style="color: #008080;">0</span><br />
;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">//Bullet only calls the update of worldtransform for active objects</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">virtual</span><br />
&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;&nbsp;setWorldTransform(<span style="color: #008000;">const</span><br />
&nbsp;btTransform&amp; worldTrans)=<span style="color: #008080;">0</span><br />
;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;</p>
<p> };</p>
<p>很简单，一个get接口，用于bullet获取物体的初始状态，一个set接口，用于活动物体位置改变时调用以设置新的状态。</p>
<p>下面看看btDefaultMotionState这个bullet中带的默认的MotionState类。</p>
<p><span style="color: #804000;">///The btDefaultMotionState provides a common implementation to synchronize world transforms with offsets.</span><br />
<br />
<span style="color: #008000;">struct</span><br />
&nbsp;&nbsp;btDefaultMotionState : <span style="color: #804000;">public</span><br />
&nbsp;btMotionState</p>
<p> {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;btTransform m_graphicsWorldTrans;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;btTransform m_centerOfMassOffset;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;btTransform m_startWorldTrans;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_userPointer;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;btDefaultMotionState(<span style="color: #008000;">const</span><br />
&nbsp;btTransform&amp; startTrans = btTransform::getIdentity(),<span style="color: #008000;">const</span><br />
&nbsp;btTransform&amp; centerOfMassOffset = btTransform::getIdentity())</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: m_graphicsWorldTrans(startTrans),</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_centerOfMassOffset(centerOfMassOffset),</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_startWorldTrans(startTrans),</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_userPointer(<span style="color: #008080;">0</span><br />
)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">///synchronizes world transform from user to physics</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">virtual</span><br />
&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;&nbsp; getWorldTransform(btTransform&amp; centerOfMassWorldTrans ) <span style="color: #008000;">const</span><br />
&nbsp;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;centerOfMassWorldTrans =&nbsp;&nbsp;&nbsp; m_centerOfMassOffset.inverse() * m_graphicsWorldTrans ;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">///synchronizes world transform from physics to user</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">///Bullet only calls the update of worldtransform for active objects</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">virtual</span><br />
&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;&nbsp; setWorldTransform(<span style="color: #008000;">const</span><br />
&nbsp;btTransform&amp; centerOfMassWorldTrans)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_graphicsWorldTrans = centerOfMassWorldTrans * m_centerOfMassOffset ;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> };</p>
<p>这个默认的MotionState实现了这两个接口，但是还引入了<span class="def">质心</span><br />
（center Of Mass应该是指<span class="def">质心</span><br />
吧）的概念，与外部交互时，以质心位置表示实际物体所在位置。</p>
<p>在一般rigitBody的构造函数中可以看到下列代码：</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;(m_optionalMotionState)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_optionalMotionState-&gt;getWorldTransform(m_worldTransform);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;} <span style="color: #804000;">else</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_worldTransform = constructionInfo.m_startWorldTransform;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>这就是get函数的使用，也就是决定物体初始坐标的函数回调。</p>
<p>set函数的回调如下：</p>
<p><span style="color: #008000;">void</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;btDiscreteDynamicsWorld::synchronizeSingleMotionState(btRigidBody* body)</p>
<p> {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;btAssert(body);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;(body-&gt;getMotionState() &amp;&amp; !body-&gt;isStaticOrKinematicObject())</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">//we need to call the update at least once, even for sleeping objects</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">//otherwise the 'graphics' transform never updates properly</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">///@todo: add 'dirty' flag</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">//if (body-&gt;getActivationState() != ISLAND_SLEEPING)</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btTransform interpolatedTransform;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btTransformUtil::integrateTransform(body-&gt;getInterpolationWorldTransform(),</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body-&gt;getInterpolationLinearVelocity(),body-&gt;getInterpolationAngularVelocity(),m_localTime*body-&gt;getHitFraction(),interpolatedTransform);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body-&gt;getMotionState()-&gt;setWorldTransform(interpolatedTransform);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> }</p>
<p>也就是同步状态的时候调用。此过程发生在调用bullet的<span style="font-family: Courier New;">btDynamicsWorld::stepSimulation函数调用时。</span></p>
<p>然后可以参考DemoApplication的DemoApplication::renderscene(int pass)函数：</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;btScalar&nbsp;&nbsp;&nbsp; m[<span style="color: #008080;">16</span><br />
];</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;btMatrix3x3 rot;rot.setIdentity();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">const</span><br />
&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;&nbsp;numObjects=m_dynamicsWorld-&gt;getNumCollisionObjects();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;btVector3 wireColor(<span style="color: #008080;">1</span><br />
,<span style="color: #008080;">0</span><br />
,<span style="color: #008080;">0</span><br />
);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">for</span><br />
(<span style="color: #008000;">int</span><br />
&nbsp;i=<span style="color: #008080;">0</span><br />
;i&lt;numObjects;i++)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btCollisionObject*&nbsp; colObj=m_dynamicsWorld-&gt;getCollisionObjectArray()[i];</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btRigidBody*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; body=btRigidBody::upcast(colObj);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
(body&amp;&amp;body-&gt;getMotionState())</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btDefaultMotionState* myMotionState = (btDefaultMotionState*)body-&gt;getMotionState();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myMotionState-&gt;m_graphicsWorldTrans.getOpenGLMatrix(m);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rot=myMotionState-&gt;m_graphicsWorldTrans.getBasis();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>&nbsp;&nbsp;&nbsp; }</p>
<p>}</p>
<p>实际也就是再通过获取motionState然后获取到图形的位置了，这种defaultMotion的使用就类似Box2D中的使用了。</p>
<p>既然是回调，那么就可以让函数不仅仅做赋值那么简单的事情，回头来再做一次轮询全部物体的查询，官网的WIKI中为Ogre编写的MotionState就比较合乎推荐的MotionState用法，代码如下：</p>
<p> lass MyMotionState : <span style="color: #804000;">public</span><br />
&nbsp;btMotionState {<br />
<span style="color: #804000;">public</span><br />
:</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;MyMotionState(<span style="color: #008000;">const</span><br />
&nbsp;btTransform &amp;initialpos, Ogre::SceneNode *node) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mVisibleobj = node;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mPos1 = initialpos;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">virtual</span><br />
&nbsp;~MyMotionState() {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;setNode(Ogre::SceneNode *node) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mVisibleobj = node;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">virtual</span><br />
&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;getWorldTransform(btTransform &amp;worldTrans) <span style="color: #008000;">const</span><br />
&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;worldTrans = mPos1;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">virtual</span><br />
&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;setWorldTransform(<span style="color: #008000;">const</span><br />
&nbsp;btTransform &amp;worldTrans) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
(<span style="color: #008080;">NULL</span><br />
&nbsp;== mVisibleobj) <span style="color: #804000;">return</span><br />
; <span style="color: #804000;">// silently return before we set a node</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btQuaternion rot = worldTrans.getRotation();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mVisibleobj-&gt;setOrientation(rot.w(), rot.x(), rot.y(), rot.z());</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btVector3 pos = worldTrans.getOrigin();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mVisibleobj-&gt;setPosition(pos.x(), pos.y(), pos.z());</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p><span style="color: #804000;">protected</span><br />
:</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;Ogre::SceneNode *mVisibleobj;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;btTransform mPos1;</p>
<p> };</p>
<p>注意，这里的使用直接在set回调中直接设置了物体的位置。如此使用MotionState后，update只需要关心逻辑即可，不用再去手动查询物体的位置，然后更新物体的位置并刷新显示。</p>
<h2>碰撞检测</h2>
<p>
&nbsp;&nbsp;&nbsp; 物理引擎不仅仅包括模拟真实物理实现的一些运动，碰撞，应该还提供方式供检测碰撞情况，bullet也不例外。</p>
<p>&nbsp;&nbsp; &nbsp;AppCollisionInterfaceDemo展示了怎么直接通过btCollisionWorld来检测碰撞而不模拟物理。</p>
<p>而官方的WIKI对于碰撞检测的描述也过于简单，只给下列的示例代码，但是却没有详细的解释。</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">//Assume world-&gt;stepSimulation or world-&gt;performDiscreteCollisionDetection has been called</span></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;numManifolds = world-&gt;getDispatcher()-&gt;getNumManifolds();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">for</span><br />
&nbsp;(<span style="color: #008000;">int</span><br />
&nbsp;i=<span style="color: #008080;">0</span><br />
;i&lt;numManifolds;i++)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btPersistentManifold* contactManifold =&nbsp; world-&gt;getDispatcher()-&gt;getManifoldByIndexInternal(i);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btCollisionObject* obA = <span style="color: #804000;">static_cast</span><br />
&lt;btCollisionObject*&gt;(contactManifold-&gt;getBody0());</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btCollisionObject* obB = <span style="color: #804000;">static_cast</span><br />
&lt;btCollisionObject*&gt;(contactManifold-&gt;getBody1());</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;numContacts = contactManifold-&gt;getNumContacts();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">for</span><br />
&nbsp;(<span style="color: #008000;">int</span><br />
&nbsp;j=<span style="color: #008080;">0</span><br />
;j&lt;numContacts;j++)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btManifoldPoint&amp; pt = contactManifold-&gt;getContactPoint(j);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;(pt.getDistance()&lt;<span style="color: #008080;">0.f</span><br />
)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">const</span><br />
&nbsp;btVector3&amp; ptA = pt.getPositionWorldOnA();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">const</span><br />
&nbsp;btVector3&amp; ptB = pt.getPositionWorldOnB();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">const</span><br />
&nbsp;btVector3&amp; normalOnB = pt.m_normalWorldOnB;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>以上代码的主要内容就是<br />
<span style="color: #008000;">int</span><br />
&nbsp;numManifolds = world-&gt;getDispatcher()-&gt;getNumManifolds();</p>
<p>btPersistentManifold* contactManifold =&nbsp; world-&gt;getDispatcher()-&gt;getManifoldByIndexInternal(i);</p>
<p>两句。</p>
<p>&nbsp;&nbsp; &nbsp;而btPersistentManifold类表示一个Manifold，其中包含了body0,body1表示Manifold的两个物体。</p>
<p>这里特别提及的是,Manifold并不直接表示碰撞，其真实的含义大概是重叠，在不同的情况下可能表示不同的含义，比如在Box2D中，手册的描述大概是（凭记忆）为了快速的检测碰撞，在2D中一般先经过AABB盒的检测过滤，而只有AABB盒重叠的才有可能碰撞，而Manifold在Box2D中就表示AABB盒重叠的两个物体，而我看Bullet有不同的Broadphase,在实际中，也重叠也应该会有不同的情况，因为我没有看源码，所以不能确定，但是，总而言之，可以理解Manifold为接近碰撞的情况。</p>
<p>所以无论在Box2D还是Bullet中，都有额外的表示碰撞的概念，那就是contact（接触）。上述示例代码：<br />
<span style="color: #008000;">int</span><br />
&nbsp;numContacts = contactManifold-&gt;getNumContacts();</p>
<p>就表示查看接触点的数量，假如接触点为0，那么自然表示两个物体接近于碰撞，而实际没有碰撞。而上述代码中的Distance的判断应该是防止误差，因为我输出了一个盒子和地面发生碰撞的全部过程的distance，发现绝大部分情况，只要有contact，那么距离就小于0，可是在一次盒子离开地面的过程中，distance还真有过一次0.00x的正值。。。。。。。</p>
<p>当你开始放心大胆的使用上述代码后，也许你总是用来模拟物体的其他效果，也许都不会有问题，直到某一天你希望在碰撞检测后删除掉发生碰撞的问题，你的程序crash了。。。。你却不知道为什么。用前面的demo来展示碰撞检测的方法，并且删除掉发生碰撞的物体。一般先写出的代码都会类似下面这样：</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;numManifolds = m_dynamicsWorld-&gt;getDispatcher()-&gt;getNumManifolds();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">for</span><br />
&nbsp;(<span style="color: #008000;">int</span><br />
&nbsp;i=<span style="color: #008080;">0</span><br />
;i&lt;numManifolds;i++)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btPersistentManifold* contactManifold =&nbsp; m_dynamicsWorld-&gt;getDispatcher()-&gt;getManifoldByIndexInternal(i);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btCollisionObject* obA = <span style="color: #804000;">static_cast</span><br />
&lt;btCollisionObject*&gt;(contactManifold-&gt;getBody0());</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btCollisionObject* obB = <span style="color: #804000;">static_cast</span><br />
&lt;btCollisionObject*&gt;(contactManifold-&gt;getBody1());</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;numContacts = contactManifold-&gt;getNumContacts();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">for</span><br />
&nbsp;(<span style="color: #008000;">int</span><br />
&nbsp;j=<span style="color: #008080;">0</span><br />
;j&lt;numContacts;j++)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btManifoldPoint&amp; pt = contactManifold-&gt;getContactPoint(j);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;(pt.getDistance()&lt;<span style="color: #008080;">0.f</span><br />
)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RemoveObject(obA);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RemoveObject(obB);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>但是上面这样的代码是有问题的，这在Box2D的文档中有详细描述，Bullet文档中没有描述，那就是obA和obB可能重复删除的问题（也就相当于删除同一个对象多次，自然crash）在本例中有两个问题会导致重复，很明显的一个，当两个物体多余一个Contact点的时候，在遍历Contacts点时会导致obA,obB重复删除。另外，稍微隐晦点的情况是，当一个物体与两个物体发生碰撞时，同一个物体也可能在不同的manifold中，所以，真正没有问题的代码是先<span style="color: #ff0000;">记录所有的碰撞，然后消除重复，再然后删除</span><br />
。这是Bullet文档中没有提到，WIKI中也没有说明的，初学者需要特别注意。。。。。。下面才是安全的代码：</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;numManifolds = m_dynamicsWorld-&gt;getDispatcher()-&gt;getNumManifolds();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">for</span><br />
&nbsp;(<span style="color: #008000;">int</span><br />
&nbsp;i=<span style="color: #008080;">0</span><br />
;i&lt;numManifolds;i++)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btPersistentManifold* contactManifold =&nbsp; m_dynamicsWorld-&gt;getDispatcher()-&gt;getManifoldByIndexInternal(i);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btCollisionObject* obA = <span style="color: #804000;">static_cast</span><br />
&lt;btCollisionObject*&gt;(contactManifold-&gt;getBody0());</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btCollisionObject* obB = <span style="color: #804000;">static_cast</span><br />
&lt;btCollisionObject*&gt;(contactManifold-&gt;getBody1());</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">int</span><br />
&nbsp;numContacts = contactManifold-&gt;getNumContacts();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">for</span><br />
&nbsp;(<span style="color: #008000;">int</span><br />
&nbsp;j=<span style="color: #008080;">0</span><br />
;j&lt;numContacts;j++)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;btManifoldPoint&amp; pt = contactManifold-&gt;getContactPoint(j);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;(pt.getDistance()&lt;<span style="color: #008080;">0.f</span><br />
)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_collisionObjects.push_back(obA);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_collisionObjects.push_back(obB);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;m_collisionObjects.sort();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;m_collisionObjects.unique();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">for</span><br />
&nbsp;(CollisionObjects_t::iterator itr = m_collisionObjects.begin();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;itr != m_collisionObjects.end();</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++itr) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RemoveObject(*itr);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;m_collisionObjects.clear();</p>
<p>上述m_collisionObjects是std::list类型的成员变量。</p>
<h2>碰撞过滤</h2>
<p>
&nbsp;&nbsp;&nbsp; <a id="zq4w" title="Bullet的wiki" href="http://bulletphysics.org/mediawiki-1.5.8/index.php/Collision_Filtering" title="Bullet的wiki">Bullet的wiki</a><br />
 提到了3个方法，这里只讲述最简单的mask（掩码）过滤方法。</p>
<p>&nbsp;&nbsp; &nbsp;mask的使用相信大家基本都接触过，无非就是通过一个整数各个2进制位来表示一些bool值。比如Unix/Linux中文件权限的掩码。在bullet中的碰撞mask的使用非常简单，主要在addRigidBody时候指定。（需要注意的是，只有btDiscreteDynamicsWorld类才有这个函数，btDynamicsWorld并没有，所以demoApplication中的成员变量dynamicWorld不能直接使用。）</p>
<p>WIKI中的代码已经很能说明问题了：</p>
<p><span style="color: #c000c0;">#define BIT(x) (</span><br />
<span style="color: #008080;">1</span><br />
<span style="color: #c000c0;">&lt;&lt;(x))</span><br />
<br />
<span style="color: #008000;">enum</span><br />
&nbsp;collisiontypes {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;COL_NOTHING = <span style="color: #008080;">0</span><br />
, <span style="color: #804000;">//&lt;Collide with nothing</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;COL_SHIP = BIT(<span style="color: #008080;">1</span><br />
), <span style="color: #804000;">//&lt;Collide with ships</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;COL_WALL = BIT(<span style="color: #008080;">2</span><br />
), <span style="color: #804000;">//&lt;Collide with walls</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;COL_POWERUP = BIT(<span style="color: #008080;">3</span><br />
) <span style="color: #804000;">//&lt;Collide with powerups</span><br /></p>
<p> }</p>
<p><span style="color: #008000;">int</span><br />
&nbsp;shipCollidesWith = COL_WALL;<br />
<span style="color: #008000;">int</span><br />
&nbsp;wallCollidesWith = COL_NOTHING;<br />
<span style="color: #008000;">int</span><br />
&nbsp;powerupCollidesWith = COL_SHIP | COL_WALL;</p>
<p></p>
<p> btRigidBody ship; <span style="color: #804000;">// Set up the other ship stuff</span><br /></p>
<p> btRigidBody wall; <span style="color: #804000;">// Set up the other wall stuff</span><br /></p>
<p> btRigidBody powerup; <span style="color: #804000;">// Set up the other powerup stuff</span></p>
<p> mWorld-&gt;addRigidBody(ship, COL_SHIP, shipCollidesWith);</p>
<p> mWorld-&gt;addRigidBody(wall, COL_WALL, wallCollidesWith);</p>
<p> mWorld-&gt;addRigidBody(powerup, COL_POWERUP, powerupCollidesWith);</p>
<p>特别是那个<span style="color: #c000c0;">#define BIT(x) (</span><br />
<span style="color: #008080;">1</span><br />
<span style="color: #c000c0;">&lt;&lt;(x))</span><br />
宏用的很有意思。</p>
<p>不要特别注意的是，两个物体要发生碰撞，那么，两个物体的collidesWith参数必须要互相指定对方，假如A指定碰撞B，但是B没有指定碰撞A,那么还是没有碰撞。就上面的例子而言，虽然ship和powerup想要撞墙，但是墙不想撞它们，那么事实上，上面的例子就相当于过滤了所有墙的碰撞，其实仅仅只有ship和power的碰撞，这真所谓强扭的瓜不甜啊，等双方都情愿。</p>
<p>仿照上面的例子，假如你希望在碰撞检测的时候过滤掉地板，只让物体间发生碰撞然后删除物体，为demo添加下列代码：</p>
<p><span style="color: #c000c0;">#define BIT(x) (</span><br />
<span style="color: #008080;">1</span><br />
<span style="color: #c000c0;">&lt;&lt;(x))</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">enum</span><br />
&nbsp;collisiontypes {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COL_NOTHING = <span style="color: #008080;">0</span><br />
, <span style="color: #804000;">//&lt;Collide with nothing</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COL_GROUND = BIT(<span style="color: #008080;">1</span><br />
), <span style="color: #804000;">//&lt;Collide with ships</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COL_OBJECTS = BIT(<span style="color: #008080;">2</span><br />
), <span style="color: #804000;">//&lt;Collide with walls</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;};</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">short</span><br />
&nbsp;GroundCollidesWith = COL_OBJECTS;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">short</span><br />
&nbsp;ObjectsCollidesWith = COL_GROUND;</p>
<p>但是当你将上述方法应用到demo中，想要过滤掉你想要的碰撞，你会发现碰撞检测的确是过滤掉了，同时过滤掉的还有碰撞，球直接传地板而过，掉进了无底的深渊。注意，这里的过滤是指碰撞过滤，而不是碰撞检测的过滤，假如希望实现碰撞检测的过滤，你可以在碰撞检测中直接进行。比如前面地板的例子，因为地板是静态物体，你可以通过调用rigidBody的isStaticObject来判断是否是地板，然后进行删除，就如下面的代码这样：</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;(pt.getDistance()&lt;<span style="color: #008080;">0.f</span><br />
) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;(!obA-&gt;isStaticObject()) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_collisionObjects.push_back(obA);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;(!obB-&gt;isStaticObject()) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_collisionObjects.push_back(obB);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>假如希望与地面碰撞并不删除物体，只有物体与物体的碰撞才删除物体，这也简单：</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">if</span><br />
&nbsp;(!obA-&gt;isStaticObject() &amp;&amp; !obB-&gt;isStaticObject()) {</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_collisionObjects.push_back(obA);</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_collisionObjects.push_back(obB);</p>
<p>至于更加复杂的情况，还可以借助于rigidBody的UserPointer，这在WIKI中没有提及，</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">///users can point to their objects, userPointer is not used by Bullet</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
*&nbsp; getUserPointer() <span style="color: #008000;">const</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">return</span><br />
&nbsp;m_userObjectPointer;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #804000;">///users can point to their objects, userPointer is not used by Bullet</span><br /></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #008000;">void</span><br />
&nbsp;&nbsp; setUserPointer(<span style="color: #008000;">void</span><br />
* userPointer)</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;{</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_userObjectPointer = userPointer;</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;}</p>
<p>但是就我的经验，这两个函数的作用是巨大的，你可以将你需要的一切都设置进去。。。。。。。。然后取出来，就上面的碰撞检测过滤而言，你完全可以实现自己的一套碰撞检测mask，只要你想，一切皆有可能。这些例子的完整源代码见https://bullet-sample.jtianling.googlecode.com/hg/中的Bullet-CollideDetection工程。</p>
<h2>约束(Constraints)和连接(Joints)</h2>
<p>
&nbsp;&nbsp;&nbsp; 一个一个单独的物理实体已经可以构建一个有意思的物理世界了，但是显示世界有很多东西（最典型的就是绳子连接的物体）不是单独的物理实体可以模拟的，物理引擎中使用约束来模拟类似的东西/现象。</p>
<p>&nbsp;&nbsp; &nbsp;（待补充）</p>
<h2>软体</h2>
<p>
&nbsp;&nbsp; 因为我的使用暂时不需要用到软体，暂时未学习此部分内容，欢迎大家补充。</p>
<h2>有用的工具</h2>
<p>
1. <a id="o_bu" title="MAYA,3D Max的插件" href="http://code.google.com/p/dynamica/downloads/list" title="MAYA,3D Max的插件">MAYA,3D Max的插件</a><br /></p>
<p>2. <a id="x1fp" title="Blender" href="http://www.blender.org/" title="Blender">Blender</a><br />
，开源的3D建模工具，内建的Game Engine有直接的Bullet支持，还有<a id="dfka" title="Erwin提供的改版" href="http://code.google.com/p/bullet-physics-editor/downloads/list" title="Erwin提供的改版">Erwin提供的改版</a><br />
可以直接导出.bullet文件。</p>
<h2>使用了Bullet的其他有用工程</h2>
<p>
1. <a id="z2e2" title="GameKit" href="http://code.google.com/p/gamekit/" title="GameKit">GameKit</a><br />
,Erwin Coumans自己发起的整合Ogre/Irrlicht和Bullet的游戏引擎，与Blender结合的也很好。</p>
<p>2. <a id="s:s_" title="oolongengine" href="http://code.google.com/p/oolongengine/" title="oolongengine">oolongengine</a><br />
,乌龙引擎，<a href="http://code.google.com/u/wolfgang.engel/">wolfgang.engel</a><br />
（<a id="g40j" title="他的博客" href="http://www.wolfgang-engel.info/blogs/" title="他的博客">他的博客</a><br />
）这个大牛（到底有多牛可以<a id="uv2b" title="参考这里" href="http://www.linkedin.com/in/wolfgangengel" title="参考这里">参考这里</a><br />
）发起的iPhone平台引擎项目，使用了Bullet，也为Bullet能够流畅的运行于iPhone平台做出了很大贡献。（优化了浮点运算）为什么写乌龙引擎？wolfgang自己有个解释，<a id="e1_q" title="见这里" href="http://www.jtianling.com/archive/2010/10/11/5933822.aspx" title="见这里">见这里</a><br />
。</p>
<p>3. <a id="ix2q" title="Dynamica" href="http://code.google.com/p/dynamica" title="Dynamica">Dynamica</a><br />
, Erwin建立的工程，开发bullet的Maya,3D Max插件。</p>
<p>4.&nbsp;<a id="v4-m" title="bullet-physics-editor" href="http://code.google.com/p/bullet-physics-editor/" title="bullet-physics-editor">bullet-physics-editor</a><br />
, Erwin自己发起的一个bullet编辑器工程，目前还处于前期开发阶段。但是项目中同时包含一些能够到处.Bullet文件的<a id="um-q" title="Blender改版" href="http://code.google.com/p/bullet-physics-editor/downloads/list" title="Blender改版">Blender改版</a><br />
。</p>
<h2>Bullet的实现原理</h2>
<p>
1.<a id="qnk1" title="Physics Pipeline Implementation" href="http://bulletphysics.org/mediawiki-1.5.8/index.php/Physics_Pipeline_Implementation" title="Physics Pipeline Implementation">Physics Pipeline Implementation</a><br />
,应该是一个在爱尔兰的中国人写的，并发布在WIKI上，这里是他的<a id="o3gy" title="博客" href="http://iphonephysics.com/" title="博客">博客</a><br />
。</p>
<p>2.<a title="SIGGRAPH 2010 course slides, high-level overview on Bullet collision detection" href="http://bullet.googlecode.com/files/GDC10_Coumans_Erwin_Contact.pdf" title="SIGGRAPH 2010 course slides, high-level overview on Bullet collision detection">SIGGRAPH 2010 course slides, high-level overview on Bullet collision detection</a><br /></p>
<p>3.<a title="GDC 2010 presentation about contact generation" href="http://bullet.googlecode.com/files/GDC10_Coumans_Erwin_Contact.pdf" title="GDC 2010 presentation about contact generation">GDC 2010 presentation about contact generation</a><br /></p>
<p>4.最大的资料自然就是Bullet的<a id="bvc-" title="源代码" href="http://code.google.com/p/bullet/downloads/list" title="源代码">源代码</a><br />
啦。。。。。。慢慢研究吧。</p>
<h2>参考资料</h2>
<p>
1.<a id="rfia" title="Bullet 2.76 Physics SDK Manual" href="http://bulletphysics.com/ftp/pub/test/physics/Bullet_User_Manual.pdf" title="Bullet 2.76 Physics SDK Manual">Bullet 2.76 Physics SDK Manual</a><br />
，Bullet的项目发起人，目前的负责人Erwin Coumans所写，（就WIKI资料显示，这哥们现在在SONY)算是官方的Manual了，源码包中就有pdf。</p>
<p>2.<a id="cmel" title="Bullet WIKI Tutorial Articles" href="http://bulletphysics.org/mediawiki-1.5.8/index.php/Tutorial_Articles" title="Bullet WIKI Tutorial Articles">Bullet WIKI Tutorial Articles</a><br />
，算是第2个能够找到的稍微好点的关于Bullet的东西了，就是有点散乱。</p>
<p align="left">3.<a id="ivvp" title="Bullet Bullet Documentation" href="http://bulletphysics.com/Bullet/BulletFull/" title="Bullet Bullet Documentation">Bullet Bullet Documentation</a><br />
，Bullet的文档，自动生成的，也就只能在写代码的时候可能有些用，很难靠这个学习。</p>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<h2>我写的关于Bullet的文章</h2>
<p>
1.<a id="n_7j" title="Ogre与Bullet的整合(on iPhone)" href="http://www.jtianling.com/archive/2010/10/09/5928695.aspx" title="Ogre与Bullet的整合(on iPhone)">Ogre与Bullet的整合(on iPhone)</a><br /></p>
<p>2.<a id="u0nf" title="Ogre的3D Max插件介绍" href="http://www.jtianling.com/archive/2010/10/09/5930269.aspx" title="Ogre的3D Max插件介绍">Ogre的3D Max插件介绍</a></p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;">最后，因为本文较长，为方便查看，提供了<a href="http://bullet-sample.jtianling.googlecode.com/hg/bullet-not-complete-guide.pdf">pdf版</a><br />
方便大家查看。</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: right;">&nbsp;</p>
<p style="text-align: right;">原创文章作者保留版权 转载请注明原作者 并给出链接</p>
<p style="text-align: right;"><strong><a href="http://www.jtianling.com">write by 九天雁翎(JTianLing) -- www.jtianling.com</a><br />
</strong></p>
<p>&nbsp;</p>
