---
layout: post
title: C#特性杂谈
categories:
- C#
tags:
- C#
status: publish
type: post
published: true
meta:
  mkd_text: "看到题目不要误解, 我不是要教唆广大的C++程序员放下他们正在使用的顺手语言, 都去使用C#, 那自然是自找没趣, 被口水淹死.  本文只是我作为一个从C++开始接触编程的程序员,
    开始正式认真的学习C#的一些记录. 事实上, 因为我还学过一点其他的语言, 我会从这些语言的角度看看C#到底是有多好, 好在哪.  并且因为我没有那么多的时间去慢慢学习,
    真正的学习可能会在项目开始以后, 所以记录不可能完整, 希望不要因为这个而让C#爱好者有意见.  \n\n$TOC$\n\n# 为什么学习C#\n虽然对Anders
    Hejlsberg很有好感, 但是对C#一直不感冒, 所以一直没有真的接触过C#, 甚至在以前的Unity3d项目中坚持使用Javascript.  现在机会又来了,
    又要开始一个Unity3d项目, 在Ruby都学了的今天, 还是抛开成见, 好好学习一下C#吧.  \nC#也的确不是当年那种微软, Windows独占的语言了,
    [*mono*](http://www.mono-project.com/)项目已经将C#移植到了Mac和Linux上, 甚至还包括iOS和Android.
    也就是说, 假如你愿意的话, 你可以使用C#通吃所有平台, 当然, 前提是你能接受巨贵的授权费用.   作为什么事情都喜欢自己搞一套的微软,(因为他都是垄断的)
    在C#这件事情上一开始就很开放(因为有JAVA在前), 总算是做对了一件事情.  \n\n# 我看的书\n鉴于[*C#程序设计语言*][]这本Anders写的书就像是语言规格说明,
    我决定阅读[*C#入门经典*][](Beginning Visual C# 2010).   说实话, 看到这本书的时候, 我稍微叹了口气, 起码比那本厚如砖头的[*JAVA编程思想*][]要薄啊.
    \ 然后, 我再看了一下, 其实我只需要阅读第一部分, 也就是介绍C#的那一部分, 一共才390面.  哈雷路亚...相对比[*C程序设计语言*]的200来面,
    似乎还可以接受啊.  突然对C#有了一些好感.  \n\n# 我用的环境\n离开Windows太久了, 上次我想回去琢磨下VS2012对C++ 11的支持,
    发现在Windows下我的Vim配置都是个问题, 有些烦, 所以想在Mac下来学习, 可惜了VS2012这个好的IDE.  而Mono Developer有些很神奇的问题,
    那就是stable release crash的让我崩溃, 最后安装了最新的beta版本, 到目前为止还可以接受.  \n\n# Hello World\nMono在创建一个名为test的console的工程后,
    给了我一个Hello World的代码, \n\n    :::C#\n    using System;\n\n    namespace test\n
    \   {\n      class MainClass\n      {\n        public static void Main (string[]
    args)\n        {\n          Console.WriteLine (\"Hello World!\");\n        }\n
    \     }\n    }\n\n第一眼看去, 就知道C#中了JAVA的毒了, 用所谓完全面向对象的方式, 强迫你写一堆臃肿而无用的代码... 我至今也没有明白为什么Main函数最后会变成Main类,
    也没有明白这有什么好处...  想起最近看的一篇文章[*Why Java Sucks and C# Rocks*](http://blog.zhaojie.me/2010/04/why-java-sucks-and-csharp-rocks-1-thoughts-and-goals.html),
    说\"自从C# 1.0诞生之日起，就只出现Java借鉴C#特性的情况\", 以此来驳斥JAVA一派对C#抄袭的指责.  其实, 光是从Hello World都能看出来C#对JAVA的模仿,
    他的言论也的确是避重就轻了, 因为, 连他也无法否认C#诞生前及诞生过程中发生的事情...  \n\n值得一提的是, C#对传统的`printf`进行了改进,
    `{0}`形式的占位符不需要表明类型, 只按照数量和位置匹配.  \n\n# 变量与表达式\n\n1. C#没有像JAVA一样把无符号类型给去掉, 这点我觉得有些不可思议.
    \ 在C++新的使用倾向中都已经尽量的去使用有符号的类型了, 除非是进行位运算.  \n2. 变量的声明方式和C/C++一致, 为`type name;`的形式.
    \ \n3. 有++自增操作符, 本来很正常的事情, 但是因为最近老是在用Python和Ruby, 看到这个竟然有些亲切.  \n4. 基础数值变量没有JAVA或者Objective-C那种对应的类,
    直接就是对象, 这个的确比较人性化.  虽然是很小的改进.  简单的说就是C#中类似整数类型的变量可以直接存储到类似List等只能存储对象的容器中去.  JAVA,
    Objective-C需要借助对应的辅助类才行, 因为类似整数类型的变量并不是真的对象.  \n5. 增加了checked, unchecked(默认)关键字来应付类型转换时的溢出问题.
    \ 比如下面的代码:  \n    \n    :::C#\n    short source = 257;\n    byte dest = (byte)source;\n\n上面的代码在转换时会发生溢出,
    这往往不是我们要的结果, 也往往因此出现莫名而难以调试的bug.  而类似下面的代码会在运行时会抛出`System.OverflowException: Number
    overflow.`异常.  这个方案很值得欣赏.  简单有效.  \n6. 枚举可以指定基本类型, 但是本身还是强类型的, 只能强制转换, 不能默认转换.\n7.
    变量的类型还是分为引用类型和值类型, 这个算是为了效率而向易用性的妥协.\n\n\n# 流程控制\n\n1. 保留了goto.\n2. 有foreach循环,
    这个是在C++时代我羡慕的语法糖, 不过现在也不稀奇了.  \n\n\n# 数组\n\n1. 从0开始计数.  越界访问抛异常`System.IndexOutOfRangeException`,
    这似乎是C++以后语言的标配了.  \n2. 本身带Length表示长度, 标配, 这个在意料之中了.  \n\n# 函数\n\n1. 看到了引用参数关键字`ref`,
    也算结束了JAVA中痛苦的经历.  在JAVA中都是*pass by value*, 连一个简单的swap函数都不能直接实现.  还得通过一个构建一个数组来实现,
    都不知道怎么想的.   \n2. 新增输出参数关键字`out`, 与`ref`类似, 有以下区别:\n\n  1. 把为赋值的变量用作ref参数是非法的,
    但是可以把未赋值的变量用作out参数.  \n  2. out参数在函数中使用时, 必须看作时未赋值的.  \n\n3. \n\n# 结构\n\n1. 结构在C#中被弱化,
    也的确应该.\n\n# 委托(delegate)\n这算是接触到的第一个较新的概念, 多写一点.  \ndelegate是Objective-C里面用的非常多的概念,
    有很方便的一面, 但是是在类这个层次上的概念.  \nC#的委托更加想是Objective-C的SEL/@selector和C++ 11的function,
    也就是为了方便函数调用(特别是回调函数)和构建高阶函数而存在的.  这个也是函数不是第一类值(first class)的语言里面需要解决的问题.  函数指针有人说很方便,
    但是那个语法实在太逆天了.  当然, 因为这个原因, 其实C#的委托也无法实现直接对`<, >, +, -`等操作符的控制, 而是需要用类似C++的方法提供辅助函数的方法来完成.
    \ \n\nC#的委托:\n\n    ::C#\n    using System;\n\n    namespace test\n    {\n      class
    MainClass\n      {\n        delegate int Actor (int leftParam, int rightParam);\n\n
    \       static int Call (Actor fun, int leftParam, int rightParam)\n        {\n
    \         return fun(leftParam, rightParam);\n        }\n\n        static int
    Multiply (int leftParam, int rightParam)\n        {\n          return leftParam
    * rightParam;\n        }\n\n        static int Divide (int leftParam, int rightParam)\n
    \       {\n          return leftParam / rightParam;\n        }\n        public
    static void Main (string[] args)\n        {\n          Console.WriteLine (\"{0}\",
    Call(new Actor(Multiply), 10, 10));\n          Console.WriteLine (\"{0}\", Call(new
    Actor(Divide), 10, 10));\n          Console.ReadKey();\n        }\n      }\n    }\n
    \   \n\n# 异常\n传统的try, catch, finally模式.\n\n# 面向对象部分\n主要有价值的特性都在这一部分.\n\n## 类\n\n1.
    默认每个类都继承于基类System.Object.  \n2. 每个类分为*internal*(默认)和*public*, 需要一个类被外部访问的话, 需要定义为public.
    \ 这是为了支持高层次的组件概念.  可访问性只能越来越小, 不能越来越大, 即*internal*类可以继承*public*类, 反过来不行.  \n3.
    用*abstract*关键字支持抽象类的概念, 比C++中奇怪的`=0`的语法要好的多.  抽象类本身不能生成实例, 需要被继承后使用.  \n4. 新增了一个*sealed*关键字,
    直接支持禁止继承的概念.  类似JAVA中的final类.  \n\n### 构造函数初始化器\n支持类似C++初始化列表的构造函数初始化器, 用于调用基类的特殊构造函数(用`base`),
    或者本身的其他构造函数(用`this`).  \n\n## 接口\n支持类似JAVA的接口.  \n继承时没有使用`extends`, `implement`等关键字,
    要求实现继承的基类放在第一个位置, 接口都放在后面即可.  类似下面的语法:\n\n    :::C#\n    public class MyClass
    : MyBase, IMyInterface1, IMyInterface2\n    {\n      // class members\n    }\n\n也就是说,
    C#的继承体系基本上和JAVA一样, 只允许面向接口(规格)的多重继承, 不允许面向实现的多重继承.  这样好不好就见仁见智了(可参考[*多重继承不好的观点是错误的*](/articles/1998.html)一文),
    不过基本可以肯定的是, 的确要比C++要好.  \n\n## 可删除对象\n虽然C#有垃圾回收机制, 但是大家都知道, 自动的垃圾回收机制使得程序员对内存及资源的掌握变弱了,
    C#使用*可删除对象*来解决这个问题, 提供了一个IDisposable接口, 限定必须实现`Dispose()`接口(相当于手动调用的析构函数, 而不是垃圾回收机制自动调用的析构函数),
    很有意思, 这个时候的用法就很类似C++了.\n\n    :::C#\n    using System;\n\n    namespace test\n
    \   {\n      class MainClass\n      {\n        class NeedDispose : IDisposable
    {\n\n          public NeedDispose() {\n            Console.WriteLine(\"Constructing\");\n
    \         }\n\n          public void Dispose ()\n          {\n            Console.WriteLine(\"I'm
    Disposed\");\n          }\n        }\n        public static void Main (string[]
    args)\n        {\n          NeedDispose dispose = new NeedDispose();\n\n          dispose.Dispose();\n
    \       }\n      }\n    }\n    \n到这儿不算完, 都要手动调用的话, 那还不如C++那样出了对象存活范围就自动析构的对象,
    于是多了个using的用法, 基本实现了C++使用对象的方式对资源的管理.  \n\n    :::C#\n    // 语法一:\n    using (NeedDispose
    dispose = new NeedDispose())\n    {\n    }\n\n    // 语法二:\n    NeedDispose dispose
    = new NeedDispose();\n    using (dispose) \n    {\n    }\n\n不过有点比较奇怪的是, 两种语法形式上有区别,
    但是本质上竟然一样, 语法一的定义在出了using的scope以后竟然还有效, 也就是说, 上面那两种语句同时在一个scope中出现时, 会出现dispose的重定义冲突,
    这个设计很奇怪.  \n    \n\n\n\n\n\n# 最后\n结论是, 假如我不知道C#的那些高级特性, 那么我把C#当作C++来用几乎没有任何问题,
    而那些高级特性, 完全可以逐步的尝试.  而且JAVA和C#等语言的的确是进步了, 进步的方式就是把C++好的习惯用法, 编程规范和最佳实践, 直接变成语言特性(除了那所谓的完全面向对象).
    \ 当然, 加入新特性时, 要比那个该死的委员会效率要高的多.  \n\n\n\n\n\n<div style=\"text-align:right\">\n
    \ writen&nbsp;by <a href=\"http://www.jtianling.com\" target=\"_blank\">九天雁翎(JTianLing)
    -- www.jtianling.com</a>\n</div>\n\n[*C程序设计语言*]: http://www.amazon.cn/gp/product/B0011425T8/ref=as_li_ss_tl?ie=UTF8&tag=jtianlinsblog-23&linkCode=as2&camp=536&creative=3132&creativeASIN=B0011425T8\n[*C#入门经典*]:
    http://www.amazon.cn/gp/product/B004EPZ43A/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B004EPZ43A&linkCode=as2&tag=jtianlinsblog-23\n[*JAVA编程思想*]:
    http://www.amazon.cn/gp/product/B0011F7WU4/ref=as_li_ss_tl?ie=UTF8&camp=536&creative=3132&creativeASIN=B0011F7WU4&linkCode=as2&tag=jtianlinsblog-23\n[*C#程序设计语言*]:
    http://www.amazon.cn/gp/product/B005FOV7IK/ref=as_li_ss_tl?ie=UTF8&tag=jtianlinsblog-23&linkCode=as2&camp=536&creative=3132&creativeASIN=B005FOV7IK
    \n\n1."
  views: '236'
  _aioseop_title: C#特性杂谈
author:
  login: jtianling
  email: jtianling@gmail.com
  display_name: jtianling
  first_name: ''
  last_name: ''
---
<p>文中充满了各种C#与我会的语言的对比及吐槽, 希望介意者勿观... 当然, 鉴于太乱, 我怀疑有没有人能看完.  </p>
<div class="toc">
<ul>
<li><a href="#c">学习C#</a></li>
<li><a href="#hello-world">Hello World</a></li>
<li><a href="#_1">变量与表达式</a>
<ul>
<li><a href="#_2">动态类型</a></li>
<li><a href="#_3">值类型和引用类型</a></li>
<li><a href="#checked">checked支持的受限强制转换</a></li>
</ul>
</li>
<li><a href="#_4">流程控制</a></li>
<li><a href="#_5">数组</a></li>
<li><a href="#_6">函数</a>
<ul>
<li><a href="#_7">可选参数</a></li>
<li><a href="#_8">命名参数</a></li>
<li><a href="#delegate">委托(delegate)</a></li>
<li><a href="#lambda">匿名函数(Lambda)</a></li>
</ul>
</li>
<li><a href="#_9">异常</a></li>
<li><a href="#_10">面向对象部分</a>
<ul>
<li><a href="#_11">类</a>
<ul>
<li><a href="#_12">构造函数初始化器</a></li>
<li><a href="#_13">访问器</a></li>
<li><a href="#_14">可访问性传递原则</a></li>
<li><a href="#_15">匿名类</a></li>
<li><a href="#_16">扩展方法</a></li>
</ul>
</li>
<li><a href="#_17">接口</a>
<ul>
<li><a href="#_18">显示实现接口成员</a></li>
</ul>
</li>
<li><a href="#_19">可删除对象</a></li>
</ul>
</li>
<li><a href="#_20">结构</a></li>
<li><a href="#_21">泛型</a>
<ul>
<li><a href="#_22">约束类型</a></li>
<li><a href="#_23">可空变量</a></li>
</ul>
</li>
<li><a href="#_24">事件</a></li>
<li><a href="#_25">最后</a></li>
</ul>
</div>
<h1 id="c">学习<strong>C#</strong></h1>
<p>C#也的确不是当年那种微软, Windows独占的语言了, <a href="http://www.mono-project.com/"><em>mono</em></a>项目已经将C#移植到了Mac和Linux上, 甚至还包括iOS和Android. 也就是说, 假如你愿意的话, 你可以使用C#通吃所有平台, 当然, 前提是你能接受巨贵的授权费用.   作为什么事情都喜欢自己搞一套的微软,(因为他都是垄断的) 在C#这件事情上一开始就很开放(因为有JAVA在前), 总算是做对了一件事情.  </p>
<h1 id="hello-world">Hello World</h1>
<p>Mono在创建一个名为test的console的工程后, 给了我一个Hello World的代码, </p>
<div class="codehilite">
<pre><span class="n">using</span> <span class="n">System</span><span class="p">;</span>

<span class="n">namespace</span> <span class="n">test</span>
<span class="p">{</span>
  <span class="n">class</span> <span class="n">MainClass</span>
  <span class="p">{</span>
    <span class="n">public</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">Main</span> <span class="p">(</span><span class="n">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span> <span class="p">(</span><span class="s">&quot;Hello World!&quot;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>
<p>第一眼看去, 就知道C#中了JAVA的毒了, 用所谓完全面向对象的方式, 强迫你写一堆臃肿而无用的代码... 我至今也没有明白为什么Main函数最后会变成Main类, 也没有明白这有什么好处...  想起最近看的一篇文章<a href="http://blog.zhaojie.me/2010/04/why-java-sucks-and-csharp-rocks-1-thoughts-and-goals.html"><em>Why Java Sucks and C# Rocks</em></a>, 说"自从C# 1.0诞生之日起，就只出现Java借鉴C#特性的情况", 以此来驳斥JAVA一派对C#抄袭的指责.  其实, 光是从Hello World都能看出来C#对JAVA的模仿, 他的言论也的确是避重就轻了, 因为, 连他也无法否认C#诞生前及诞生过程中发生的事情...  </p>
<p>值得一提的是, C#对传统的<code>printf</code>进行了改进, <code>{0}</code>形式的占位符不需要表明类型, 只按照数量和位置匹配.  </p>
<h1 id="_1">变量与表达式</h1>
<ol>
<li>C#没有像JAVA一样把无符号类型给去掉, 这点我觉得有些不可思议.  在C++新的使用倾向中都已经尽量的去使用有符号的类型了, 除非是进行位运算.  </li>
<li>变量的声明方式和C/C++一致, 为<code>type name;</code>的形式.  </li>
<li>有++自增操作符, 本来很正常的事情, 但是因为最近老是在用Python和Ruby, 看到这个竟然有些亲切.  </li>
<li>枚举可以指定基本类型, 但是本身还是强类型的, 只能强制转换, 不能默认转换.  </li>
<li>有类似C++ 11 <code>auto</code>的类型推理关键字<code>var</code>.  可以极大的简化我们的生活~~~  </li>
</ol>
<h2 id="_2">动态类型</h2>
<p>大家都知道类似C/C++, JAVA, C#这种对效率还稍微有些追求的语言都是静态类型语言, 并且靠编译期静态类型检查来排查错误, 而从C++以后, 各语言都以更加'真正的'强类型自豪.  而类似<code>auto</code>, <code>var</code>等自动类型推导的变量只不过是语法糖而已, 所以当我看到C#的确提供了动态类型<code>dynamic</code>, 我还是着实吃了一惊.  这也体现了C#的设计者们比C++, JAVA更加激进的一面.  很多年前, BS就说过(其实Mats也说过类似的), 语言不是一堆特性的堆积, 也不是说堆积的越多就越好.  因为, 很多时候JAVA, C#的拥护者们炫耀着JAVA, C#有着什么样的新特性的时候, 其实并不太感冒.  但是, 这一个, 够让人震撼的.  一个静态语言里面有动态类型会是什么效果? 不禁想让人尝试一番.   </p>
<div class="codehilite">
<pre><span class="n">public</span> <span class="k">static</span> <span class="n">dynamic</span> <span class="nf">Add</span><span class="p">(</span><span class="n">dynamic</span> <span class="n">var1</span><span class="p">,</span> <span class="n">dynamic</span> <span class="n">var2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">var1</span> <span class="o">+</span> <span class="n">var2</span><span class="p">;</span>
<span class="p">}</span>
</pre>
</div>
<p>类似上面的<code>Add</code>功能, 本来必须使用模版才能实现, <code>var</code>使用时, 因为是类型推导, 所以必须在初始化时才能使用, 不能用于函数参数, 而真正的动态类型<code>dynamic</code>就可以.  最近使用Python, Ruby比较多, 突然感觉C#有种Python, Ruby上身的感觉.  </p>
<h2 id="_3">值类型和引用类型</h2>
<p>当我看到<a href="http://blog.zhaojie.me/2010/04/why-java-sucks-and-csharp-rocks-2-primitive-types-and-object-orientation.html"><em>Why Java Sucks and C# Rocks（2）：基础类型与面向对象</em></a>一文时, 我还以为C#真的已经是所谓的"完全面向对象"了.  所以当我看到<a href="http://www.amazon.cn/gp/product/B004EPZ43A/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;creative=3132&amp;creativeASIN=B004EPZ43A&amp;linkCode=as2&amp;tag=jtianlinsblog-23"><em>C#入门经典</em></a>书中写到变量的类型还是分为引用类型和值类型时, 我相当意外.(我先看的那一系列文章, 再看的<a href="http://www.amazon.cn/gp/product/B004EPZ43A/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;creative=3132&amp;creativeASIN=B004EPZ43A&amp;linkCode=as2&amp;tag=jtianlinsblog-23"><em>C#入门经典</em></a>)  等我看到书中写到封箱和拆箱的时候, 就更加惊讶了... 都是一个对象, 为啥还要封箱和拆箱呢? 当然, 鉴于Objective-C连自动的封箱和拆箱都还没有, 我也不能说这就有多么落后. <br />
不过, 我用C++的时候就完全没听说过封箱和拆箱的概念, 容器的设计完全可以容纳基础数值, 为啥到了Objective-C, JAVA和C#里反而不行了呢? 因为C++没有统一的基类? 容器设计的时候就压根不是光考虑存储啥Object对象的.  这个倒是让我想起一句话, 你以为你解决了一个问题, 因为你比以前更加优美了, 但是同时带来了另外一个问题, 后来, 你们比较的是后一个问题谁更优美的解决了.  而这个问题本来并不存在...<br />
另外, 当你其实还分值类型和引用类型的时候, 你就已经输给Python, Ruby了, 何必还讨论谁的箱子更好看呢... 要把这个问题上升到理念层次, 我更加就没法认同了.  </p>
<h2 id="checked">checked支持的受限强制转换</h2>
<p>增加了checked, unchecked(默认)关键字来应付类型转换时的溢出问题.  比如下面的代码:  </p>
<div class="codehilite">
<pre><span class="kt">short</span> <span class="n">source</span> <span class="o">=</span> <span class="mi">257</span><span class="p">;</span>
<span class="n">byte</span> <span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="n">byte</span><span class="p">)</span><span class="n">source</span><span class="p">;</span>
</pre>
</div>
<p>上面的代码在转换时会发生溢出, 这往往不是我们要的结果, 也往往因此出现莫名而难以调试的bug.  而类似下面的代码会在运行时会抛出<code>System.OverflowException: Number overflow.</code>异常.  这个方案很值得欣赏.  简单有效.  </p>
<h1 id="_4">流程控制</h1>
<ol>
<li>保留了goto.</li>
<li>有foreach循环, 这个是在C++时代我羡慕的语法糖, 不过现在也不稀奇了.  </li>
</ol>
<h1 id="_5">数组</h1>
<ol>
<li>从0开始计数.  越界访问抛异常<code>System.IndexOutOfRangeException</code>, 这似乎是C++以后语言的标配了.  </li>
<li>本身带Length表示长度, 标配, 这个在意料之中了.  </li>
</ol>
<h1 id="_6">函数</h1>
<ol>
<li>看到了引用参数关键字<code>ref</code>, 也算结束了JAVA中痛苦的经历.  在JAVA中都是<em>pass by value</em>, 连一个简单的swap函数都不能直接实现.  还得通过一个构建一个数组来实现, 都不知道怎么想的.   </li>
<li>新增输出参数关键字<code>out</code>, 与<code>ref</code>类似, 有以下区别:  </li>
<li>把为赋值的变量用作ref参数是非法的, 但是可以把未赋值的变量用作out参数.  </li>
<li>out参数在函数中使用时, 必须看作时未赋值的.  </li>
</ol>
<h2 id="_7">可选参数</h2>
<p>实际上就等于C++里面的参数默认值, 在有默认值时, 在函数最后的参数为可选.  看书中说C#是在C#4后才支持, 为啥呢?</p>
<h2 id="_8">命名参数</h2>
<p>命名参数在动态语言里面是很常见的, 并且是个容易理解又很使用的功能.  但是C++并没有支持, 看BS在<a href="http://www.amazon.cn/gp/product/B007JFSCPY/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;creative=3132&amp;creativeASIN=B007JFSCPY&amp;linkCode=as2&amp;tag=jtianlinsblog-23"><em>C++语言的设计与演化</em></a>中讲到其实当时有过讨论, 只是因为在C++中有所谓的接口与实现分离, 而看以前的代码, 很多接口(头文件)使用的参数名和实现中用的参数名并不一样, 所以这个有用的特性并没有加入C++.  这也是为什么我前面说接口与实现分离实在是太不DRY的一个原因.<br />
当时BS给的例子是用Win32 API创建windows的代码(因为书在同事那里, 记忆不准确请指出), 因为需要的参数实在是太多了.  非常的不方便, 见MSDN:</p>
<div class="codehilite">
<pre><span class="n">HWND</span> <span class="n">WINAPI</span> <span class="n">CreateWindow</span><span class="p">(</span>
    <span class="n">_In_opt_</span>  <span class="n">LPCTSTR</span> <span class="n">lpClassName</span><span class="p">,</span>
    <span class="n">_In_opt_</span>  <span class="n">LPCTSTR</span> <span class="n">lpWindowName</span><span class="p">,</span>
    <span class="n">_In_</span>      <span class="n">DWORD</span> <span class="n">dwStyle</span><span class="p">,</span>
    <span class="n">_In_</span>      <span class="kt">int</span> <span class="n">x</span><span class="p">,</span>
    <span class="n">_In_</span>      <span class="kt">int</span> <span class="n">y</span><span class="p">,</span>
    <span class="n">_In_</span>      <span class="kt">int</span> <span class="n">nWidth</span><span class="p">,</span>
    <span class="n">_In_</span>      <span class="kt">int</span> <span class="n">nHeight</span><span class="p">,</span>
    <span class="n">_In_opt_</span>  <span class="n">HWND</span> <span class="n">hWndParent</span><span class="p">,</span>
    <span class="n">_In_opt_</span>  <span class="n">HMENU</span> <span class="n">hMenu</span><span class="p">,</span>
    <span class="n">_In_opt_</span>  <span class="n">HINSTANCE</span> <span class="n">hInstance</span><span class="p">,</span>
    <span class="n">_In_opt_</span>  <span class="n">LPVOID</span> <span class="n">lpParam</span>
    <span class="p">);</span>
</pre>
</div>
<p>事实上, 在Win32 API里面, 你要完整的创建一个窗口, 还有类似注册窗口类等巨多参数的接口, 而其实在这个API里面, 每次调用时真正需要使用的又并不是所有的参数, 不用说有多不方便了.  可选参数(参数默认值), 只能在参数列表的最后使用, 让这种简化有的时候变成了一个排序游戏, 到底哪个参数才是最不常用的呢?<br />
BS给了在C++里面我们的一种解决方案, 这种方案也是我们在实际中使用的方案, 那就是用<code>struct</code>, 当<code>struct</code>成员变量都有默认值的时候, 我们就只需要给我们真正需要的那个变量赋值即可.  具体的情况就不多说了, 书上都有, 但是在有命名参数后这些都是浮云.  你只需要给你的确需要的参数赋值即可, 也不需要额外的创建类或结构.  比如上例, 有了命名参数后, 我假如只对窗口的宽度感兴趣, 那么如下调用即可:</p>
<div class="codehilite">
<pre><span class="n">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">CreateWindow</span> <span class="p">(</span>
  <span class="kt">int</span> <span class="n">lpClassName</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">lpWindowName</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">dwStyle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">nWidth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">nHeight</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">hWndParent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">hMenu</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">hInstance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
  <span class="kt">int</span> <span class="n">lpParam</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

    <span class="n">public</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">Main</span> <span class="p">(</span><span class="n">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">CreateWindow</span><span class="p">(</span><span class="n">nWidth</span><span class="o">:</span> <span class="mi">640</span><span class="p">,</span> <span class="n">nHeight</span><span class="o">:</span> <span class="mi">960</span><span class="p">);</span>
<span class="p">}</span>
</pre>
</div>
<p>还有比这更方便的事情吗? 顺面吐槽一句, Objective-C里面函数调用的方式简直就是为命名参数准备的, 当然竟然完全不支持命名参数, 甚至不支持参数默认值, 崩溃啊...  </p>
<h2 id="delegate">委托(delegate)</h2>
<p>这算是接触到的第一个较新的概念, 多写一点.<br />
delegate是Objective-C里面用的非常多的概念, 有很方便的一面, 但是是在类这个层次上的概念.<br />
C#的委托更加想是Objective-C的SEL/@selector和C++ 11的function, 也就是为了方便函数调用(特别是回调函数)和构建高阶函数而存在的.  这个也是函数不是第一类值(first class)的语言里面需要解决的问题.  函数指针有人说很方便, 但是那个语法实在太逆天了.  当然, 因为这个原因, 其实C#的委托也无法实现直接对<code>&lt;, &gt;, +, -</code>等操作符的控制, 而是需要用类似C++的方法提供辅助函数的方法来完成.  </p>
<p>C#的委托:</p>
<div class="codehilite">
<pre><span class="n">using</span> <span class="n">System</span><span class="p">;</span>

<span class="n">namespace</span> <span class="n">test</span>
<span class="p">{</span>
  <span class="n">class</span> <span class="n">MainClass</span>
  <span class="p">{</span>
    <span class="n">delegate</span> <span class="kt">int</span> <span class="n">Actor</span> <span class="p">(</span><span class="kt">int</span> <span class="n">leftParam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rightParam</span><span class="p">);</span>

    <span class="k">static</span> <span class="kt">int</span> <span class="nf">Call</span> <span class="p">(</span><span class="n">Actor</span> <span class="n">fun</span><span class="p">,</span> <span class="kt">int</span> <span class="n">leftParam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rightParam</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="n">leftParam</span><span class="p">,</span> <span class="n">rightParam</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">int</span> <span class="nf">Multiply</span> <span class="p">(</span><span class="kt">int</span> <span class="n">leftParam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rightParam</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">leftParam</span> <span class="o">*</span> <span class="n">rightParam</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">int</span> <span class="nf">Divide</span> <span class="p">(</span><span class="kt">int</span> <span class="n">leftParam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rightParam</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">leftParam</span> <span class="o">/</span> <span class="n">rightParam</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">public</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">Main</span> <span class="p">(</span><span class="n">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span> <span class="p">(</span><span class="s">&quot;{0}&quot;</span><span class="p">,</span> <span class="n">Call</span><span class="p">(</span><span class="n">new</span> <span class="n">Actor</span><span class="p">(</span><span class="n">Multiply</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
      <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span> <span class="p">(</span><span class="s">&quot;{0}&quot;</span><span class="p">,</span> <span class="n">Call</span><span class="p">(</span><span class="n">new</span> <span class="n">Actor</span><span class="p">(</span><span class="n">Divide</span><span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
      <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>
<h2 id="lambda">匿名函数(Lambda)</h2>
<p>有匿名函数的语言才算是现代语言啊... 我说这句话, C++, JAVA, Objective-C, C#无一中枪, 不管是加入的早晚(其实都是较晚), 上述语言都已经有了使用匿名函数的办法.  对于Python, Ruby来说, 匿名函数就更不是什么新鲜事物了.  比较有意思的是, 作为静态语言的新事物, 上述语言都独立的发展了一套自己的Lambda语法, 而且各有特色, 并且最终的目的似乎都是让你搞不明白.  C#的Lambda使用了<code>=&gt;</code>来标记.  因为可以使用类型推导, 所以语法的简洁性上可以做到极致.<br />
参考上面委托的例子, 假如Multiply和Divide我们只是使用一次的话, 还按上面的形式定义就太麻烦了, 匿名函数可以简化代码.  </p>
<div class="codehilite">
<pre><span class="n">class</span> <span class="n">MainClass</span>
<span class="p">{</span>
  <span class="n">delegate</span> <span class="kt">int</span> <span class="n">Actor</span> <span class="p">(</span><span class="kt">int</span> <span class="n">leftParam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rightParam</span><span class="p">);</span>

  <span class="k">static</span> <span class="kt">int</span> <span class="nf">Call</span> <span class="p">(</span><span class="n">Actor</span> <span class="n">fun</span><span class="p">,</span> <span class="kt">int</span> <span class="n">leftParam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rightParam</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="n">leftParam</span><span class="p">,</span> <span class="n">rightParam</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">public</span> <span class="k">static</span> <span class="kt">void</span> <span class="nf">Main</span> <span class="p">(</span><span class="n">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span> <span class="p">(</span><span class="s">&quot;{0}&quot;</span><span class="p">,</span> <span class="n">Call</span><span class="p">((</span><span class="n">leftParam</span><span class="p">,</span> <span class="n">rightParam</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="k">return</span> <span class="n">leftParam</span> <span class="o">*</span> <span class="n">rightParam</span><span class="p">;</span>
          <span class="p">},</span>
          <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span> <span class="p">(</span><span class="s">&quot;{0}&quot;</span><span class="p">,</span> <span class="n">Call</span><span class="p">((</span><span class="n">leftParam</span><span class="p">,</span> <span class="n">rightParam</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="k">return</span> <span class="n">leftParam</span> <span class="o">/</span> <span class="n">rightParam</span><span class="p">;</span>
          <span class="p">},</span>
          <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">ReadKey</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>
<p>可以看到代码显著的简化, 当然, 其实这里的例子还是太过简单和生造了, 匿名函数最大的应用在于利用闭包特性来作为回调函数.  此时简化的往往不仅仅是一个函数, 甚至是一套完整的类.  而且, 在多个类似回调同时在一个类中使用的时候, 每个匿名函数各自独立, 不会出现需要在类的回调函数中用switch/if-else区分的丑陋代码.  这个回忆回忆以前你用过的任何GUI系统的Button回调, 大概就能理解.  而最佳的例子, 我也常常提起我很感叹的是, 在最近的Objective-C中加入的匿名函数(在Objective-C中被称为Block)对Objective-C接口的巨大影响, 几乎是整体性的对原有<code>delegate</code>的替换.  这个替换过程不仅仅发生在社区, 连Apple官方也是如此.    </p>
<h1 id="_9">异常</h1>
<p>传统的try, catch, finally模式.</p>
<h1 id="_10">面向对象部分</h1>
<p>主要有价值的特性都在这一部分.  我觉得最大的改进就在于C#和JAVA都没有使用C++(还有Objective-C)里面看似优美的接口与实现分离的策略.  很多时候我们都在说DRY(Don't Repeat Yourself)是编程中排在第一的原则, 但是接口与实现分离, 即一个头文件用于声明, 一个实现文件用于实现的方式是彻头彻尾的<em>Repeat</em>.  这种方式就我了解是来自于C语言.  C++和Objective-C都在一定程度上有向C语言兼容的负担, 于是都这样做了.   稍微追求点人性化的语言其实都不是类似C/C++和Objective-C那种方式.  这个序列可以从JAVA, C#一直写到lua, python, ruby, lisp.<br />
这里有个值得探讨的话题, 因为我的确对编译原理什么的不是太了解, 不过大概知道, 实际的我们称的编译过程包括编译(生成.o文件)及链接(生成真正的可执行文件)两个过程, 而接口与实现分离的好处在于, 编译期可以不要求找到实现, 方便单独对每个文件的编译和将实现放在别的文件里面, 直到链接期才真正的匹配.  这也许是早期类C语言(需要直接最后生成机器码)这么设计的根源.  但是, 我还是得说, 那种设计并不好, 并且其实是有办法避免的.  只是可能需要离C远一点, 所以C++和Objective-C都没有用.  更有意思的是, 尽管似乎早就已经有<code>export</code>关键字了, C++还是只能将模版的声明和实现都放在头文件里面, 而我当年, 甚至还觉得模版这么做实在是太不规范了.  当然, 还有<code>inline</code>, 这也是个必须放在头文件里面的家伙.  </p>
<h2 id="_11">类</h2>
<ol>
<li>默认每个类都继承于基类<code>System.Object</code>.  </li>
<li>每个类分为<code>internal</code>(默认)和<code>public</code>, 需要一个类被外部访问的话, 需要定义为<code>public</code>.  </li>
<li>用<code>abstract</code>关键字支持抽象类的概念, 比C++中奇怪的<code>=0</code>的语法要好的多.  抽象类本身不能生成实例, 需要被继承后使用.  </li>
<li>新增了一个<code>sealed</code>关键字, 直接支持禁止继承的概念.  类似JAVA中的final类.  同时也可以对成员函数使用, 表示禁止在子类中被override.  </li>
<li>除了传统的<code>public</code>, <code>protected</code>, <code>private</code>, 多了个<code>internal</code>的访问限制层级, 用于对成员的访问控制.  表示限制为程序集内的代码可以访问(即不是对外开放, 但是对内部的类开放)  </li>
<li>成员内部变量用<code>readonly</code>替代了<code>const</code>.  表示常量.  </li>
<li>继承后对基类方法的override必须用<code>override</code>关键字显式声明.  </li>
<li>类成员也可以通过<code>extern</code>关键字表示由项目外部提供方法的实现代码.  书中说这是高级论题, 没有做详细的描述.  </li>
<li>可通过<code>new</code>关键字显式的隐藏基类成员函数, 此时类似C++中覆盖非虚函数.  只不过, 在C#中, 甚至连基类的虚函数都可以通过<code>new</code>隐藏.  所谓的隐藏与覆盖(override)的区别在于, 隐藏在调用时没有多态性.  </li>
<li>用<code>base</code>调用基类的变量或者函数, 用<code>this</code>调用本身的变量或者函数.   </li>
<li>用<code>partial</code>关键字实现部分类定义, 即可将一个类拆散到多个文件中, 这件事情因为C++的接口与实现分离本来可以很自然的实现, 但是鬼才知道为啥我当年在一个项目中强烈建议把一个超过6k行的Player.cpp文件按逻辑拆开, 会遭到强烈的反对, 认为那样反而会更加麻烦, 虽然我原本的意思仅仅是几乎一行代码不动的拆到几个.cpp文件而已.  其实当一个类写到不得不需要拆开的时候, 这个类本身似乎也已经有些太臃肿了.  </li>
<li><code>is</code>关键字用于判断一个对象的类是否是继承于一个类, 或者就等于这个类.</li>
<li>虽然很多人批评过C++的运算符重载(比如JAVA中就没有), 但是C#似乎原封不动的照搬了.  这个各执一词, 我也不好说什么, 可以滥用, 也的确更方便.  当然, 我是喜欢有的.  </li>
<li><code>as</code>关键字用于实现引用的类型转换, 在转换失败后, 不抛出异常(普通的强制转换就会), 而是返回null.  </li>
</ol>
<h3 id="_12">构造函数初始化器</h3>
<p>支持类似C++初始化列表的构造函数初始化器.  语法也类似.<br />
在新的C#中还支持直接类似C++ 11的统一初始化格式的对象初始化器.  语法如下:  </p>
<div class="codehilite">
<pre><span class="n">namespace</span> <span class="n">test</span>
<span class="p">{</span>
  <span class="n">public</span> <span class="n">class</span> <span class="n">Point</span>
  <span class="p">{</span>
    <span class="n">public</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">{</span><span class="n">get</span><span class="p">;</span> <span class="n">set</span><span class="p">;}</span>
    <span class="n">public</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">{</span><span class="n">get</span><span class="p">;</span> <span class="n">set</span><span class="p">;}</span>
  <span class="p">}</span>

  <span class="n">class</span> <span class="n">MainClass</span>
  <span class="p">{</span>
    <span class="n">public</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">Main</span> <span class="p">(</span><span class="n">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">Point</span> <span class="n">p</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Point</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">};</span>
      <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Point: x={0}, y={1}&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>
<p>其中<code>Point p</code>就是通过上述对象初始化器完成的初始化.  这种方法没有提供一个带完善参数的构造函数使用起来方便, 但是在没有提供类似构造函数的时候.  可以不需要一行一行直接使用定义后的变量来初始化了.  另外, 对于集合来说, 也有类似的语法.  </p>
<h3 id="_13">访问器</h3>
<p>通过get, set关键字来定义属性的访问器, 并且通过忽略其中一个来实现只读和只写.  并且提供了一种自动生成属性的功能, 代码类似<code>public int MyIntProp { get; set;}</code>, 在一行内定义一个属性, 并且不用再定义一个变量, 这个变量由编译器自动生成, 我们不知道它叫什么, 但是能通过访问器提供的方法来访问.    </p>
<h3 id="_14">可访问性传递原则</h3>
<p>可访问性只能越来越严格, 不能越来越放松.  比如<code>internal</code>类可以继承<code>public</code>类, 反过来不行.  访问器的<code>get</code>, <code>set</code>单独设置的访问限制也类似, 只能比统一外部声明的要更加严格.</p>
<h3 id="_15">匿名类</h3>
<p>大家都知道匿名函数好用, 匿名类呢? 有了总比没有好吧.<br />
配合<code>var</code>使用, 语法如下:</p>
<div class="codehilite">
<pre><span class="n">var</span> <span class="n">p</span> <span class="o">=</span> <span class="n">new</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">};</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Point: x={0}, y={1}&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</pre>
</div>
<p>注意, 我其实并没有定义一个Point类.  包含<code>x,y</code>成员变量的类由编译器自动生成.</p>
<h3 id="_16">扩展方法</h3>
<p>在Python, Ruby里面都能很方便的给已存在的类添加方法, 实现打<em>猴子补丁</em>的功能, 类也被称为<em>开放类</em>.  当时静态语言一般不行, C#通过扩展方法实现类似的功能, 只不过语法非常之不优美, 同为静态语言, 建议anders去学习一下Objective-C里面的<em>类别</em>(category), 这种使用在Objective-C中非常的普遍, 因为的确非常的方便.<br />
首先看C#的语法:</p>
<div class="codehilite">
<pre><span class="n">public</span> <span class="k">static</span> <span class="n">class</span> <span class="n">ExtensionString</span>
<span class="p">{</span>
  <span class="n">public</span> <span class="k">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">GetArray</span> <span class="p">(</span>
      <span class="n">this</span> <span class="n">string</span> <span class="n">str</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">new</span> <span class="n">List</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">foreach</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="n">in</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">result</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">class</span> <span class="n">MainClass</span>
<span class="p">{</span>
  <span class="n">public</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">Main</span> <span class="p">(</span><span class="n">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;abcdefg&quot;</span><span class="p">;</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">chars</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">GetArray</span> <span class="p">();</span>

    <span class="n">foreach</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="n">in</span> <span class="n">chars</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Console</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>
<p>上例中, 我给标准的<code>string</code>类增加了一个<code>GetArray</code>的接口, 返回一个<code>List&lt;char&gt;</code>类型的对象.  语法大概的描述如下:</p>
<ol>
<li>静态类</li>
<li>静态函数</li>
<li>函数的第一个参数为this修饰的, 你要增加方法的类型.</li>
</ol>
<p>不知道大家怎么看, 我是觉得有些不太直观和自然.</p>
<h2 id="_17">接口</h2>
<p>支持类似JAVA的接口.  关键字<code>interface</code>.  访问限定永远是public(不然还做接口干啥), 无实现代码, 不定义成员变量.  但是可以定义属性.  并且语法类似自动属性.<br />
继承时没有使用<code>extends</code>, <code>implement</code>等关键字, 要求实现继承的基类放在第一个位置(没有则可以忽略), 接口都放在后面即可.  类似下面的语法:</p>
<div class="codehilite">
<pre><span class="n">public</span> <span class="n">class</span> <span class="n">MyClass</span> <span class="o">:</span> <span class="n">MyBase</span><span class="p">,</span> <span class="n">IMyInterface1</span><span class="p">,</span> <span class="n">IMyInterface2</span>
<span class="p">{</span>
  <span class="c1">// class members</span>
<span class="p">}</span>
</pre>
</div>
<p>也就是说, C#的继承体系基本上和JAVA一样, 只允许面向接口(规格)的多重继承, 不允许面向实现的多重继承.  这样好不好就见仁见智了(可参考<a href="/articles/1998.html"><em>多重继承不好的观点是错误的</em></a>一文), 不过基本可以肯定的是, 的确要比C++不受限制的多重继承要难以滥用.  </p>
<h3 id="_18">显示实现接口成员</h3>
<p>又一个新东西, 在实现类明确的制定一个函数是实现接口的某个函数式, 只能通过接口的多态性来调用该函数, 不允许使用类本身的对象来调用.  这相当于强制接口调用.  </p>
<h2 id="_19">可删除对象</h2>
<p>虽然C#有垃圾回收机制, 但是大家都知道, 自动的垃圾回收机制使得程序员对内存及资源的掌握变弱了, C#使用<em>可删除对象</em>来解决这个问题, 提供了一个IDisposable接口, 限定必须实现<code>Dispose()</code>接口(相当于手动调用的析构函数, 而不是垃圾回收机制自动调用的析构函数), 很有意思, 这个时候的用法就很类似C++了.</p>
<div class="codehilite">
<pre><span class="n">using</span> <span class="n">System</span><span class="p">;</span>

<span class="n">namespace</span> <span class="n">test</span>
<span class="p">{</span>
  <span class="n">class</span> <span class="n">MainClass</span>
  <span class="p">{</span>
    <span class="n">class</span> <span class="n">NeedDispose</span> <span class="o">:</span> <span class="n">IDisposable</span> <span class="p">{</span>

      <span class="n">public</span> <span class="n">NeedDispose</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Constructing&quot;</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="n">public</span> <span class="kt">void</span> <span class="n">Dispose</span> <span class="p">()</span>
      <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;I&#39;m Disposed&quot;</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">public</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">Main</span> <span class="p">(</span><span class="n">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">NeedDispose</span> <span class="n">dispose</span> <span class="o">=</span> <span class="n">new</span> <span class="n">NeedDispose</span><span class="p">();</span>

      <span class="n">dispose</span><span class="p">.</span><span class="n">Dispose</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>
<p>到这儿不算完, 都要手动调用的话, 那还不如C++那样出了对象存活范围就自动析构的对象, 于是多了个using的用法, 基本实现了C++使用对象的方式对资源的管理.  </p>
<div class="codehilite">
<pre><span class="c1">// 语法一:</span>
<span class="n">using</span> <span class="p">(</span><span class="n">NeedDispose</span> <span class="n">dispose</span> <span class="o">=</span> <span class="n">new</span> <span class="n">NeedDispose</span><span class="p">())</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="c1">// 语法二:</span>
<span class="n">NeedDispose</span> <span class="n">dispose</span> <span class="o">=</span> <span class="n">new</span> <span class="n">NeedDispose</span><span class="p">();</span>
<span class="n">using</span> <span class="p">(</span><span class="n">dispose</span><span class="p">)</span> 
<span class="p">{</span>
<span class="p">}</span>
</pre>
</div>
<p>不过有点比较奇怪的是, 两种语法形式上有区别, 但是本质上竟然一样, 语法一的定义在出了using的scope以后竟然还有效, 也就是说, 上面那两种语句同时在一个scope中出现时, 会出现dispose的重定义冲突, 这个设计很奇怪.  </p>
<h1 id="_20">结构</h1>
<ol>
<li>C#把结构设定为值类型, 即赋值时会直接产生值复制(类似整数等基本类型), 而不是产生新的引用.  这让结构有了新的用途.  </li>
<li>结构内的成员函数默认是private的, 这点不像C++.  </li>
<li><code>struct</code>不允许被继承.  </li>
</ol>
<h1 id="_21">泛型</h1>
<p>C#在2.0后才加入了泛型, 作为一门新语言, 不知道这是为啥.  这也是为啥前面提到不知道从哪冒出来的封箱拆箱问题的原因?<br />
泛型容器的好处就是它是强类型的, 对于强类型语言来说, 不提供强类型的容器, 那还叫强类型吗?(行吧, Objective-C躺着中枪了, 它至今还没有泛型)  </p>
<h2 id="_22">约束类型</h2>
<p>这个类似C++中的曾经想要(但是没有)加入C++ 11的特性<a href="http://zh.wikipedia.org/wiki/%E6%A6%82%E5%BF%B5_(C%2B%2B)"><em>concept</em></a>的更通用版本.  相当于给泛型类型一个约束限定, 只允许符合约束条件的模版类型.  这个特性的加入也体现了委员会和公司决定的语言之间的区别.  委员会保守, 公司激进, 而个人? 随意! 参考Python3...  </p>
<div class="codehilite">
<pre><span class="n">interface</span> <span class="n">IMyInterface</span>
<span class="p">{</span>
  <span class="kt">void</span> <span class="n">DoSomeThing</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">class</span> <span class="n">MyClass</span> <span class="o">:</span> <span class="n">IMyInterface</span>
<span class="p">{</span>
  <span class="n">public</span> <span class="kt">void</span> <span class="n">DoSomeThing</span><span class="p">()</span> <span class="p">{</span>

  <span class="p">}</span>
<span class="p">}</span>

<span class="n">class</span> <span class="n">MyGenericClass</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">where</span> <span class="n">T</span> <span class="o">:</span> <span class="n">IMyInterface</span>
<span class="p">{</span>

<span class="p">}</span>

<span class="n">class</span> <span class="n">MainClass</span>
<span class="p">{</span>
  <span class="n">public</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">Main</span> <span class="p">(</span><span class="n">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="c1">// MyGenericClass&lt;int&gt; x = new MyGenericClass&lt;int&gt;();  // compile error</span>
    <span class="n">MyGenericClass</span><span class="o">&lt;</span><span class="n">IMyInterface</span><span class="o">&gt;</span> <span class="n">y</span> <span class="o">=</span> <span class="n">new</span> <span class="n">MyGenericClass</span><span class="o">&lt;</span><span class="n">IMyInterface</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">MyGenericClass</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span> <span class="n">z</span> <span class="o">=</span> <span class="n">new</span> <span class="n">MyGenericClass</span><span class="o">&lt;</span><span class="n">MyClass</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre>
</div>
<p>语法上见上面的代码, 其中被注释掉的那一行会出现编译错误, 因为模版类型T被约束了.  只有<code>IMyInterface</code>及其子类才可以使用<code>MyGenericClass&lt;T&gt;</code>模板类.  </p>
<h2 id="_23">可空变量</h2>
<p>即可以等于null的变.  用类似<code>int?</code>的形式来定义一个可空类型, 实际是<code>System.Nullable&lt;int&gt;</code>类型的缩写. 用<code>??</code>操作符来为可空类型提供默认值.  </p>
<h1 id="_24">事件</h1>
<p>C#的事件本质上就是一种Gof的observer设计模式, 虽然语法上没有用subscribe这些传统概念.  并且因为C#委托的存在, 事件写起来还算是比较方便.  独创的用操作符<code>+=</code>用于表示事件的订阅, 绝对是属于操作符能自定义后被滥用的绝佳例子.  </p>
<h1 id="_25">最后</h1>
<p>结论是, 假如不知道C#的那些高级特性, 那么把C#当作C++来用几乎没有任何问题, 而那些高级特性, 完全可以逐步的尝试.  而且JAVA和C#等语言的的确是进步了, 进步的方式就是把C++好的习惯用法, 编程规范和最佳实践, 直接变成语言特性(除了那所谓的完全面向对象).  一些改动虽然看起来很小, 甚至是语法糖, 但是的确是强制的(或者语言层面鼓励)写更好的代码.<br />
当然, 加入新特性时, 要比那个该死的委员会(虽然BS强调过C++不是委员会设计)效率要高太多了.  这也是我较为欣赏的一点, 也许有人可以说稳定正是C++的好处, 但是在快速变化的互联网时代, '不进则退'啊... 这个话也就只能安慰安慰C++程序员罢了, 市场的丢失是实实在在的.  作为一个从C++入门的程序员, 对此我常常倍感痛心.<br />
本文纯粹是<a href="http://www.amazon.cn/gp/product/B004EPZ43A/ref=as_li_ss_tl?ie=UTF8&amp;camp=536&amp;creative=3132&amp;creativeASIN=B004EPZ43A&amp;linkCode=as2&amp;tag=jtianlinsblog-23"><em>C#入门经典</em></a>关于C#语言部分的阅读记录, 其中牵扯到的各种语言大部分都是凭借我的记忆, 语言过多了总难免记忆混乱, 其中如有错误的之处希望大家能不吝赐教.    </p>
<div style="text-align:right">
  writen&nbsp;by <a href="http://www.jtianling.com" target="_blank">九天雁翎(JTianLing) -- www.jtianling.com</a>
</div>
