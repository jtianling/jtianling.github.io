---
layout: post
title: "《数据结构与算法分析C++描述》 搜索二叉树的C++实现"
categories:
- "算法"
tags:
- C++
- "《数据结构与算法分析C++描述》"
- "二叉树"
status: publish
type: post
published: true
meta:
  ratings_users: '0'
  ratings_score: '0'
  ratings_average: '0'
  views: '14'
author:
  login: jtianling
  email: jtianling@gmail.com
  display_name: jtianling
  first_name: ''
  last_name: ''
---

<p><span style="font-family:宋体"><br />
<span style="color:#365f91; font-size:16pt"><strong>《数据结构与算法分析C++描述》</strong></span><br />
<span style="color:#365f91; font-size:16pt"><strong>搜索二叉树的C++实现</strong></span></span><span style="font-size:16pt"><strong><br />
</strong></span></p>
<p style="text-align: right"><span style="color:#c0504d; text-decoration:underline"><strong>write by <span style="font-family:宋体">九天雁翎</span>(JTianLing) -- www.jtianling.com</strong></span></p>
<p> <br />
 </p>
<p><span style="font-family:宋体">《数据结构与算法分析</span>c++<span style="font-family:宋体">描述》</span> Mark Allen Weiss<span style="font-family:宋体">著</span><br />
<span style="font-family:宋体">人民邮电大学出版</span><br />
<span style="font-family:宋体">中文版第</span>93-100<span style="font-family:宋体">面，搜索二叉树<br />
</span></p>
<p><span style="font-family:宋体">需要说明一点的是，此搜索二叉树并没有平衡算法，所以可能会导致有可能出现O(M logN)的最坏情况。<br />
</span></p>
<p><span style="font-family:宋体">并且几乎所有代码都用递归实现，所以效率并不是太高，并且当N足够大的时候，很多操作都可能导致栈溢出。但是因为对于树的操作用递归描述起来理解上还是比循环好的多，并且以后可以用平衡算法，所以这里都用递归了。<br />
</span></p>
<p>
 </p>
<p><span style="font-family:宋体">搜索二叉树的实现：<br />
</span></p>
<p><span style="font-family:Courier New"><span style="color:#804040">  1 </span><br /><span style="color:#804040">  2 </span><span style="color:#a020f0">#ifndef __BINARY_SEARCH_TREE_H__</span><br /><span style="color:#804040">  3 </span><span style="color:#a020f0">#define __BINARY_SEARCH_TREE_H__</span><br /><span style="color:#804040">  4 </span><br /><span style="color:#804040">  5 </span><span style="color:seagreen"><strong>template</strong></span>&lt;<span style="color:seagreen"><strong>typename</strong></span> T&gt;<br /><span style="color:#804040">  6 </span><span style="color:seagreen"><strong>class</strong></span> CBinarySearchTree<br /><span style="color:#804040">  7 </span>{<br /><span style="color:#804040">  8 <strong>public</strong></span>:<br /><span style="color:#804040">  9 </span>    CBinarySearchTree():mpRoot(<span style="color:fuchsia">NULL</span>) { }<br /><span style="color:#804040"> 10 </span>    CBinarySearchTree(<span style="color:seagreen"><strong>const</strong></span> CBinarySearchTree&amp; aOrig)<br /><span style="color:#804040"> 11 </span>    {<br /><span style="color:#804040"> 12 </span>        mpRoot = Clone(aOrig.mpRoot);<br /><span style="color:#804040"> 13 </span>    }<br /><span style="color:#804040"> 14 </span>    ~CBinarySearchTree()<br /><span style="color:#804040"> 15 </span>    {<br /><span style="color:#804040"> 16 </span>        MakeEmpty();<br /><span style="color:#804040"> 17 </span>    }<br /><span style="color:#804040"> 18 </span><br /><span style="color:#804040"> 19 </span>    <span style="color:blue">////////////////////////////////////////////</span><br /><span style="color:#804040"> 20 </span>    <span style="color:blue">// const member function</span><br /><span style="color:#804040"> 21 </span>    <span style="color:blue">////////////////////////////////////////////</span><br /><span style="color:#804040"> 22 </span>    <span style="color:seagreen"><strong>const</strong></span> T* FindMin() <span style="color:seagreen"><strong>const</strong></span>;<br /><span style="color:#804040"> 23 </span>    <span style="color:seagreen"><strong>const</strong></span> T* FindMax() <span style="color:seagreen"><strong>const</strong></span>;<br /><span style="color:#804040"> 24 </span><br /><span style="color:#804040"> 25 </span>    <span style="color:seagreen"><strong>bool</strong></span> Contains( <span style="color:seagreen"><strong>const</strong></span> T&amp; aElement) <span style="color:seagreen"><strong>const</strong></span>;<br /><span style="color:#804040"> 26 </span>    <span style="color:seagreen"><strong>bool</strong></span> IsEmpty() <span style="color:seagreen"><strong>const</strong></span><br /><span style="color:#804040"> 27 </span>    {<br /><span style="color:#804040"> 28 </span>        <span style="color:#804040"><strong>return</strong></span> (mpRoot != <span style="color:fuchsia">NULL</span>) ? <span style="color:fuchsia">true</span> : <span style="color:fuchsia">false</span>;<br /><span style="color:#804040"> 29 </span>    }<br /><span style="color:#804040"> 30 </span><br /><span style="color:#804040"> 31 </span>    <span style="color:blue">// I don't know how to print it in a good format</span><br /><span style="color:#804040"> 32 </span>    <span style="color:blue">//void PrintTree() const;</span><br /><span style="color:#804040"> 33 </span><br /><span style="color:#804040"> 34 </span>    <span style="color:blue">////////////////////////////////////////////</span><br /><span style="color:#804040"> 35 </span>    <span style="color:blue">// non-const member function</span><br /><span style="color:#804040"> 36 </span>    <span style="color:blue">////////////////////////////////////////////</span><br /><span style="color:#804040"> 37 </span>    <span style="color:seagreen"><strong>void</strong></span> MakeEmpty();<br /><span style="color:#804040"> 38 </span>    <span style="color:seagreen"><strong>void</strong></span> Insert( <span style="color:seagreen"><strong>const</strong></span> T&amp; aElement);<br /><span style="color:#804040"> 39 </span>    <span style="color:seagreen"><strong>void</strong></span> Remove( <span style="color:seagreen"><strong>const</strong></span> T&amp; aElement);<br /><span style="color:#804040"> 40 </span><br /><span style="color:#804040"> 41 </span>    <span style="color:seagreen"><strong>const</strong></span> CBinarySearchTree&amp; <span style="color:#804040"><strong>operator</strong></span>=(<span style="color:seagreen"><strong>const</strong></span> CBinarySearchTree&amp; aOrig);<br /><span style="color:#804040"> 42 </span><br /><span style="color:#804040"> 43 <strong>private</strong></span>:<br /><span style="color:#804040"> 44 </span>    <span style="color:seagreen"><strong>struct</strong></span> CBinaryNode<br /><span style="color:#804040"> 45 </span>    {<br /><span style="color:#804040"> 46 </span>        CBinaryNode(<span style="color:seagreen"><strong>const</strong></span> T&amp; aElement, CBinaryNode* apLeft, CBinaryNode* apRight)<br /><span style="color:#804040"> 47 </span>            : mElement(aElement),mpLeft(apLeft),mpRight(apRight) {  }<br /><span style="color:#804040"> 48 </span><br /><span style="color:#804040"> 49 </span>        T mElement;<br /><span style="color:#804040"> 50 </span>        CBinaryNode *mpLeft;<br /><span style="color:#804040"> 51 </span>        CBinaryNode *mpRight;<br /><span style="color:#804040"> 52 </span>    };<br /><span style="color:#804040"> 53 </span><br /><span style="color:#804040"> 54 </span>    <span style="color:blue">// Root Node</span><br /><span style="color:#804040"> 55 </span>    CBinaryNode *mpRoot;<br /><span style="color:#804040"> 56 </span><br /><span style="color:#804040"> 57 </span>    <span style="color:blue">////////////////////////////////////////////</span><br /><span style="color:#804040"> 58 </span>    <span style="color:blue">// private member function to call recursively</span><br /><span style="color:#804040"> 59 </span>    <span style="color:blue">////////////////////////////////////////////</span><br /><span style="color:#804040"> 60 </span><br /><span style="color:#804040"> 61 </span>    <span style="color:blue">// I don't like to use reference to pointer</span><br /><span style="color:#804040"> 62 </span>    <span style="color:blue">// so I used pointer to pointer instead</span><br /><span style="color:#804040"> 63 </span>    <span style="color:seagreen"><strong>void</strong></span> Insert(<span style="color:seagreen"><strong>const</strong></span> T&amp; aElement, CBinaryNode** appNode) <span style="color:seagreen"><strong>const</strong></span>;<br /><span style="color:#804040"> 64 </span>    <span style="color:seagreen"><strong>void</strong></span> Remove(<span style="color:seagreen"><strong>const</strong></span> T&amp; aElement, CBinaryNode** appNode) <span style="color:seagreen"><strong>const</strong></span>;<br /><span style="color:#804040"> 65 </span><br /><span style="color:#804040"> 66 </span>    CBinaryNode* FindMin(CBinaryNode* apNode) <span style="color:seagreen"><strong>const</strong></span>;<br /><span style="color:#804040"> 67 </span>    CBinaryNode* FindMax(CBinaryNode* apNode) <span style="color:seagreen"><strong>const</strong></span>;<br /><span style="color:#804040"> 68 </span>    <span style="color:seagreen"><strong>bool</strong></span> Contains(<span style="color:seagreen"><strong>const</strong></span> T&amp; aElement, CBinaryNode * apNode) <span style="color:seagreen"><strong>const</strong></span>;<br /><span style="color:#804040"> 69 </span>    <span style="color:seagreen"><strong>void</strong></span> MakeEmpty(CBinaryNode** apNode);<br /><span style="color:#804040"> 70 </span>    <span style="color:blue">//void PrintTree(CBinaryNode* apNode) const;</span><br /><span style="color:#804040"> 71 </span>    CBinaryNode* Clone(CBinaryNode* apNode) <span style="color:seagreen"><strong>const</strong></span>;<br /><span style="color:#804040"> 72 </span><br /><span style="color:#804040"> 73 </span>};<br /><span style="color:#804040"> 74 </span><br /><span style="color:#804040"> 75 </span><br /><span style="color:#804040"> 76 </span><span style="color:seagreen"><strong>template</strong></span>&lt;<span style="color:seagreen"><strong>typename</strong></span> T&gt;<br /><span style="color:#804040"> 77 </span><span style="color:seagreen"><strong>bool</strong></span> CBinarySearchTree<t>::Contains(<span style="color:seagreen"><strong>const</strong></span> T&amp; aElement) <span style="color:seagreen"><strong>const</strong></span><br /><span style="color:#804040"> 78 </span>{<br /><span style="color:#804040"> 79 </span>    <span style="color:#804040"><strong>return</strong></span> Contains(aElement, mpRoot);<br /><span style="color:#804040"> 80 </span>}<br /><span style="color:#804040"> 81 </span><br /><span style="color:#804040"> 82 </span><span style="color:seagreen"><strong>template</strong></span>&lt;<span style="color:seagreen"><strong>typename</strong></span> T&gt;<br /><span style="color:#804040"> 83 </span><span style="color:seagreen"><strong>bool</strong></span> CBinarySearchTree</t><t>::Contains(<span style="color:seagreen"><strong>const</strong></span> T &aElement;, CBinaryNode *apNode) <span style="color:seagreen"><strong>const</strong></span><br /><span style="color:#804040"> 84 </span>{<br /><span style="color:#804040"> 85 </span>    <span style="color:#804040"><strong>if</strong></span>( <span style="color:fuchsia">NULL</span> == apNode )<br /><span style="color:#804040"> 86 </span>    {<br /><span style="color:#804040"> 87 </span>        <span style="color:#804040"><strong>return</strong></span> <span style="color:fuchsia">false</span>;<br /><span style="color:#804040"> 88 </span>    }<br /><span style="color:#804040"> 89 </span>    <span style="color:#804040"><strong>else</strong></span> <span style="color:#804040"><strong>if</strong></span> ( aElement &lt; apNode-&gt;mElement )<br /><span style="color:#804040"> 90 </span>    {<br /><span style="color:#804040"> 91 </span>        <span style="color:#804040"><strong>return</strong></span> Contains(aElement, apNode-&gt;mpLeft);<br /><span style="color:#804040"> 92 </span>    }<br /><span style="color:#804040"> 93 </span>    <span style="color:#804040"><strong>else</strong></span> <span style="color:#804040"><strong>if</strong></span> ( aElement &gt; apNode-&gt;mElement )<br /><span style="color:#804040"> 94 </span>    {<br /><span style="color:#804040"> 95 </span>        <span style="color:#804040"><strong>return</strong></span> Contains(aElement, apNode-&gt;mpRight);<br /><span style="color:#804040"> 96 </span>    }<br /><span style="color:#804040"> 97 </span>    <span style="color:#804040"><strong>else</strong></span><br /><span style="color:#804040"> 98 </span>    {<br /><span style="color:#804040"> 99 </span>        <span style="color:#804040"><strong>return</strong></span> <span style="color:fuchsia">true</span>;      <span style="color:blue">// Find it</span><br /><span style="color:#804040">100 </span>    }<br /><span style="color:#804040">101 </span>}<br /><span style="color:#804040">102 </span><br /><span style="color:#804040">103 </span><span style="color:seagreen"><strong>template</strong></span>&lt;<span style="color:seagreen"><strong>typename</strong></span> T&gt;<br /><span style="color:#804040">104 </span><span style="color:seagreen"><strong>void</strong></span> CBinarySearchTree</t><t>::Insert(<span style="color:seagreen"><strong>const</strong></span> T &aElement;)<br /><span style="color:#804040">105 </span>{<br /><span style="color:#804040">106 </span>    Insert(aElement, &mpRoot;);<br /><span style="color:#804040">107 </span>}<br /><span style="color:#804040">108 </span><br /><span style="color:#804040">109 </span><span style="color:seagreen"><strong>template</strong></span>&lt;<span style="color:seagreen"><strong>typename</strong></span> T&gt;<br /><span style="color:#804040">110 </span><span style="color:seagreen"><strong>void</strong></span> CBinarySearchTree</t><t>::Insert(<span style="color:seagreen"><strong>const</strong></span> T&amp; aElement, CBinaryNode** appNode) <span style="color:seagreen"><strong>const</strong></span><br /><span style="color:#804040">111 </span>{<br /><span style="color:#804040">112 </span>    CBinaryNode *lpNode = *appNode;<br /><span style="color:#804040">113 </span>    <span style="color:#804040"><strong>if</strong></span>(<span style="color:fuchsia">NULL</span> == lpNode)<br /><span style="color:#804040">114 </span>    {<br /><span style="color:#804040">115 </span>        *appNode = <span style="color:#804040"><strong>new</strong></span> CBinaryNode(aElement, <span style="color:fuchsia">NULL</span>, <span style="color:fuchsia">NULL</span>);<br /><span style="color:#804040">116 </span>    }<br /><span style="color:#804040">117 </span>    <span style="color:#804040"><strong>else</strong></span> <span style="color:#804040"><strong>if</strong></span>( aElement &lt; lpNode-&gt;mElement )<br /><span style="color:#804040">118 </span>    {<br /><span style="color:#804040">119 </span>        Insert(aElement, &amp;(lpNode-&gt;mpLeft) );<br /><span style="color:#804040">120 </span>    }<br /><span style="color:#804040">121 </span>    <span style="color:#804040"><strong>else</strong></span> <span style="color:#804040"><strong>if</strong></span>( aElement &gt; lpNode-&gt;mElement)<br /><span style="color:#804040">122 </span>    {<br /><span style="color:#804040">123 </span>        Insert(aElement, &amp;(lpNode-&gt;mpRight) );<br /><span style="color:#804040">124 </span>    }<br /><span style="color:#804040">125 </span><br /><span style="color:#804040">126 </span>    <span style="color:blue">// had not deal with duplicate</span><br /><span style="color:#804040">127 </span>}<br /><span style="color:#804040">128 </span><br /><span style="color:#804040">129 </span><span style="color:seagreen"><strong>template</strong></span>&lt;<span style="color:seagreen"><strong>typename</strong></span> T&gt;<br /><span style="color:#804040">130 </span><span style="color:seagreen"><strong>void</strong></span> CBinarySearchTree</t><t>::Remove(<span style="color:seagreen"><strong>const</strong></span> T &aElement;)<br /><span style="color:#804040">131 </span>{<br /><span style="color:#804040">132 </span>    Remove(aElement, &mpRoot;);<br /><span style="color:#804040">133 </span>}<br /><span style="color:#804040">134 </span><br /><span style="color:#804040">135 </span><span style="color:seagreen"><strong>template</strong></span>&lt;<span style="color:seagreen"><strong>typename</strong></span> T&gt;<br /><span style="color:#804040">136 </span><span style="color:seagreen"><strong>void</strong></span> CBinarySearchTree</t><t>::Remove(<span style="color:seagreen"><strong>const</strong></span> T &aElement;, CBinaryNode** appNode) <span style="color:seagreen"><strong>const</strong></span><br /><span style="color:#804040">137 </span>{<br /><span style="color:#804040">138 </span>    CBinaryNode* lpNode = *appNode;<br /><span style="color:#804040">139 </span>    <span style="color:#804040"><strong>if</strong></span>(<span style="color:fuchsia">NULL</span> == lpNode)<br /><span style="color:#804040">140 </span>    {<br /><span style="color:#804040">141 </span>        <span style="color:#804040"><strong>return</strong></span>;       <span style="color:blue">// Item removing is not exist</span><br /><span style="color:#804040">142 </span>    }<br /><span style="color:#804040">143 </span><br /><span style="color:#804040">144 </span>    <span style="color:#804040"><strong>if</strong></span>( aElement &lt; lpNode-&gt;mElement )<br /><span style="color:#804040">145 </span>    {<br /><span style="color:#804040">146 </span>        Remove(aElement, &amp;(lpNode-&gt;mpLeft) );<br /><span style="color:#804040">147 </span>    }<br /><span style="color:#804040">148 </span>    <span style="color:#804040"><strong>else</strong></span> <span style="color:#804040"><strong>if</strong></span>( aElement &gt; lpNode-&gt;mElement )<br /><span style="color:#804040">149 </span>    {<br /><span style="color:#804040">150 </span>        Remove(aElement, &amp;(lpNode-&gt;mpRight) );<br /><span style="color:#804040">151 </span>    }<br /><span style="color:#804040">152 </span>    <span style="color:#804040"><strong>else</strong></span> <span style="color:#804040"><strong>if</strong></span>( <span style="color:fuchsia">NULL</span> != lpNode-&gt;mpLeft &amp;&amp; <span style="color:fuchsia">NULL</span> != lpNode-&gt;mpRight) <span style="color:blue">// Two children</span><br /><span style="color:#804040">153 </span>    {<br /><span style="color:#804040">154 </span>        lpNode-&gt;mElement = FindMin(lpNode-&gt;mpRight)-&gt;mElement;<br /><span style="color:#804040">155 </span>        Remove( lpNode-&gt;mElement, &amp;(lpNode-&gt;mpRight) );<br /><span style="color:#804040">156 </span>    }<br /><span style="color:#804040">157 </span>    <span style="color:#804040"><strong>else</strong></span><br /><span style="color:#804040">158 </span>    {<br /><span style="color:#804040">159 </span>        CBinaryNode *lpOldNode = lpNode;<br /><span style="color:#804040">160 </span>        <span style="color:blue">// Even if lpNode equal NULL, this is still the right behavior we need</span><br /><span style="color:#804040">161 </span>        <span style="color:blue">// Yeah,When lpNode have no children,we make lpNode equal NULL</span><br /><span style="color:#804040">162 </span>        *appNode = (lpNode-&gt;mpLeft != <span style="color:fuchsia">NULL</span>) ? lpNode-&gt;mpLeft : lpNode-&gt;mpRight;<br /><span style="color:#804040">163 </span>        <span style="color:#804040"><strong>delete</strong></span> lpOldNode;<br /><span style="color:#804040">164 </span>    }<br /><span style="color:#804040">165 </span>}<br /><span style="color:#804040">166 </span><br /><span style="color:#804040">167 </span><br /><span style="color:#804040">168 </span><span style="color:seagreen"><strong>template</strong></span>&lt;<span style="color:seagreen"><strong>typename</strong></span> T&gt;<br /><span style="color:#804040">169 </span><span style="color:seagreen"><strong>const</strong></span> T* CBinarySearchTree</t><t>::FindMin() <span style="color:seagreen"><strong>const</strong></span><br /><span style="color:#804040">170 </span>{<br /><span style="color:#804040">171 </span>    CBinaryNode* lpNode = FindMin(mpRoot);<br /><span style="color:#804040">172 </span>    <span style="color:#804040"><strong>return</strong></span> (lpNode != <span style="color:fuchsia">NULL</span>) ? &amp;(lpNode-&gt;mElement) : <span style="color:fuchsia">NULL</span>;<br /><span style="color:#804040">173 </span>}<br /><span style="color:#804040">174 </span><br /><span style="color:#804040">175 </span><br /><span style="color:#804040">176 </span><span style="color:blue">// damn it! So redundant words to fit to C++ syntax</span><br /><span style="color:#804040">177 </span><span style="color:blue">// the only way to fix this problom is compositing defines and declares</span><br /><span style="color:#804040">178 </span><span style="color:blue">// I even doubt that are there programmers could write it right </span><br /><span style="color:#804040">179 </span><span style="color:seagreen"><strong>template</strong></span>&lt;<span style="color:seagreen"><strong>typename</strong></span> T&gt;<br /><span style="color:#804040">180 </span><span style="color:seagreen"><strong>typename</strong></span> CBinarySearchTree</t><t>::CBinaryNode * CBinarySearchTree</t><t>::FindMin(CBinaryNode* apNode) <span style="color:seagreen"><strong>const</strong></span><br /><span style="color:#804040">181 </span>{<br /><span style="color:#804040">182 </span>    <span style="color:#804040"><strong>if</strong></span>( <span style="color:fuchsia">NULL</span> == apNode)<br /><span style="color:#804040">183 </span>    {<br /><span style="color:#804040">184 </span>        <span style="color:#804040"><strong>return</strong></span> <span style="color:fuchsia">NULL</span>;<br /><span style="color:#804040">185 </span>    }<br /><span style="color:#804040">186 </span>    <span style="color:#804040"><strong>else</strong></span> <span style="color:#804040"><strong>if</strong></span>( <span style="color:fuchsia">NULL</span> == apNode-&gt;mpLeft)<br /><span style="color:#804040">187 </span>    {<br /><span style="color:#804040">188 </span>        <span style="color:blue">// Find it</span><br /><span style="color:#804040">189 </span>        <span style="color:#804040"><strong>return</strong></span> apNode;<br /><span style="color:#804040">190 </span>    }<br /><span style="color:#804040">191 </span>    <span style="color:#804040"><strong>else</strong></span> <br /><span style="color:#804040">192 </span>    {<br /><span style="color:#804040">193 </span>        <span style="color:#804040"><strong>return</strong></span> FindMin(apNode-&gt;mpLeft);<br /><span style="color:#804040">194 </span>    }<br /><span style="color:#804040">195 </span>}<br /><span style="color:#804040">196 </span><br /><span style="color:#804040">197 </span><span style="color:seagreen"><strong>template</strong></span>&lt;<span style="color:seagreen"><strong>typename</strong></span> T&gt;<br /><span style="color:#804040">198 </span><span style="color:seagreen"><strong>const</strong></span> T* CBinarySearchTree</t><t>::FindMax() <span style="color:seagreen"><strong>const</strong></span><br /><span style="color:#804040">199 </span>{<br /><span style="color:#804040">200 </span>    CBinaryNode* lpNode = FindMax(mpRoot);<br /><span style="color:#804040">201 </span>    <span style="color:#804040"><strong>return</strong></span> (lpNode != <span style="color:fuchsia">NULL</span>) ? &amp;(lpNode-&gt;mElement) : <span style="color:fuchsia">NULL</span>;<br /><span style="color:#804040">202 </span>}<br /><span style="color:#804040">203 </span><br /><span style="color:#804040">204 </span><span style="color:seagreen"><strong>template</strong></span>&lt;<span style="color:seagreen"><strong>typename</strong></span> T&gt;<br /><span style="color:#804040">205 </span><span style="color:seagreen"><strong>typename</strong></span> CBinarySearchTree</t><t>::CBinaryNode * CBinarySearchTree</t><t>::FindMax(CBinaryNode* apNode) <span style="color:seagreen"><strong>const</strong></span><br /><span style="color:#804040">206 </span>{<br /><span style="color:#804040">207 </span>    <span style="color:#804040"><strong>if</strong></span>( <span style="color:fuchsia">NULL</span> == apNode)<br /><span style="color:#804040">208 </span>    {<br /><span style="color:#804040">209 </span>        <span style="color:#804040"><strong>return</strong></span> <span style="color:fuchsia">NULL</span>;<br /><span style="color:#804040">210 </span>    }<br /><span style="color:#804040">211 </span>    <span style="color:#804040"><strong>else</strong></span> <span style="color:#804040"><strong>if</strong></span>( <span style="color:fuchsia">NULL</span> == apNode-&gt;mpRight)<br /><span style="color:#804040">212 </span>    {<br /><span style="color:#804040">213 </span>        <span style="color:blue">// Find it</span><br /><span style="color:#804040">214 </span>        <span style="color:#804040"><strong>return</strong></span> apNode;<br /><span style="color:#804040">215 </span>    }<br /><span style="color:#804040">216 </span>    <span style="color:#804040"><strong>else</strong></span> <br /><span style="color:#804040">217 </span>    {<br /><span style="color:#804040">218 </span>        <span style="color:#804040"><strong>return</strong></span> FindMax(apNode-&gt;mpRight);<br /><span style="color:#804040">219 </span>    }<br /><span style="color:#804040">220 </span>}<br /><span style="color:#804040">221 </span><br /><span style="color:#804040">222 </span><span style="color:seagreen"><strong>template</strong></span>&lt;<span style="color:seagreen"><strong>typename</strong></span> T&gt;<br /><span style="color:#804040">223 </span><span style="color:seagreen"><strong>void</strong></span> CBinarySearchTree</t><t>::MakeEmpty()<br /><span style="color:#804040">224 </span>{<br /><span style="color:#804040">225 </span>    MakeEmpty(&mpRoot;);<br /><span style="color:#804040">226 </span>}<br /><span style="color:#804040">227 </span><br /><span style="color:#804040">228 </span><br /><span style="color:#804040">229 </span><span style="color:seagreen"><strong>template</strong></span>&lt;<span style="color:seagreen"><strong>typename</strong></span> T&gt;<br /><span style="color:#804040">230 </span><span style="color:seagreen"><strong>void</strong></span> CBinarySearchTree</t><t>::MakeEmpty(CBinaryNode** appNode)<br /><span style="color:#804040">231 </span>{<br /><span style="color:#804040">232 </span>    CBinaryNode* lpNode = *appNode;<br /><span style="color:#804040">233 </span>    <span style="color:#804040"><strong>if</strong></span>( lpNode != <span style="color:fuchsia">NULL</span>)<br /><span style="color:#804040">234 </span>    {<br /><span style="color:#804040">235 </span>        MakeEmpty( &amp;(lpNode-&gt;mpLeft) );<br /><span style="color:#804040">236 </span>        MakeEmpty( &amp;(lpNode-&gt;mpRight) );<br /><span style="color:#804040">237 </span>        <span style="color:#804040"><strong>delete</strong></span> lpNode;<br /><span style="color:#804040">238 </span>    }<br /><span style="color:#804040">239 </span><br /><span style="color:#804040">240 </span>    *appNode = <span style="color:fuchsia">NULL</span>;<br /><span style="color:#804040">241 </span>}<br /><span style="color:#804040">242 </span><br /><span style="color:#804040">243 </span><span style="color:blue">// how long the syntax is...............</span><br /><span style="color:#804040">244 </span><span style="color:seagreen"><strong>template</strong></span>&lt;<span style="color:seagreen"><strong>typename</strong></span> T&gt;<br /><span style="color:#804040">245 </span><span style="color:seagreen"><strong>const</strong></span> CBinarySearchTree</t><t>&amp; CBinarySearchTree</t><t>::<span style="color:#804040"><strong>operator</strong></span> =(<span style="color:seagreen"><strong>const</strong></span> CBinarySearchTree</t><t> &aOrig;)<br /><span style="color:#804040">246 </span>{<br /><span style="color:#804040">247 </span>    <span style="color:#804040"><strong>if</strong></span>(&aOrig; == <span style="color:#804040"><strong>this</strong></span>)<br /><span style="color:#804040">248 </span>    {<br /><span style="color:#804040">249 </span>        <span style="color:#804040"><strong>return</strong></span> *<span style="color:#804040"><strong>this</strong></span>;<br /><span style="color:#804040">250 </span>    }<br /><span style="color:#804040">251 </span><br /><span style="color:#804040">252 </span>    MakeEmpty();<br /><span style="color:#804040">253 </span>    mpRoot = Clone(aOrig.mpRoot);<br /><span style="color:#804040">254 </span><br /><span style="color:#804040">255 </span>    <span style="color:#804040"><strong>return</strong></span> *<span style="color:#804040"><strong>this</strong></span>;<br /><span style="color:#804040">256 </span><br /><span style="color:#804040">257 </span>}<br /><span style="color:#804040">258 </span><br /><span style="color:#804040">259 </span><span style="color:blue">// when you use nest class and template both,you will find out how long the C++ syntax is.....</span><br /><span style="color:#804040">260 </span><span style="color:blue">// I use it once,I ask why couldn't we have a short once again.</span><br /><span style="color:#804040">261 </span><span style="color:seagreen"><strong>template</strong></span>&lt;<span style="color:seagreen"><strong>typename</strong></span> T&gt;<br /><span style="color:#804040">262 </span><span style="color:seagreen"><strong>typename</strong></span> CBinarySearchTree</t><t>::CBinaryNode* CBinarySearchTree</t><t>::Clone(CBinaryNode *apNode) <span style="color:seagreen"><strong>const</strong></span><br /><span style="color:#804040">263 </span>{<br /><span style="color:#804040">264 </span>    <span style="color:#804040"><strong>if</strong></span>(<span style="color:fuchsia">NULL</span> == apNode)<br /><span style="color:#804040">265 </span>    {<br /><span style="color:#804040">266 </span>        <span style="color:#804040"><strong>return</strong></span> <span style="color:fuchsia">NULL</span>;<br /><span style="color:#804040">267 </span>    }<br /><span style="color:#804040">268 </span><br /><span style="color:#804040">269 </span>    <span style="color:blue">// abuse recursion</span><br /><span style="color:#804040">270 </span>    <span style="color:#804040"><strong>return</strong></span> <span style="color:#804040"><strong>new</strong></span> CBinaryNode(apNode-&gt;mElement, Clone(apNode-&gt;mpLeft), Clone(apNode-&gt;mpRight));<br /><span style="color:#804040">271 </span>}<br /><span style="color:#804040">272 </span><br /><span style="color:#804040">273 </span><br /><span style="color:#804040">274 </span><br /><span style="color:#804040">275 </span><br /><span style="color:#804040">276 </span><span style="color:#a020f0">#endif</span> <span style="color:blue">// __BINARY_SEARCH_TREE_H__<br />
</span></t></span></p>
<p>
 </p>
<p>
 </p>
<p><span style="color:blue"><span style="font-family:宋体">测试代码：</span><span style="font-family:Courier New"><br />
</span></span></p>
<p><span style="font-family:Courier New"><span style="color:#804040"> 1 </span><span style="color:#a020f0">#include </span><span style="color:fuchsia"><iostream></iostream></span><br /><span style="color:#804040"> 2 </span><span style="color:#a020f0">#include </span><span style="color:fuchsia">"BinarySearchTree.h"</span><br /><span style="color:#804040"> 3 <strong>using</strong></span> <span style="color:seagreen"><strong>namespace</strong></span> std;<br /><span style="color:#804040"> 4 </span><br /><span style="color:#804040"> 5 </span><span style="color:seagreen"><strong>int</strong></span> _tmain(<span style="color:seagreen"><strong>int</strong></span> argc, _TCHAR* argv[])<br /><span style="color:#804040"> 6 </span>{<br /><span style="color:#804040"> 7 </span>    CBinarySearchTree&lt;<span style="color:seagreen"><strong>int</strong></span>&gt; loTree;<br /><span style="color:#804040"> 8 </span><br /><span style="color:#804040"> 9 </span>    loTree.Insert(<span style="color:fuchsia">10</span>);<br /><span style="color:#804040">10 </span>    loTree.Insert(<span style="color:fuchsia">20</span>);<br /><span style="color:#804040">11 </span>    loTree.Insert(<span style="color:fuchsia">30</span>);<br /><span style="color:#804040">12 </span>    loTree.Insert(<span style="color:fuchsia">40</span>);<br /><span style="color:#804040">13 </span>    cout &lt;&lt;<span style="color:fuchsia">"Min: "</span> &lt;&lt;*loTree.FindMin() &lt;&lt;<span style="color:fuchsia">" Max: "</span> &lt;&lt;*loTree.FindMax() &lt;&lt;<span style="color:fuchsia">" IsContains(20)  "</span>&lt;<lotree.contains><span style="color:fuchsia">20</span>) &lt;<endl><br /><span style="color:#804040">14 </span>    loTree.Remove(<span style="color:fuchsia">40</span>);<br /><span style="color:#804040">15 </span>    cout &lt;&lt;<span style="color:fuchsia">"Min: "</span> &lt;&lt;*loTree.FindMin() &lt;&lt;<span style="color:fuchsia">" Max: "</span> &lt;&lt;*loTree.FindMax() &lt;&lt;<span style="color:fuchsia">" IsContains(20)  "</span> &lt;</endl></lotree.contains><lotree.contains><span style="color:fuchsia">20</span>) &lt;<endl><br /><span style="color:#804040">16 </span>    loTree.Remove(<span style="color:fuchsia">30</span>);<br /><span style="color:#804040">17 </span>    loTree.Remove(<span style="color:fuchsia">20</span>);<br /><span style="color:#804040">18 </span>    loTree.Remove(<span style="color:fuchsia">10</span>);<br /><span style="color:#804040">19 </span><br /><span style="color:#804040">20 </span><br /><span style="color:#804040">21 </span>    loTree.Insert(<span style="color:fuchsia">40</span>);<br /><span style="color:#804040">22 </span>    cout &lt;&lt;<span style="color:fuchsia">"Min: "</span> &lt;&lt;*loTree.FindMin() &lt;&lt;<span style="color:fuchsia">" Max: "</span> &lt;&lt;*loTree.FindMax() &lt;&lt;<span style="color:fuchsia">" IsContains(20)  "</span> &lt;</endl></lotree.contains><lotree.contains><span style="color:fuchsia">20</span>) &lt;<endl><br /><span style="color:#804040">23 </span>    loTree.Insert(<span style="color:fuchsia">30</span>);<br /><span style="color:#804040">24 </span>    loTree.Insert(<span style="color:fuchsia">20</span>);<br /><span style="color:#804040">25 </span>    loTree.Insert(<span style="color:fuchsia">10</span>);<br /><span style="color:#804040">26 </span>    cout &lt;&lt;<span style="color:fuchsia">"Min: "</span> &lt;&lt;*loTree.FindMin() &lt;&lt;<span style="color:fuchsia">" Max: "</span> &lt;&lt;*loTree.FindMax() &lt;&lt;<span style="color:fuchsia">" IsContains(20)  "</span> &lt;</endl></lotree.contains><lotree.contains><span style="color:fuchsia">20</span>) &lt;<endl><br /><span style="color:#804040">27 </span>    loTree.Remove(<span style="color:fuchsia">40</span>);<br /><span style="color:#804040">28 </span>    loTree.Remove(<span style="color:fuchsia">30</span>);<br /><span style="color:#804040">29 </span>    loTree.Remove(<span style="color:fuchsia">20</span>);<br /><span style="color:#804040">30 </span>    loTree.Remove(<span style="color:fuchsia">10</span>);<br /><span style="color:#804040">31 </span><br /><span style="color:#804040">32 </span>    loTree.Insert(<span style="color:fuchsia">30</span>);<br /><span style="color:#804040">33 </span>    loTree.Insert(<span style="color:fuchsia">40</span>);<br /><span style="color:#804040">34 </span>    cout &lt;&lt;<span style="color:fuchsia">"Min: "</span> &lt;&lt;*loTree.FindMin() &lt;&lt;<span style="color:fuchsia">" Max: "</span> &lt;&lt;*loTree.FindMax() &lt;&lt;<span style="color:fuchsia">" IsContains(20)  "</span> &lt;</endl></lotree.contains><lotree.contains><span style="color:fuchsia">20</span>) &lt;<endl><br /><span style="color:#804040">35 </span>    loTree.Insert(<span style="color:fuchsia">10</span>);<br /><span style="color:#804040">36 </span>    loTree.Insert(<span style="color:fuchsia">20</span>);<br /><span style="color:#804040">37 </span>    cout &lt;&lt;<span style="color:fuchsia">"Min: "</span> &lt;&lt;*loTree.FindMin() &lt;&lt;<span style="color:fuchsia">" Max: "</span> &lt;&lt;*loTree.FindMax() &lt;&lt;<span style="color:fuchsia">" IsContains(20)  "</span> &lt;</endl></lotree.contains><lotree.contains><span style="color:fuchsia">20</span>) &lt;<endl><br /><span style="color:#804040">38 </span>    CBinarySearchTree&lt;<span style="color:seagreen"><strong>int</strong></span>&gt; loTree2 = loTree;<br /><span style="color:#804040">39 </span>    cout &lt;&lt;<span style="color:fuchsia">"Min: "</span> &lt;&lt;*loTree2.FindMin() &lt;&lt;<span style="color:fuchsia">" Max: "</span> &lt;&lt;*loTree2.FindMax() &lt;&lt;<span style="color:fuchsia">" IsContains(20)  "</span> &lt;<lotree2.contains><span style="color:fuchsia">20</span>) &lt;</lotree2.contains></endl><endl><br /><span style="color:#804040">40 </span><br /><span style="color:#804040">41 </span>    loTree.MakeEmpty();<br /><span style="color:#804040">42 </span><br /><span style="color:#804040">43 </span><br /><span style="color:#804040">44 </span><br /><span style="color:#804040">45 </span>    system(<span style="color:fuchsia">"pause"</span>);<br /><span style="color:#804040">46 </span>    <span style="color:#804040"><strong>return</strong></span> <span style="color:fuchsia">0</span>;<br /><span style="color:#804040">47 </span>}<br /><span style="color:#804040">48</span></endl></lotree.contains></span><span style="font-family:宋体"><br />
</span></p>
<p style="text-align: right">
 </p>
<p style="text-align: right">
 </p>
<p style="text-align: right">
 </p>
<p style="text-align: right">
 </p>
<p style="text-align: right">
 </p>
<p style="text-align: right">
 </p>
<p style="text-align: right"><span style="color:#c0504d; text-decoration:underline"><strong>write by <span style="font-family:宋体">九天雁翎</span>(JTianLing) -- www.jtianling.com</strong></span></p>
