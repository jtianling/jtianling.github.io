---
layout: post
title: "写递归函数的正确思维方法"
date: 2013-01-05
comments: true
categories: 编程
tags: 递归 Lisp Ruby
---

递归是编程中一个相对难以理解但是却又很重要的概念. 对于从命令式语言开始学习编程的程序员天生对此有理解缺陷, 而对于从类似C++这种对函数式编程范式不友好的语言开始学习编程的程序员就更加如此了.(比如我自己) 碰巧(其实不巧)最近在读<Ansi Common Lisp>这本书(这本书国内没有引进, 网上只有巨贵的[亚马逊卖的原版](http://www.amazon.cn/gp/product/0133708756/ref=as_li_ss_tl?ie=UTF8&tag=jtianlinsblog-23&linkCode=as2&camp=536&creative=3132&creativeASIN=0133708756), 我读的是[网上的中文版](http://acl.readthedocs.org/en/latest/)), Paul Graham在书中讲述的如何写递归函数的部分, 让我印象深刻.  因为原书是讲Lisp的, 当然这个部分也是用Lisp作为例子描述的, 考虑到国内会看这本书的人太少, 能看懂Lisp的就更不多了, 我这里根据自己的理解, 重新整理一下.  最重要的是, 书中原来的例子太少, 太简单, 我自己提供了一些额外的, 并且更加复杂的例子.  以期对问题能有更好的理解.
<!-- more -->

# 什么是递归  

> 迭代的是人，递归的是神
> --L. Peter Deutsch

简单的定义: "当函数直接或者间接调用自己时，则发生了递归."  说起来简单, 但是理解起来复杂, 因为递归并不直观, 也不符合我们的思维习惯, 相对于递归, 我们更加容易理解迭代. 因为我们日常生活中的思维方式就是一步接一步的, 并且能够理解一件事情做了N遍这个概念.  而我们日常生活中几乎不会有递归思维的出现.  
举个简单的例子, 即在C/C++中计算一个字符串的长度.  下面是传统的方式, 我们一般都这样通过迭代来计算长度, 也很好理解.

~~~ cpp
size_t length(const char *str) {
	size_t length = 0;
	while (*str != 0) {
		++length;
		++str;
	}

	return length;
}
~~~

而事实上, 我们也可以通过递归来完成这样的任务.  

~~~ cpp
size_t length(const char *str) {
	if (*str == 0) {
		return 0;
	}
	return length(++str) + 1;
}
~~~

只不过, 我们都不这么做罢了, 虽然这样的实现有的时候可能代码更短, 但是很明显, 从思维上来说更加难以理解一些.  当然, 我是说假如你不是习惯于函数式语言的话.  这个例子相对简单, 稍微看一下还是能明白吧.  
迭代的算法可以这样描述: 从第一个字符开始判断字符串的每一个字符, 当该字符不为0的时候, 该字符串的长度加一.  
递归的算法可以这样描述: 当前字符串的长度等于当前字符串除了首字符后, 剩下的字符串长度+1.  
作为这么简单的例子, 两种算法其实大同小异, 虽然我们习惯迭代, 但是, 也能看到, 递归的算法无论是从描述上还是实际实现上, 并不比迭代要麻烦.  
# 理解递归
在初学递归的时候, 看到一个递归实现, 我们总是难免陷入不停的回溯验证之中, 因为回溯就像反过来思考迭代, 这是我们习惯的思维方式, 但是实际上递归不需要这样来验证.  比如, 另外一个常见的例子是[阶乘](http://zh.wikipedia.org/zh-cn/%E9%9A%8E%E4%B9%98)的计算.  阶乘的定义: "一个正整数的阶乘（英语：factorial）是所有小于或等于该数的正整数的积，并且0的阶乘为1。"  以下是Ruby的实现:  

~~~ ruby
def factorial(n) 
	if n <= 1 then
	return 1
	else
return n * factorial(n - 1)
	end
	end
~~~

我们怎么判断这个阶乘的递归计算是否是正确的呢? 先别说测试, 我说我们读代码的时候怎么判断呢?
回溯的思考方式是这么验证的, 比如当n = 4时, 那么`factoria(4)`等于`4 * factoria(3)`, 而`factoria(3)`等于`3 * factoria(2)`, `factoria(2)`等于`2 * factoria(1)`, 等于`2 * 1`, 所以`factoria(4)`等于`4 * 3 * 2 * 1`. 这个结果正好等于阶乘4的迭代定义.
用回溯的方式思考虽然可以验证当n = 某个较小数值是否正确, 但是其实无益于理解.
Paul Graham提到一种方法, 给我很大启发, 该方法如下:

> 1. 当n=0, 1的时候, 结果正确.
> 2. 假设函数对于n是正确的, 函数对n+1结果也正确.
> 如果这两点是成立的，我们知道这个函数对于所有可能的n都是正确的.

这种方法很像[数学归纳法](http://zh.wikipedia.org/zh/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95), 也是递归正确的思考方式, 事实上, 阶乘的递归表达方式就是`1!=1，n!=(n-1)!×n`(见[wiki](http://zh.wikipedia.org/zh-cn/%E9%9A%8E%E4%B9%98)).  当程序实现符合算法描述的时候, 程序自然对了, 假如还不对, 那是算法本身错了...... 相对来说, n,n+1的情况为通用情况, 虽然比较复杂, 但是还能理解, 最重要的, 也是最容易被新手忽略的问题在于第1点, 也就是基本用例(base case)要对.  比如, 上例中, 我们去掉`if n <= 1`的判断后, 代码会进入死循环, 永远不会结束.

# 使用递归
既然递归比迭代要难以理解, 为啥我们还需要递归呢? 从上面的例子来看, 自然意义不大, 但是很多东西的确用递归思维会更加简单......  
经典的例子就是[斐波那契数列](http://zh.wikipedia.org/zh-cn/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97), 在数学上, 斐波那契数列就是用递归来定义的:

> F0 = 0  
> F1 = 1  
> Fn = Fn - 1 + Fn - 2  

有了递归的算法, 用程序实现实在再简单不过了:

~~~ ruby
def fibonacci(n)
	if n == 0 then
	return 0
	elsif n == 1 then
	return 1
	else
return fibonacci(n - 1) + fibonacci(n - 2)
	end
	end
~~~

改为用迭代实现呢? 你可以试试.
上面讲了怎么理解递归是正确的, 同时可以看到在有递归算法描述后, 其实程序很容易写, 那么最关键的问题就是, 我们怎么找到一个问题的递归算法呢?
Paul Graham提到, 你只需要做两件事情:

> 1. 你必须要示范如何解决问题的一般情况, 通过将问题切分成有限小并更小的子问题.  
> 2. 你必须要示范如何通过有限的步骤, 来解决最小的问题(基本用例).  
> 如果这两件事完成了, 那问题就解决了.  因为递归每次都将问题变得更小, 而一个有限的问题终究会被解决的, 而最小的问题仅需几个有限的步骤就能解决.

这个过程还是数学归纳法的方法, 只不过和上面提到的一个是验证, 一个是证明.
现在我们用这个方法来寻找[汉诺塔](http://zh.wikipedia.org/zh-cn/%E6%B1%89%E8%AF%BA%E5%A1%94)这个游戏的解决方法.(这其实是数学家发明的游戏)

> 有三根杆子A，B，C。A杆上有N个(N>1)穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至C杆：
> 1.每次只能移动一个圆盘.
> 2.大盘不能叠在小盘上面.

![汉诺塔](http://jtianling.s3.amazonaws.com/images/220px-Tower_of_Hanoi.jpeg)
这个游戏在只有3个盘的时候玩起来较为简单, 盘越多, 就越难, 玩进去后, 你就会进入一种不停的通过回溯来推导下一步该干什么的状态, 这是比较难的.  我记得第一次碰到这个游戏好像是在*大航海时代*某一代游戏里面, 当时就觉得挺有意思的.  推荐大家都实际的玩一下这个游戏, 试试你脑袋能想清楚几个盘的情况.
现在我们来应用Paul Graham的方法思考这个游戏.  

一般情况:
当有N个圆盘在A上, 我们已经找到办法将其移到C杠上了, 我们怎么移动N+1个圆盘到C杠上呢? 很简单, 我们首先用将N个圆盘移动到C上的方法将N个圆盘都移动到B上, 然后再把第N+1个圆盘(最后一个)移动到C上, 再用同样的方法将在B杠上的N个圆盘移动到C上.  问题解决.
基本用例:
当有1个圆盘在A上, 我们直接把圆盘移动到C上即可.
算法描述大概就是上面这样了, 其实也可以看作思维的过程, 相对来说还是比较自然的.  下面是Ruby解:

~~~ ruby
def hanoi(n, from, to, other)
	if n == 1 then
	puts from + ' -> ' + to
	else
	hanoi(n-1, from, other, to)
	hanoi(1, from, to, other)
hanoi(n-1, other, to, from)
	end
	end
~~~

当n=3时的输出:
> A -> C
> A -> B
> C -> B
> A -> C
> B -> A
> B -> C
> A -> C

上述代码中, from, to, other的作用其实也就是提供一个杆子的替代符, 在n=1时, 其实也就相当于直接移动.  看起来这么复杂的问题, 其实用递归这么容易, 没有想到吧.  要是想用迭代来解决这个问题呢? 还是你自己试试吧, 你试的越多, 就能越体会到递归的好处.  

# 递归的问题
当然, 这个世界上没有啥时万能的, 递归也不例外, 首先递归并不一定适用所有情况, 很多情况用迭代远远比用递归好了解, 其次, 相对来说, 递归的效率往往要低于迭代的实现, 同时, 内存耗用也会更大, 虽然这个时候可以用[尾递归](http://zh.wikipedia.org/zh-cn/%E5%B0%BE%E9%80%92%E5%BD%92)来优化, 但是尾递归并不是一定能简单做到.

# 参考
1. [*Ansi Common Lisp*](http://acl.readthedocs.org/en/latest/)  
2. [*精通递归程序设计*](http://www.ibm.com/developerworks/cn/linux/l-recurs.html)
